#+title: Jacob Chaffin's Literate Emacs Configuration
#+language: en
#+AUTHOR: Jacob Chaffin
#+STARTUP: hideblock
#+OPTIONS: num:nil toc:2 tags:nil todo:nil H:3 tex:nil latex:nil
#+PROPERTY: header-args:emacs-lisp :tangle no
#+SETUPFILE: ./etc/html-theme/theme-readtheorg.setup

* Table Of Contents :TOC_3_gh:noexport:
- [[#preface][Preface]]
  - [[#about-this-document][About this document]]
  - [[#literate-programming][Literate Programming]]
  - [[#influences][Influences]]
- [[#base-configuration][Base Configuration]]
  - [[#tangle-file][Tangle File]]
  - [[#straightel][straight.el]]
    - [[#goto-local-package-repository][Goto local package repository]]
    - [[#browse-straight-repository-at-github][Browse straight repository at GitHub]]
    -  [[#straight-hydra-menu][Straight Hydra Menu]]
  - [[#user-information][User Information]]
  - [[#customization-group][Customization Group]]
  - [[#core][Core]]
    - [[#libraries][Libraries]]
    - [[#el-patch][El Patch]]
    - [[#constants][Constants]]
    - [[#macros][Macros]]
    - [[#functions][Functions]]
    - [[#default-setup][Default Setup]]
    - [[#encryption][Encryption]]
    - [[#alias-yes-or-no][Alias Yes Or No]]
  - [[#keybindings][Keybindings]]
    - [[#global-prefix-map][Global Prefix Map]]
    - [[#hydra][Hydra]]
    - [[#smartrep][Smartrep]]
    - [[#which-key][Which Key]]
    - [[#reload-eval][Reload Eval]]
    - [[#speed-type][Speed Type]]
  - [[#system][System]]
    - [[#use-emacs-terminfo][Use Emacs terminfo]]
    - [[#utf-8-encoding][UTF-8 Encoding]]
    - [[#pickup-environment-variables][Pickup environment variables]]
    - [[#system-packages][System Packages]]
    - [[#ensure-system-package][Ensure system package]]
    - [[#prodigy][Prodigy]]
  - [[#macos][macOS]]
    - [[#macos-keys][MacOS Keys]]
    - [[#macos-computer-name][MacOS Computer Name]]
    - [[#macos-dev-utils][MacOS Dev Utils]]
    - [[#macos-dash][MacOS Dash]]
    - [[#reveal-in-macos-finder][Reveal in macOS Finder]]
    - [[#osx-dictionary][OSX Dictionary]]
    - [[#osx-trash][OSX Trash]]
    - [[#osx-clipboard][OSX Clipboard]]
    - [[#counsel-osx-app][Counsel OSX App]]
- [[#tex-and-org-mode][Tex and Org Mode]]
  - [[#latex][Latex]]
    - [[#auctex][Auctex]]
    - [[#tex][Tex]]
    - [[#reftex][Reftex]]
    - [[#bibtex][BibTex]]
    - [[#extra][Extra]]
    - [[#preview][Preview]]
    - [[#company-auctex][Company Auctex]]
    - [[#company-reftex][Company Reftex]]
    - [[#cdlatex][cdlatex]]
    - [[#magic-latex-buffer][Magic Latex Buffer]]
    - [[#auctex-latexmk][Auctex Latexmk]]
    - [[#texinfo][Texinfo]]
    - [[#latex-math][LaTeX Math]]
  - [[#org-mode][Org Mode]]
    - [[#org-command-map][Org Command Map]]
    - [[#org-babel][Org Babel]]
    - [[#org-appearance][Org Appearance]]
    - [[#structure-and-editing][Structure and Editing]]
    - [[#task-management][Task Management]]
    - [[#concept-mapping][Concept Mapping]]
    - [[#org-hacks][Org Hacks]]
    - [[#ox][Ox]]
    - [[#ox-backends][Ox Backends]]
    - [[#ox-extra][Ox Extra]]
    - [[#ox-publish][Ox Publish]]
    - [[#ox-org][Ox Org]]
    - [[#ox-latex][Ox Latex]]
    - [[#ox-linguistics][Ox Linguistics]]
    - [[#ox-bibtex][Ox Bibtex]]
    - [[#ox-pandoc][Ox Pandoc]]
    - [[#ox-gfm][Ox GFM]]
    - [[#ox-hugo][Ox Hugo]]
    - [[#ox-html][Ox HTML]]
  - [[#org-latex][Org Latex]]
    - [[#latex-in-org-buffers][LaTeX in Org Buffers]]
    - [[#edit-latex][Edit Latex]]
    - [[#highlight-inline-latex-fragments][Highlight inline LaTeX fragments]]
    - [[#org-ref][Org Ref]]
    - [[#org-pdf][Org PDF]]
- [[#customizing-emacs][Customizing Emacs]]
  - [[#project-management][Project Management]]
    - [[#projectile][Projectile]]
    - [[#skeletor][Skeletor]]
    - [[#find-file-in-project][Find File in Project]]
  - [[#file-system][File System]]
    - [[#dired][Dired]]
    - [[#neotree][Neotree]]
    - [[#treemacs][Treemacs]]
    - [[#speedbar][Speedbar]]
  - [[#search][Search]]
    - [[#codesearch][Codesearch]]
    - [[#avy][Avy]]
    - [[#ack][ack]]
    - [[#ag][ag]]
    - [[#grep][grep+]]
    - [[#rg][rg]]
    - [[#visual-replace][Visual Replace]]
    - [[#undo-tree][Undo Tree]]
  - [[#startup][Startup]]
    - [[#buffer][Buffer]]
    - [[#inhibit-stuff][Inhibit stuff]]
    - [[#frame][Frame]]
    - [[#window-manager][Window Manager]]
  - [[#emacs][Emacs+]]
    - [[#help][Help+]]
    - [[#helpful][Helpful]]
    - [[#frame-1][Frame+]]
    - [[#frame-fns][Frame-fns]]
    - [[#posframe][posframe]]
    - [[#thingatpt][Thingatpt+]]
    - [[#bookmark][Bookmark]]
    - [[#bug-tracking][Bug Tracking]]
  - [[#multimedia][Multimedia]]
    - [[#emms][emms]]
    - [[#sound-cloud][Sound Cloud]]
- [[#user-interface][User Interface]]
  - [[#theme][Theme]]
    - [[#theme-defaults][Theme Defaults]]
    - [[#custom-theme-settings][Custom Theme Settings]]
    - [[#org-beautify-theme][Org Beautify Theme]]
    - [[#zenburn-theme][Zenburn Theme]]
    - [[#poet-theme][Poet Theme]]
    - [[#base16-themes][Base16 Themes]]
    - [[#load-theme][Load Theme]]
    - [[#org-mode-faces][Org Mode Faces]]
    - [[#italicize-font-lock-keyword-face][Italicize font lock keyword face]]
  - [[#cursor][Cursor]]
    - [[#bar-cursor][Bar Cursor]]
    - [[#disable-blink][Disable Blink]]
    - [[#only-show-cursor-in-selected-window][Only show cursor in selected window]]
    - [[#smart-cursor-color][Smart Cursor Color]]
    - [[#multiple-cursors][Multiple Cursors]]
    - [[#centered-cursor-mode][Centered Cursor Mode]]
  - [[#fonts][Fonts]]
    - [[#font-variables][Font variables]]
    - [[#set-font-interactively][Set font interactively]]
    - [[#set-the-default-font][Set the default font]]
    - [[#unicode][Unicode]]
  - [[#icons][Icons]]
    - [[#vs-code-icons][VS Code Icons]]
    - [[#all-the-icons][All the icons]]
    - [[#dired-icons][Dired Icons]]
    - [[#ivy-all-the-icons][Ivy All the Icons]]
  - [[#modeline][Modeline]]
    - [[#modeline-customization][Modeline Customization]]
    - [[#spaceline][Spaceline]]
    - [[#smart-mode-line][Smart Mode Line]]
    - [[#powerline][Powerline]]
    - [[#eyeliner][Eyeliner]]
    - [[#set-the-modeline-format][Set the modeline format]]
  - [[#scrolling][Scrolling]]
    - [[#scroll-to-first-error-on-compilation][Scroll to first error on compilation]]
    - [[#smooth-scrolling][Smooth Scrolling]]
    - [[#sublimity-scroll][Sublimity Scroll]]
  - [[#buttons][Buttons]]
    - [[#button-lock][Button Lock]]
  - [[#pretty][Pretty]]
    - [[#prettify-symbols][Prettify Symbols]]
    - [[#pretty-mode][Pretty Mode]]
    - [[#prettify-utilities][Prettify Utilities]]
    - [[#modern-emacs][Modern Emacs]]
    - [[#pretty-eshell][Pretty Eshell]]
- [[#completion][Completion]]
  - [[#company][Company]]
    - [[#company-quick-help][Company Quick Help]]
    - [[#company-statistics][Company Statistics]]
    - [[#company-box][Company Box]]
  - [[#snippets][Snippets]]
    - [[#yasnippet][YASnippet]]
    - [[#code-library][Code Library]]
  - [[#minibuffer][Minibuffer]]
    - [[#prompt-properties][Prompt Properties]]
    - [[#ivy][Ivy]]
    - [[#counsel][Counsel]]
    - [[#swiper][Swiper]]
    - [[#smex][Smex]]
    - [[#omnibox][Omnibox]]
- [[#terminal][Terminal]]
  - [[#with-editor][With Editor]]
  - [[#sane-term][Sane Term]]
  - [[#compilation-command][Compilation Command]]
    - [[#colorize-compilation-buffer][Colorize Compilation Buffer]]
  - [[#xterm][xterm]]
  - [[#run-bash-on-windowspc][Run Bash On Windows/PC]]
  - [[#eshell][Eshell]]
    - [[#eshell-bookmark][Eshell Bookmark]]
    - [[#eshell-z][Eshell Z]]
  - [[#shell][Shell]]
    - [[#shell-script-indentation][Shell script Indentation]]
    - [[#zsh-macfix][ZSH Macfix]]
    - [[#shell-command-to-list][Shell Command to list]]
  - [[#remote][Remote]]
    - [[#ssh][SSH]]
    - [[#scp][SCP]]
  - [[#tramp][Tramp]]
    - [[#default-method][Default Method]]
    - [[#anything-tramp][Anything Tramp]]
  - [[#unix-programs][Unix Programs]]
    - [[#wget][Wget]]
- [[#web][Web]]
  - [[#web-servers-and-utilities][Web Servers and Utilities]]
  - [[#browsing][Browsing]]
    - [[#browser-prefix-command][Browser prefix command]]
    - [[#webkit-xwidget][Webkit xwidget]]
    - [[#browse-url][Browse url]]
    - [[#browser-utilities-on-macos][Browser utilities on macOS]]
    - [[#google-search-at-point][Google search at point]]
    - [[#search-web][Search Web]]
    - [[#browse-at-remote][Browse at remote]]
    - [[#set-default-browser][Set default browser]]
    - [[#engine-mode][Engine Mode]]
  - [[#email][Email]]
    - [[#offlineimap][Offlineimap]]
    - [[#mu][Mu]]
  - [[#cloud-integration][Cloud Integration]]
    - [[#org-onenote][Org OneNote]]
- [[#prose][Prose]]
  - [[#spelling-and-grammar][Spelling and Grammar]]
    - [[#flyspell][Flyspell]]
    - [[#langtool][Langtool]]
    - [[#academic-phrases][Academic Phrases]]
    - [[#proselint][Proselint]]
  - [[#text-completion][Text Completion]]
    - [[#company-dict][Company Dict]]
    - [[#dictionaryel][Dictionary.el]]
  - [[#taking-notes][Taking Notes]]
    - [[#deft][Deft]]
    - [[#lorem-ipsum][Lorem Ipsum]]
    - [[#org-velocity][Org Velocity]]
  - [[#writing-mode][Writing mode]]
    - [[#typo-mode][Typo Mode]]
    - [[#writegood][Writegood]]
    - [[#variable-pitch][Variable Pitch]]
    - [[#olivetti][Olivetti]]
    - [[#writeroom][Writeroom]]
  - [[#reading-and-viewing][Reading and viewing]]
    - [[#justify-kp][Justify Kp]]
    - [[#nov][Nov]]
    - [[#visual-fill-column][Visual Fill Column]]
    - [[#fill-column-indicator][Fill Column Indicator]]
    - [[#adaptive-wrap][Adaptive Wrap]]
  - [[#graphics][Graphics]]
    - [[#artist-mode][Artist Mode]]
    - [[#uml-diagrams][UML Diagrams]]
    - [[#graphviz][Graphviz]]
    - [[#thesaurus][Thesaurus]]
- [[#code][Code]]
  - [[#lsp][LSP]]
    - [[#lsp-mode][LSP Mode]]
    - [[#lsp-ui-mode][LSP UI Mode]]
    - [[#company-lsp][Company LSP]]
  - [[#flycheck][Flycheck]]
  - [[#code-style][Code Style]]
    - [[#default][Default]]
    - [[#hy-mode][Hy mode]]
    - [[#highlight-indentation][Highlight Indentation]]
    - [[#symbol-highlighting][Symbol Highlighting]]
    - [[#code-folding][Code Folding]]
    - [[#editorconfig][Editorconfig]]
    - [[#google-c-style][Google C Style]]
    - [[#code-formatting][Code Formatting]]
  - [[#code-completion][Code Completion]]
    - [[#pair-matching][Pair Matching]]
    - [[#gtags][Gtags]]
  - [[#version-control][Version Control]]
    - [[#vcs-customize-interface][VCS Customize Interface]]
    - [[#git][Git]]
    - [[#mercurial][Mercurial]]
    - [[#ediff][Ediff]]
  - [[#devops][DevOps]]
    - [[#docker][Docker]]
    - [[#aws][AWS]]
  - [[#prog-tools][Prog Tools]]
    - [[#time-tracking][Time Tracking]]
    - [[#realgud][RealGUD]]
    - [[#logging][Logging]]
    - [[#pair-programming][Pair Programming]]
  - [[#prog-lang-api][Prog Lang API]]
  - [[#programming-languages][Programming Languages]]
    - [[#conf][Conf]]
    - [[#assembly][Assembly]]
    -  [[#cc][C/C++]]
    - [[#common-lisp][Common Lisp]]
    - [[#clojure][Clojure]]
    - [[#emacs-lisp][Emacs Lisp]]
    - [[#groovy][Groovy]]
    - [[#java][Java]]
    - [[#javascript][JavaScript]]
    - [[#python][Python]]
    - [[#ruby][Ruby]]
    - [[#ocaml][Ocaml]]
    - [[#scala][Scala]]
    - [[#web-1][Web]]
    - [[#markdown][Markdown]]
- [[#misc][Misc]]
  - [[#scimax][Scimax]]
  - [[#alfred-org-capture][Alfred Org Capture]]
  - [[#ess][ESS]]
- [[#prologue][Prologue]]
- [[#known-issues][Known Issues]]
  - [[#halidom-literate-config-file-is-added-to-org-agenda-files][~halidom-literate-config-file~ is added to ~org-agenda-files~]]
  - [[#dashboard-buffer-not--found-when-setting-value-of-initial-buffer][dashboard buffer not  found when setting value of initial buffer]]
  - [[#improper-font-locking-by-org-highlight-latex-and-related][Improper font locking by ~org-highlight-latex-and-related~]]
- [[#footnotes][Footnotes]]

* Preface
** About this document

This document contains my entire configuration for the GNU Emacs text editor. It written as some combination of travelogue, technical notebook, personal journal, and [[https://www.stackoverflow.com][StackOverflow]] pasteboard.

** Literate Programming
:PROPERTIES:
:ID:       A184FB03-2742-4398-8DDD-CB0D9577DAF5
:END:

[[https://en.wikipedia.org/wiki/literate_programming][Literate Programming]] is a method of writing computer programs where the composition, logic, and structure of the program are optimized for human comprehension. Introduced by Donald Knuth in his 1983 eponymous work, a literate program interoperates source code with macros, commentary, and documentation written in natural language prose. The source code is then extracted in a pre-compilation step known as /tangling/.

Where as a program is traditionally presented in a tree structure, a programmer implementing literate techniques arranges parts and forms the relations of these parts in the order of human logic.

A literate program is then structured like an essay or other work of literature, where ideas are connected in the form of a web rather than the unidirectional order of interpretation that is characteristic of a
compiler.

** Influences

- [[http://pages.sachachua.com/.emacs.d/sacha.html][Sacha Chua's Emacs Configuration]]
- [[http://aaronbedra.com/emacs.d/][Aaron Bedra's Emacs Configuration]]
- [[https://github.com/Wasamasa/dotemacs/blob/master/init.org][wasamasa/dotemacs]]
- [[http://fgiasson.com/blog/index.php/2016/06/21/optimal-emacs-settings-for-org-mode-for-literate-programming/][Optimal Emacs Settings For Org Mode For Literal Programming]]
  
* Base Configuration
** Tangle File
:PROPERTIES:
:ID:       E291C00A-151B-4B37-B771-2E71B7CF937A
:CUSTOM_ID: tangle-file
:END:

Insert conventional elisp header.[fn:1]

#+NAME: comment-block
#+BEGIN_SRC emacs-lisp :tangle yes
;;; halidom.el -- Emacs Configuration File
;;
;; Copyright (c) 2018 Jacob Chaffin
;;
;; Author: Jacob Chaffin <jchaffin@ucla.edu>
;; Keywords: emacs, .emacs.d, dotemacs, org-mode, literate
;; Homepage: https://github.com/jchaffin/.emacs.d
;; Package-Requires: ((emacs "27"))
;;
;; This file is not part of GNU Emacs.
;;
;;; License: GPLv3
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.


;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.
;;
;; Commentary:
;; This file was tangled using `org-babel'. See [[file:chaffin.org::#tangle-file][chaffin.org]] for the source.

;;; Code:
#+END_SRC

** straight.el
:PROPERTIES:
:ID:       66FE9466-8249-4F2A-9E45-1F1ABC67E643
:CUSTOM_ID: straight
:END:

[[https://github.com/raxod502/straight.el][Straight.el]] is a drop-in replacement for =package.el=.

It took me a while to figure out how straight works and to
conceptualize the way it loads packages  - primarily because documentation is also for people who understand things - but now that I've gotten through the substantial learning curve (made substantially harder due to my misconception regrading the value of reading documentation), I've come to find it reduces a lot of the weirdness of the Emacs loading process and increases the rapidity (shall I say agility? no..) with which I comprehend the way third-party packages are implemented and modify them as I deem necessary.

*** Goto local package repository

Function to jump to a repository installed by [[#straight][straight]]. An
interactive minibuffer completion menu using ivy.

#+BEGIN_SRC emacs-lisp :tangle yes

(cl-defun straight-browse-local (&optional build-dir)
  "Go to a straight repository directory. If BUILD-DIR, then go to
  the build directory for that repository instead."
  (interactive "P")
  (lexical-let* ((dir (-> user-emacs-directory
                         (f-join "straight"
                                 (if build-dir "build" "repos"))))
                 (pkg-keys (--> straight--recipe-cache
                                (hash-table-keys it)
                                (seq-difference
                                 it
                                 (mapcar
                                  #'symbol-name
                                  straight-built-in-pseudo-packages))
                                (sort it #'string-lessp)))
                 (msg (format "(%s) Goto recipe: "
                              (upcase-initials (f-base dir)))))
    (ivy-read
     msg
     pkg-keys
     :action
     (lambda (package)
       (lexical-let (pkg-directory pkg-file)
         (condition-case nil
             (if (and build-dir
                    (not (plist-get
                        (gethash package straight--recipe-cache)
                        :no-build)))
                 (progn
                   (setq pkg-directory (expand-file-name package dir))
                   (and (file-directory-p pkg-directory)
                      (dired pkg-directory)))
               (let ((repo (plist-get
                            (gethash package straight--recipe-cache)
                            :local-repo)))
                 (if repo
                     (setq pkg-directory
                           (expand-file-name
                            repo
                            (replace-regexp-in-string "build" "repos" dir))
                           pkg-file
                           (car
                            (directory-files pkg-directory t
                                             (concat "\\README.*\\'\\|" package ".el"))))
                   (setq pkg-directory
                         (file-name-directory (locate-library package))
                         pkg-file
                         (car (directory-files pkg-directory t
                                               (concat package ".el\\(?:.gz\\)")))))
                 (if pkg-file
                     (and (file-exists-p pkg-file)
                        (find-file pkg-file))
                   (and (file-directory-p pkg-directory)
                      (dired pkg-directory)))))))))))

(define-key goto-map "r" #'straight-browse-local)
#+END_SRC

*** Browse straight repository at GitHub

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun straight--get-remote-url (pkg)
    (let ((recipe (cdr (straight-recipes-retrieve pkg))))
      (destructuring-bind (repo host)
          `(,(plist-get recipe :repo)
            ,(plist-get recipe :host))
        (if (eq host 'github)
            (concat "https://github.com/" repo)
          (message "%s is not a GitHub repository :(" pkg)))))


  (defun straight-browse-remote (&optional package)
    "Open a straight recipe on GitHub in the `browse-url-default-browser.'"
    (interactive "P")
    (let* ((pkg (if (interactive-p)
                    (completing-read
                     "Which recipe? "
                     (straight-recipes-list straight-recipe-repositories)
                     nil 'require-match)))
           (url (straight--get-remote-url (intern pkg))))
      (browse-url url)))
#+END_SRC

***  Straight Hydra Menu

#+NAME: straight/hydra
#+BEGIN_SRC emacs-lisp :tangle yes
  (with-eval-after-load 'hydra
    (defhydra hydra-straight (:hint nil :exit t)

      "
    _c_heck all       |_f_etch all     |_m_erge all      |_n_ormalize all   |p_u_sh all
    _C_heck package   |_F_etch package |_M_erge package  |_N_ormlize package|p_U_sh package
    ----------------^^+--------------^^+---------------^^+----------------^^+------------||_q_uit||
    _r_ebuild all     |_p_ull all      |_v_ersions freeze|_w_atcher start   |_g_et recipe
    _R_ebuild package |_P_ull package  |_V_ersions thaw  |_W_atcher quit    |pru_n_e build
    ----------------^^+--------------^^+---------------^^+----------------^^+------------
    _b_rowse package local
    _B_rowse package remote
    "
      ("b" straight-browse-local)
      ("B" straight-browse-remote)
      ("c" straight-check-all)
      ("C" straight-check-package)
      ("r" straight-rebuild-all)
      ("R" straight-rebuild-package)
      ("f" straight-fetch-all)
      ("F" straight-fetch-package)
      ("p" straight-pull-all)
      ("P" straight-pull-package)
      ("m" straight-merge-all)
      ("M" straight-merge-package)
      ("n" straight-normalize-all)
      ("N" straight-normalize-package)
      ("u" straight-push-all)
      ("U" straight-push-package)
      ("v" straight-freeze-versions)
      ("V" straight-thaw-versions)
      ("w" straight-watcher-start)
      ("W" straight-watcher-quit)
      ("g" straight-get-recipe)
      ("n" straight-prune-build)
      ("q" nil))
  )
#+END_SRC

** User Information

These values are initialized with the ’name’ and ’email’
environment variables, respectively[fn:3].

Emacs uses these variables to fill the mail header when sending
emails in emacs, and various third-party packages rely on them
for correct behavior.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq user-full-name "Jacob Chaffin"
      user-mail-address "jchaffin@ucla.edu")
#+END_SRC

Ensure that programs store emacs information in the cannonical
directory.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq user-emacs-directory "~/.emacs.d/")
#+END_SRC

** Customization Group

#+NAME: halidom/customization
#+BEGIN_SRC emacs-lisp :tangle yes
;; Customization Group
(defgroup halidom nil
  "Customization group for the `halidom' Emacs configuration."
  :group 'applications
  :prefix "halidom-")

(defcustom halidom-prefix "\M-m"
  "The prefix map leader key.")
#+END_SRC

** Core
*** Libraries
**** Dash

Functional bindings i.e thread =->= macro.

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package dash
  :config
  (eval-after-load 'dash
    '(dash-enable-font-lock)))

#+END_SRC

**** Cl-lib

Common Lisp extensions.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package cl-lib)
#+END_SRC

***** cl-highlight

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package cl-lib-highlight
  :demand t
  :after cl-lib)

#+END_SRC

**** ov

#+NAME: ov-spec
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ov
  :straight t)
#+END_SRC

**** =f=

Declarative file and directory utilities.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package f)
#+END_SRC

**** =s=

The string manipulation library.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package s)
#+END_SRC

**** =a=
#+NAME: libs/a
#+BEGIN_SRC emacs-lisp :tangle no
(use-package a)
#+END_SRC

*** El Patch

Use [[https://github.com/raxod502/el-patch#lazy-loading-packages][el patch]] to advice system and package lazy-loading.

#+NAME: elpatch-spec
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package el-patch
    :init
  (defun el-patch-remove-feature ()
    (interactive)
    (let ((feature (completing-read "Feature: " el-patch-pre-validate-hook))
          (patch (call-interactively #'el-patch-unpatch)))
      (remove-hook 'el-patch-pre-validate-hook (intern feature))
      (remhash patch el-patch--patches))))

#+END_SRC

*** Constants

Variables used throughout this file[fn:4]:

#+NAME: halidom/constants
#+BEGIN_SRC emacs-lisp :tangle yes

(defconst *is-mac* (eq system-type 'darwin))
(defconst *is-linux* (eq system-type 'gnu/linux))
(defconst *is-windows* (eq system-type 'windows))

#+END_SRC

*** Macros

#+NAME: halidom/macros
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin Macros
;; If not
<<macros/if-not>>
;; with major mode
<<macros/with-major-mode>>
;; if major mode
<<macros/if-major-mode>>
;; End Macros
#+END_SRC

**** If not

Clojure-like =if-not= macro in elisp.

#+NAME: macros/if-not
#+BEGIN_SRC emacs-lisp :tangle no
(defmacro if-not (condition then-form &rest rest-forms)
  (declare (indent 2))
  `(progn
     (if (not ,condition)
	 ,then-form
       ,@rest-forms)))
#+END_SRC

**** With major mode macro

#+NAME: macros/with-major-mode
#+BEGIN_SRC emacs-lisp :tangle no
(defmacro with-major-mode (mode &rest body)
  "If the current major-mode is MODE, then execute BODY."
  (declare (indent defun))
  `(when (equal major-mode ',mode)
     ,@body))
#+END_SRC

***** If-Else Major Mode Macro

#+NAME: macros/if-major-mode
#+BEGIN_SRC emacs-lisp :tangle no
(defmacro if-major-mode (mode then-form &rest rest-forms)
  "If MODE, then execute THEN-FORM, else execute REST-FORMS."
  (declare (indent defun))
  `(progn
     (if (equal major-mode ',mode)
	       ,then-form
       ,@rest-forms)))
#+END_SRC

*** Functions

#+NAME: halidom/functions
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
<<utility-functions>>
<<buffer-functions>>
<<window-functions>>
<<fd-functions>>
#+END_SRC

**** Lisp Utilities

#+NAME: utility-functions
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Add to Hooks
<<utility-hooks>>
;; Join Strings
<<utility-join>>
;; SSL check
<<utility-ssl>>
;; Minor Modes
<<utility-minor-modes>>
;; Unadvise
<<utility-unadvise>>
#+END_SRC

***** Add multiple hooks

See Stack Overflow ticket [[https://stackoverflow.com/a/7400476/6233622][#7398216]]

#+NAME: utility-hooks
#+BEGIN_SRC emacs-lisp :tangle no
(defun add-to-hooks (fun hooks)
  "Add function FUN to HOOKS."
  (dolist (hook hooks)
    (add-hook hook fun)))

#+END_SRC

***** Join Strings with Separator

#+NAME: utility-join
#+BEGIN_SRC emacs-lisp :tangle no

(defun join (seq sep)
  "Concatenate SEQ with SEP as combinator."
  (mapconcat 'identity seq sep))

#+END_SRC

***** Check if HTTPS is supported

From the melpa installation:

#+NAME: utility-ssl
#+BEGIN_SRC emacs-lisp :tangle yes

(defun ssl-p ()
  "Determine whether https protocol is supported."
  (and (not (memq system-type '(windows-nt ms-dos)))
       (gnutls-available-p)))

#+END_SRC

***** Get Active Minor Modes

#+NAME: utility-minor-modes
#+BEGIN_SRC emacs-lisp :tangle yes
(defun list-enabled-minor-modes (&optional buf)
  "The minor modes enabled in the current buffer."
  (let ((auto-save-mode nil)
        (buf (or buf (current-buffer))))
    (cl-loop for mode being the element of minor-mode-list
             when (boundp mode)
             when (symbol-value mode)
             collect mode)))


(defvar minor-modes-enabled-list (list-enabled-minor-modes (current-buffer))
  "The list of enabled minor modes")

(defun minor-mode-enabled-p (mode)
  (member mode (list-enabled-minor-modes (current-buffer))))
#+END_SRC

***** Unadvise

[[https://emacs.stackexchange.com/questions/24657/unadvise-a-function-remove-all-advice-from-it][Remove advice]].

#+NAME: utility-unadvise
#+BEGIN_SRC emacs-lisp :tangle no

(defun unadvise (sym)
  "Remove all advices from symbol SYM."
  (interactive "aFunction symbol: ")
  (advice-mapc (lambda (advice _props) (advice-remove sym advice)) sym))

#+END_SRC

**** Buffers

#+NAME: buffer-functions
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
<<buf-list-names>>
<<buf-scratch>>
#+END_SRC

***** Buffer List Names

#+NAME: buffer-list-names
#+BEGIN_SRC emacs-lisp :tangle no

(defun buffer-list-names ()
  "Get list of buffer names."
  (let ((f (lambda (b) (buffer-name b)))
	(buffer-alist (buffer-list)))
    (mapcar f buffer-alist)))

#+END_SRC

***** Regenerate scratch buffer

#+NAME: buf-scratch
#+BEGIN_SRC emacs-lisp :tangle no

(defun scratch (&optional new)
  "Switch to scratch buffer. If optional prefix NEW,
then create a new buffer. Else reuse the existing scratch buffer,
generating a new one if the initial scratch buffer has been killed."
  (interactive "P")
  (unless (or new (not (seq-contains (buffer-list) (get-buffer "*scratch*"))))
    (with-current-buffer (generate-new-buffer "*scratch*")
      (emacs-lisp-mode)))
  (switch-to-buffer-other-window "*scratch*"))


#+END_SRC

**** Windows

#+NAME: window-functions
#+BEGIN_SRC emacs-lisp :tangle no  :noweb yes :exports none
;; Window Count
<<win-count>>
;; Window Count Unique
<<win-count-unique>>
;; Window Buffer List
<<win-buf-list>>
;; WIndow Buffer List Modes
<<wind-buf-list-modes>>
#+END_SRC

***** Window Count

#+NAME: win-count
#+BEGIN_SRC emacs-lisp :tangle no
(defun window-count ()
  "Count number of windows in the current frame."
  (interactive)
  (length (window-list)))
#+END_SRC

***** Count Unique Windows
#+NAME: win-count-unique
#+BEGIN_SRC emacs-lisp :tangle no
(defun window-count-unique ()
  "Count number of unique windows in the current frame"
  (interactive)
  (length (cl-delete-duplicates (mapcar #'window-buffer (window-list)))))
#+END_SRC

***** Window Buffer List

#+NAME: win-buf-list
#+BEGIN_SRC emacs-lisp :tangle no
(defun window-buffer-list ()
  "Get list of buffers in an open window."
  (let ((windows))
    (dolist (frame (frame-list) windows)
      (with-selected-frame frame
      (setq windows (append (window-list) windows))))
        (map 'seq-uniq (lambda (w) (window-buffer w)) windows)))
#+END_SRC

#+NAME: win-buf-list-modes
#+BEGIN_SRC emacs-lisp :tangle no
(defun buffer-list-modes ()
  "Restart org-mode in all org buffers in open windows."
  (let ((modes))
    (dolist (buf (window-buffer-list) modes)
      (with-current-buffer buf
        (setq modes (push major-mode modes))))
    (seq-uniq modes)))
#+END_SRC

**** Files and Directories

#+NAME: fd-functions
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Unix Basename
<<fd-basename>>
;; Copy File Path
<<fd-copy>>
;; Directory Files no wildcards
<<fd-no-wildcards>>
;; Read File
<<fd-read-file>>
;; Resolve Path
<<fd-resolve-path>>
;; User Directories
<<fd-user>>
;; Emacs Directories
<<fd-emacs>>
;; Readonly directories
<<fd-read-only>>
#+END_SRC

***** Unix-style =basename=

The Elisp =file-name-base= function has somewhat misleading nomenclature. The name seems to suggest that it would have the same behavior of the UNIX =basename= command, but the Emacs function actually behaves quites differently:

1. If the given file path is a directory, the Unix implementation discards the trailing slash and operates on the directory component as if it were a regular file. In Emacs, the same input will return an empty string.
2. The Emacs function removes the extension from the file - that is, the substring from the last-most '.' character to the end of the string.

As discussed in this 2011[[https://lists.gnu.org/archive/html/emacs-devel/2011-01/msg01217.html][ thread]] from the =emacs-devel= mailing list, it would be nice if Emacs also had a function that behaved similarly to the Unix command.

#+NAME: fd-basename
#+BEGIN_SRC emacs-lisp :tangle no
(defun basename (pathname)
  "Return the filename or directory portion of PATHNAME"
  (if (or (file-directory-p pathname)
          (string-match "/$" pathname))
      (let ((dirname (directory-file-name pathname)))
        (file-name-nondirectory dirname))
    (file-name-nondirectory pathname)))
#+END_SRC

***** Copy File Path

#+NAME: fd-copy
#+BEGIN_SRC emacs-lisp :tangle no
(defun copy-file-path (func)

  "Copies the file path and applies the result as an argument to
function FUNC. To copy the file path to the kill-ring, use the
 interactive function `copy-file-path-as-kill'."

  (destructuring-bind (file dir)
      (cond ((eq major-mode 'dired-mode)
             (list (substring-no-properties (thing-at-point 'symbol))
                   dired-directory))
            ((stringp buffer-file-name)
             (mapcar (lambda (f) (funcall f buffer-file-name))
                     '(file-name-nondirectory file-name-directory)))
            (t  (list (buffer-name (current-buffer)) default-directory)))
    (funcall func (expand-file-name file dir))))

(defun copy-file-path-as-kill ()
  "Copies the file path of the current dired directory or file buffer to the kill-ring."
  (interactive)
  (let ((func (lambda (s)
		(progn
		  (kill-new s)
		  (message "%s" s)))))
    (copy-file-path func)))

#+END_SRC

***** Remove wildcards from directory files list

#+NAME: fd-no-wildcards
#+BEGIN_SRC emacs-lisp :tangle yes
(defun directory-files-no-wildcards (directory &optional full nosort)
   "List directory contents without wildcards"
   (cddr (directory-files directory full nil nosort)))
#+END_SRC

***** Read File Contents

From [[http://ergoemacs.org/emacs/elisp_read_file_content.html][Ergo Emacs]]:

#+NAME: fd-read-file
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; As String
<<read-file-as-string>>
;; As list
<<read-file-lines>>
#+END_SRC

****** As String

#+NAME: read-file-as-string
#+BEGIN_SRC emacs-lisp :tangle no
(defun read-file-contents (file)
  "Return contents of FILE."
  (with-temp-buffer
    (insert-file-contents file)
    (buffer-string)))
#+END_SRC

****** As List of Lines

#+NAME: read-file-lines
#+BEGIN_SRC emacs-lisp :tangle no
(defun read-lines (file)
  "Return a list of lines in FILE."
  (with-temp-buffer
    (insert-file-contents file)
    (split-string (buffer-string) "\n" t)))
#+END_SRC

***** Resolve Path

#+NAME: fd-resolve-path
#+BEGIN_SRC emacs-lisp :tangle no

(defun resolve-path (&rest paths)
  "Concatenate path segments."
  (let ((paths- (mapcar #'directory-file-name paths)))
    (mapconcat 'identity paths- "/")))

#+END_SRC

***** User Directories

#+NAME: fd-user
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
<<fd-user-home>>
<<fd-dropbox>>
<<fd-projects>>
#+END_SRC

****** User Home

#+NAME: fd-user-home
#+BEGIN_SRC emacs-lisp :tangle no
(defun user-home (&rest path-segments)
  "Resolves the absolute path formed PATH-SEGMENTS to the
   user home directory."
  (let ((root-separator "/"))
    (--> (getenv "HOME")
         (f-split it)
         (append it path-segments)
         (cdr it)
         (cons (concat root-separator (car it) )(cdr it))
         (apply #'resolve-path it)
         (f-slash it))))

#+END_SRC

****** Dropbox Directory

#+NAME: fd-dropbox
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
(defalias #'dropbox-dir (apply-partially #'user-home "Dropbox"))
#+END_SRC

****** Project Directory

#+NAME: fd-projects
#+BEGIN_SRC emacs-lisp :tangle no
(defalias #'projects-dir
 (apply-partially #'user-home "Developer" "Projects"))
#+END_SRC

***** Emacs Directories

#+NAME: fd-emacs
#+BEGIN_SRC emacs-lisp :tangle no
(defalias #'emacs-dir (apply-partially #'user-home ".emacs.d"))
(defalias #'emacs-var-dir (apply-partially #'emacs-dir "var"))
(defalias #'emacs-etc-dir (apply-partially #'emacs-dir "etc"))
(defalias #'straight-dir (apply-partially #'emacs-dir "straight"))

(defalias #'org-dir (apply-partially #'dropbox-dir "org"))
(defalias #'agenda-dir (apply-partially #'org-dir "agenda"))
#+END_SRC

***** Read only

#+NAME: fd-read-only
#+BEGIN_SRC emacs-lisp :tangle no
(defvar read-only-directories '()
  "A list of directories for which all files and subdirectories
should open in `read-only-mode'.")

(defvar read-only-whitelist-directories '()
  "A list of directories which should not be opened in read-only mode.")

(defvar read-only-file-extensions '("\\.gz\\'")
  "Not yet implemented.")

(defun dir-level (dir)
  (length (f-split dir)))

(defun dir-or-subdir-p (d1 d2)
  "If non-nil, then directory D1 is subdirectory or the same directory as D2."
  (cond ((< (dir-level d1) (dir-level d2)) nil)
        ((string= d1 d2) t)
        (t (dir-or-subdir-p
            (--> d1 basename file-name-as-directory (string-remove-suffix it d1))
            d2))))

(defun read-only-directory-p (bf)
"Determine whether the current buffer file is in a directory
that is a member of `read-only-directories'."
  (cl-flet ((f (d) (funcall #'dir-or-subdir-p bf d)))
    (and (not (null (seq-filter #'f read-only-directories)))
         (null (seq-filter #'f read-only-whitelist-directories))
         (file-writable-p bf))))

(defun halidom/open-buffer-as-read-only (file)
  "All buffers from `read-only-directories' or
`read-only-file-extensions' are set to read-only."
  (let ((bd (and buffer-file-name (file-name-directory file))))
    (if (read-only-directory-p bd) (read-only-mode 1))))

(defun halidom/find-file-read-only-hook ()
  (funcall #'halidom/open-buffer-as-read-only (buffer-file-name)))

(setq read-only-directories `(,(straight-dir) "/usr/local/"))

(setq read-only-whitelist-directories '("/usr/local/src/llvm-project/"))
(add-hook 'find-file-hook #'halidom/find-file-read-only-hook)

#+END_SRC

*** Default Setup
**** Garbage Collection

Consider the following from the documentation:

#+BEGIN_QUOTE
By binding this temporarily to a large number, you can effectively
prevent garbage collection during a part of the program.
#+END_QUOTE

When I first read how the default garbage collection interval in Emacs
is notoriously low, I added an arbitrary number of zeros to the
default value and called it a day. However, because I'm writing this
monolithic configuration and making a lot of mistakes in the process,
I've had to start Emacs with essentially its default settings pretty
frequently and I've noticed the lag time I occasionally experience
when searching long documents is essentially nonexistent in vanilla
Emacs. After reading this [[http://bling.github.io/blog/2016/01/18/why-are-you-changing-gc-cons-threshold/][blogpost]], it seems that jacking up the GC
interval may actually be the /cause/ of the lagtime rather than
contributing to the solution.

#+BEGIN_SRC emacs-lisp :tangle yes
(defun halidom/rev-up-gc ()
   (interactive)
  (setq gc-cons-threshold most-positive-fixnum))

(defun halidom/rev-down-gc ()
   (interactive)
  (setq gc-cons-threshold 800000))

(add-hook 'minibuffer-setup-hook #'halidom/rev-up-gc)
(add-hook 'minibuffer-exit-hook #'halidom/rev-down-gc)
#+END_SRC

**** Files
***** No Littering

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package no-littering
:custom
(no-littering-etc-directory
 (expand-file-name "etc" user-emacs-directory)
 (no-littering-var-directory
  (expand-file-name "var" user-emacs-directory))))

(require 'no-littering)

(setq auto-save-file-name-transforms
      `((".*" ,(no-littering-expand-var-file-name "auto-save/") t)))
#+END_SRC

***** Custom File

By default, Emacs customizations[fn:6] done through the =customize=
interface write to =user-init-file=.

While I usually prefer configuring emacs programmatically, settings
that depend on resources outside of this repository, such as
org-agenda files, will impact portability and potentially break on
other machines.

#+BEGIN_SRC emacs-lisp :tangle yes
(let ((directory (emacs-etc-dir "custom"))
      (file (pcase system-type
              (`darwin "custom-macos.el")
              (`gnu/linux "custom-linux.el")
              (`windows "custom-windows.el"))))
  (setq custom-file (expand-file-name file directory))
  ;; Create custom file if it does not exist.
  (if-not (file-exists-p custom-file)
      (with-temp-buffer
        (find-file custom-file)
        (save-buffer)
        (kill-buffer)))
  (load custom-file))


(defun goto-custom ()
    (interactive)
    (find-file custom-file))

(define-key goto-map "C" #'goto-custom)
#+END_SRC

***** Backup Files

This might come back to bite me one day but I never use them.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq make-backup-files nil)
#+END_SRC

***** Inhibit Autosave message


#+BEGIN_SRC emacs-lisp :tangle yes
(setq auto-save-no-message t)
#+END_SRC

***** Lockfiles

Causes a conflict with ~lsp-mode~.
#+NAME: lockfiles-spec
#+BEGIN_SRC emacs-lisp :tangle yes
(setq create-lockfiles nil)
#+END_SRC

***** Shortcuts

#+BEGIN_SRC emacs-lisp :tangle yes

(defun goto-init ()
  (interactive)
  (find-file (expand-file-name "init.el" user-emacs-directory)))

(defun goto-literate ()
  (interactive)
  (find-file halidom-user-literate-init-file))

(defun goto-tangled-init ()
  (interactive)
  (find-file
    (concat (file-name-sans-extension halidom-user-literate-init-file) ".el")))


(define-key goto-map "i" #'goto-init)
(define-key goto-map "l" #'goto-literate)
(define-key goto-map "t" #'goto-tangled-init)

#+END_SRC

**** Load Secrets

#+BEGIN_SRC emacs-lisp :tangle yes
(when (and (executable-find "gpg") *is-mac*)
  (if-not (string-empty-p
       (shell-command-to-string
	      (concat "gpg --list-keys | grep " user-mail-address)))
      (progn
        (add-to-list 'load-path (emacs-etc-dir "secrets"))
        (require 'secrets))
    (print (format "GPG key(s) for %s not found"
                   (or user-full-name user-mail-address)))))
#+END_SRC

**** Fill Column

#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default fill-column 80)
#+END_SRC

**** Modernize Emacs

- makuto's [[https://github.com/makuto/editorPreferences/blob/master/Emacs/emacsConfig.txt][emacsConfig.txt]]
- Xah Lee [[http://ergoemacs.org/emacs/emacs_make_modern.html][emacs make modern]]

#+BEGIN_SRC emacs-lisp :tangle yes
(global-subword-mode 0)
(delete-selection-mode 1)
(global-hl-line-mode -1)
(save-place-mode 1)
#+END_SRC

**** Prefer newer bytecode

#+BEGIN_SRC emacs-lisp :tangle yes
(setq load-prefer-newer t)
#+END_SRC

*** Encryption
**** GnuTLS

As GitHub user [[https://github.com/wasamasa][wasamasa]] points out in /h?(er|is)|^\S+/ dotfiles,
[[https://gnutls.org/][GnuTLS]] throws several warnings when using the default 256 minimum
prime bits over a TLS handshake.

#+BEGIN_QUOTE
Minimum number of prime bits accepted by GnuTLS for key exchange.
During a Diffie-Hellman handshake, if the server sends a prime
number with fewer than this number of bits, the handshake is
rejected.  (The smaller the prime number, the less secure the
key exchange is against man-in-the-middle attacks.)
#+END_QUOTE


#+BEGIN_SRC emacs-lisp :tangle yes
(setq gnutls-min-prime-bits 4096)
#+END_SRC

**** Use GPG2
***** Set GPG program to 'gpg2'.

#+BEGIN_SRC emacs-lisp :tangle yes
(when *is-mac*
  (let* ((has-brew (not (string-empty-p
			 (shell-command-to-string
			  "which brew"))))
	 (gpg-path (if has-brew
		       (shell-command-to-string "brew --prefix gpg2")))
	 (has-gpg2 (if gpg-path
		             (file-exists-p
                  (replace-regexp-in-string "\n" "" gpg-path)))))
    (setq epg-gpg-program (if has-gpg2 "gpg2" "gpg"))))
#+END_SRC

***** Disable External Pin Entry

Switching between Emacs and an external tools is annoying.

By default, decrypting gpg files in Emacs will result in the pin entry
window being launched from the terminal session.

By disabling the agent info, we can force Emacs to handle this
internally[fn:7].

#+BEGIN_SRC emacs-lisp :tangle yes
(setenv "GPG_AGENT_INFO" nil)
#+END_SRC

Or so I thought...

***** Internal Pinentry Problem and Solution

While I couldn't figure out how to get Emacs to handle gpg pinentry
internally, I was able to still find a satisfactory solution using the
~pinentry-mac~ tool.

Note that this solution requires macOS and using gpg2 for encryption.

See ticket [[https://github.com/Homebrew/homebrew-core/issues/14737][#1437]] from the [[https://github.com/Homebrew/homebrew-core][Homebrew/homebrew-core]] repository.

#+BEGIN_EXAMPLE sh
brew install pinentry-mac
echo "pinentry-program /usr/local/bin/pinentry-mac" >> ~/.gnupg/gpg-agent.conf
killall gpg-agent
#+END_EXAMPLE

**** Ignore Extensions

#+BEGIN_SRC emacs-lisp :tangle yes
(append completion-ignored-extensions
        '("o" "~" ".lbin" ".so" ".a"
          ".git/" ".hg/" ".svn" ".svn-base"))
#+END_SRC

*** Alias Yes Or No

#+NAME: yes-or-no-p
#+BEGIN_SRC emacs-lisp :tangle yes
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC


** Keybindings

#+NAME: keybindings-spec
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin Keybindings
;; Which Key
<<kb-which-key>>
;; Hydra
<<kb-hydra>>
;; Smartrep
<<kb-smartrep>>
;; Prefix Map
<<kb-prefix-map>>
;; Reload Eval
<<kb-reload-eval>>
;; Speed Type
<<kb-speed-type>>
;; End Keybindings
#+END_SRC

*** Global Prefix Map

#+NAME: kb-prefix-map
#+BEGIN_SRC emacs-lisp :tangle no
(define-prefix-command 'halidom-prefix-map)
(global-set-key halidom-prefix 'halidom-prefix-map)
#+END_SRC

*** Hydra

[[https://github.com/abo-abo/hydra/wiki/Emacs][Hydra]] is a package used to bind a family of related commands with a
common prefix.

#+NAME: kb-hydra
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Hydra
<<hydra-hydra>>
;; Ivy Hydra
<<hydra-ivy>>
#+END_SRC


#+NAME: hydra-hydra
#+BEGIN_SRC emacs-lisp :tangle no
(use-package hydra)
#+END_SRC

**** Ivy Hydra

#+NAME: hydra-ivy
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ivy-hydra
  :after (:all hydra ivy)
  :demand t)
#+END_SRC

*** Smartrep

#+NAME: kb-smart-rep
#+BEGIN_SRC emacs-lisp :tangle no
(use-package smartrep)
#+END_SRC

*** Which Key

#+NAME: kb-which-key
#+BEGIN_SRC emacs-lisp :tangle no
(use-package which-key
  :custom
  (which-key-enable-extended-define-key t)
  (which-key-allow-multiple-replacements t)
  :init
  (which-key-mode 1))
#+END_SRC

*** Reload Eval

#+NAME: kb-reload-eval
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Begin reload-eval Group
;; Reload eval straight
<<reload-eval-straight>>
;; Restart Emacs
<<reload-eval-restart>>
;; Reload Eval Keymap
<<reload-eval-commander>>
;; End reload-eval Group
#+END_SRC

**** Straight Reloading

#+NAME: reload-eval-straight
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
;; Reload Init
<<straight-reload-init>>
;; Eval Buffer
<<straight-eval-buffer>>
#+END_SRC

***** Reload Init

#+NAME: straight-reload-init
#+BEGIN_SRC emacs-lisp :tangle no

(defun straight-reload-init (&optional debug)
  "Reload init file using straight transaction system."
  (interactive "P")
  (straight-transaction
    (straight-mark-transaction-as-init)
    (message "Reloading initialization file...")
    (when debug
      (set (make-local-variable 'use-literate-p) nil)
      (set (make-local-variable 'user-init-file)
	   (expand-file-name "init.el" user-emacs-directory)))
    (load user-init-file nil 'nomessage)
    (message "Reloading initialization file...done.")))


#+END_SRC

***** Profile Init

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package esup)
#+END_SRC

***** Eval Buffer

#+NAME: straight-eval-buffer
#+BEGIN_SRC emacs-lisp :tangle no
(defun straight-eval-buffer ()
  "Evaluate current buffer using the straight transaction system."
  (interactive)
  (message "Evaluating %s..." (buffer-name))
  (straight-transaction
    (if (or (null buffer-file-name)
            (not (file-exists-p buffer-file-name)))
        (eval-buffer)
      (progn
        (when (string= buffer-file-name user-init-file)
          (straight-mark-transaction-as-init))
        (load-file buffer-file-name))))

  (message "Evaluating %s...done." (buffer-name)))
#+END_SRC


**** Restart Emacs

The [[https://github.com/iqbalansari/restart-emacs][restart-emacs]] package allows quickly rebooting Emacs
from within Emacs.

#+NAME: reload-eval-restart
#+BEGIN_SRC emacs-lisp :tangle no
(use-package restart-emacs)
#+END_SRC

**** Reload Eval Map

#+NAME: reload-eval-commander
#+BEGIN_SRC emacs-lisp :tangle yes

  (define-prefix-command 'reload-eval-prefix-map)

  (let ((map reload-eval-prefix-map))
    (define-key map "i" 'straight-reload-init)
    (define-key map "b" 'straight-eval-buffer)
    (define-key map "r" 'eval-region)
    (define-key map "f" 'straight-eval-defun)
    (define-key map "q" 'restart-emacs))

  (define-key 'halidom-prefix-map (kbd "s") 'hydra-straight/body)
  (define-key 'halidom-prefix-map (kbd "r") 'reload-eval-prefix-map)
  (which-key-add-prefix-title "M-m r" "Reload/Eval")

#+END_SRC

*** Speed Type

I just got the blank-capped [[https://elitekeyboards.com/products.php?sub=pfu_keyboards,hhkbpro2&pid=pdkb400bn][HHKB2]] keyboard. I need all the help I can get.

#+NAME: kb-speed-type
#+BEGIN_SRC emacs-lisp :tangle no
(use-package speed-type)
#+END_SRC

** System
*** Use Emacs terminfo

Setting this variable to nil forces Emacs to use internal terminfo,
rather than the system terminfo.

I'm setting it to non-nil because setting this variable to nil causes
issues with build commands in [[#gradle-mode][gradle-mode]]

#+BEGIN_SRC emacs-lisp :tangle yes
(setq system-uses-terminfo t)
#+END_SRC

*** UTF-8 Encoding

UTF-8 is the recommanded coding system on macOS.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when (eq system-type 'darwin)
    (prefer-coding-system 'utf-8)
    (set-default-coding-systems 'utf-8)
    (set-terminal-coding-system 'utf-8)
    (set-keyboard-coding-system 'utf-8)
    ;; Treat clipboard input as UTF-8 string first; compound text next, etc.
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))


(global-set-key (kbd "C-x C-m i") 'set-input-method)

#+END_SRC

*** Pickup environment variables

Emacs relies heavily on shell environment variables.

These variables may not be picked up when launching emacs
from a gui on a unix-like operating system.

**** Exec Path From Shell

The [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]] package fixes this problem by copying
user environment variables from the shell.

The ~exec-path-from-shell~ package only works with posix-compliant
operating systems. This may or may not include Microsoft Windows[fn:8].

However, the ~exec-path-from-shell~ instructions recommends loading
the package on linux and macOS operating system. I don't use Windows
all that often anyways, so that's fine with me.

The ~:if~ key of ~use-package~ offers us a really concise way for
conditionally loading dependencies.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package exec-path-from-shell
  ;; only load `exec-path-from-shell' package on macos and linux.
  :if (memq window-system '(mac ns))
  :config
  (progn
    (exec-path-from-shell-initialize)
    (setq exec-path-from-shell-check-startup-files nil)))
#+END_SRC

*** System Packages
Utilities for managing system packages in Emacs using an external
package manager.

#+NAME: os-sys-packages
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package system-packages
:init
 (defun system-packages/update-brew-commands (commands)
   "Update the brew commands supported in system-packages."
     (dolist (command  commands)
       (destructuring-bind (name . cmd) command
         (setf (cdr (assoc
                     name
                     (cdr
                      (assoc
                       'brew
                       system-packages-supported-package-managers))))
               cmd))))

 :config
 (with-eval-after-load 'system-packages
   (let ((commands-alist '((get-info . "brew info")
                          (verify-all-packages . "brew doctor")
                           (log . "brew log"))))
     (system-packages/update-brew-commands commands-alist))))
#+END_SRC

*** Ensure system package

#+BEGIN_SRC emacs-lisp :tangle no
(use-package use-package-ensure-system-package
  :after (:all exec-path-from-shell system-packages)
  :demand t)
#+END_SRC

*** Prodigy

Interface for controlling external processes in Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package prodigy)
#+END_SRC

** macOS

I work on a macbook, so this section is where I'm loading all of my
settings that rely on local file paths, macOS applications, and
external programs.

#+NAME: macos-spec
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes :exports none
;; Begin MacOS
(progn
  ;; MacOS keybindings
  <<macos-keybindings>>

  ;; macOS computer name
  <<macos-computer-name>>

  ;; macOS finder
  <<macos-finder-config>>

  ;; macOS Dash
  <<macos-dash-config>>

  ;; macOS Dev Utils
  <<macos-dev-utils>>

  ;; macOS Dictionary.app
  <<macos-dictionary>>

  ;; macOS Trash
  <<macos-trash>>

  ;; macOS clipboard
  <<macos-pbcopy>>

  ;; macOS app
  <<macos-counsel-osx-app>>)
;; End MacOS
#+END_SRC

*** MacOS Keys

#+NAME: macos-keybindings
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; MacOS prefix
<<macos-prefix>>
;; Modifer Keys
<<macos-modifier-keys>>
;; Mouse-2
<<macos-mouse-2>>
#+END_SRC

**** Prefix Map

#+NAME: macos-prefix
#+BEGIN_SRC emacs-lisp :tangle no
(define-prefix-command 'macos-prefix-map)
(define-key 'halidom-prefix-map "m" 'macos-prefix-map)

(which-key-add-prefix-title "M-m m" "")
#+END_SRC

**** Modifier Keys

macOS specific settings[fn:9].

Maps the modifier keys based on personal preferences.
Also sets terminal coding system to "utf-8".

#+NAME: macos-modifier-keys
#+BEGIN_SRC emacs-lisp :tangle no
(setq mac-command-modifier 'super
      mac-option-modifier  'meta
      ns-control-modifier  'control
      ns-function-modifier 'hyper)

(when *is-mac*
  (global-set-key (kbd "s-=" ) 'text-scale-increase)
  (global-set-key (kbd "s--")  'text-scale-decrease)
  ;; Default is <XF86Back> .. C-x <right>
  (global-set-key (kbd "s-[")  'previous-buffer)
  (global-set-key (kbd "s-]")  'next-buffer)
  (global-set-key (kbd "s-}")  'ns-next-frame)
  (global-set-key (kbd "s-{")  'ns-prev-frame)
  (global-set-key (kbd "s-L")   'mark-sexp))

#+END_SRC

**** Generate =<mouse-2>= on trackpad

As far as I know, there is no trackpad gesture to trigger the
=<mouse-2>= event in Emacs. The following snippet uses [[help:key-translation-map][key-translation-map]] to emulate the =<mouse-2>= event when clicking
the trackpad (=<mouse-1>=) like normal while holding down Command, or
"super", modifier key

#+NAME: macos-mouse-2
#+BEGIN_SRC emacs-lisp :tangle no
;; From https://emacs.stackexchange.com/questions/20946/generate-mouse-2-event-from-macbook-trackpadTrackpage
(when *is-mac*
  (define-key key-translation-map (kbd "<s-mouse-1>") (kbd "<mouse-2>")))
#+END_SRC

*** MacOS Computer Name

#+NAME: macos-computer-name
#+BEGIN_SRC emacs-lisp :tangle no
(defun halidom/computer-name-cmd ()
  (let* ((has-scutil
          (executable-find "scutil"))
	       (scutil-cmd
          (lambda ()
            (shell-command-to-string "scutil --get ComputerName"))))
    (if has-scutil
	      (replace-regexp-in-string "\n" "" (funcall scutil-cmd)) nil)))

(defvar computer-name nil)

(when *is-mac*
  (setq computer-name (halidom/computer-name-cmd)))

(defconst *is-hal* (string= computer-name "hal"))
#+END_SRC

*** MacOS Dev Utils

Small library for opening files and buffers in external text
editors and various other applications on macOS.

#+NAME: macos-dev-utils
#+BEGIN_SRC emacs-lisp :tangle no
(use-package macos-dev-utils
  :if *is-mac*
  :straight
  (macos-dev-utils
   :host github
   :repo "jchaffin/macos-dev-utils")

  :commands (macos-iterm-command-map macos-open-with-command-map)
  :init
  (require 'macos-dev-utils)

  (define-key 'macos-prefix-map "t" 'macos-iterm-command-map)
  (define-key 'macos-prefix-map "o" 'macos-open-with-command-map)

  
  (which-key-add-key-based-replacements "M-m m t" '("iTerm" . "iTerm"))

  (which-key-add-key-based-replacements "M-m m o" '("Open With" . "Open With")))

#+END_SRC

*** MacOS Dash
:PROPERTIES:
:ID:       64240356-D983-4422-A359-4F773DD2E946
:CUSTOM_ID: macos-dash
:END:

Dash.app is an application for quickly searching and navigating API
docsets for programming tools and languages.
There are already two Emacs plugins that utilize Dash docsets,
helm-dash and counsel-dash, which is a simple wrapper around helm
dash.

For whatever reason, I can't figure out how to open the docset in an
=eww= frame or in an external browser using =browse-url=.

Because of the OS/licensing restrictions of Dash.app, both these
packages try to solve the problem of creating an interface for users
to navigate, query, and switch between docsets.

Because I've purchased a license and run macOS locally, I'm going to
bypass that problem and define a function that uses the
=dash-plugin://= protocol to launch/switch to the application and
query it with the marked region or symbol at point.

#+NAME: macos-dash-config
#+BEGIN_SRC emacs-lisp :tangle no
(defvar dash-plugin-keywords nil
  "An `alist' of keywords representing the docsets which should
  searched in the query to Dash.app")

(defun macos-dash-at-point ()
  (interactive)
  (let* ((protocol "dash-plugin://")
         (keywords (if dash-plugin-keywords
                       (mapconcat 'identity dash-plugin-keywords ",")
                     ""))
         (search-string
          (if (use-region-p)
              (buffer-substring-no-properties
               (region-beginning)
               (region-end))
            (substring-no-properties (or (thing-at-point 'symbol) "")))))

    (start-process "Dash" nil "open"
                   (concat
                    protocol
                    (unless (string-empty-p keywords)
                      (concat "keys=" keywords "&"))
                    "query="
                    (url-hexify-string search-string)))))
#+END_SRC

*** Reveal in macOS Finder

#+NAME: macos-finder-config
#+BEGIN_SRC emacs-lisp :tangle no
(use-package reveal-in-osx-finder
  :if *is-mac*
  :commands (reveal-in-osx-finder))
#+END_SRC

*** OSX Dictionary

Provides an interface to /Dictionary.app/ in Emacs. I am using this
package in conjunction with [[#dictionary-el][dictionary.el]] right now. The latter
package uses an open-source dictionary server to access
dictionaries. I haven't tested it on a different OS yet, but it should
provide comparable functionality to [[https://github.com/xuchunyang/osx-dictionary.el][osx-dictionary.el]] on machines not
running macOS.

#+NAME: macos-dictionary
#+BEGIN_SRC emacs-lisp :tangle no
(use-package osx-dictionary
  :if *is-mac*
  :defines (osx-dictionary-open-dictionary-app-at-point)
  :commands (osx-dictionbary-search-word-at-point
             osx-dictionary-search-input)
  :init
  (progn
    (defun osx-dictionary-open-dictionary-app-at-point ()
      (interactive)
      "Open `word' at point in Dictionary.app."

      (shell-command (format "open dict://%s" (thing-at-point 'word))))
    (define-prefix-command 'osx-dictionary-keymap)
    (define-key 'macos-prefix-map
        "d" 'osx-dictionary-keymap)
    (define-key 'osx-dictionary-keymap
        "d" 'osx-dictionary-search-word-at-point)
    (define-key 'osx-dictionary-keymap
        "s" 'osx-dictionary-search-input)
    (define-key 'osx-dictionary-keymap
        "o" 'osx-dictionary-open-dictionary-app-at-point)))

#+END_SRC

*** OSX Trash

#+NAME: macos-trash
#+BEGIN_SRC emacs-lisp :tangle no
(use-package osx-trash
  :if (and *is-mac* (not (boundp 'mac-system-move-file-to-trash-use-finder)))
  :init
  (progn
    (osx-trash-setup))
  :config
  (progn
    (setq delete-by-moving-to-trash t)))
#+END_SRC

*** OSX Clipboard

#+NAME: macos-pbcopy
#+BEGIN_SRC emacs-lisp :tangle no
(use-package pbcopy
  :if (and *is-mac* (not (display-graphic-p)))
  :init (turn-on-pbcopy))
#+END_SRC

*** Counsel OSX App

#+NAME: macos-counsel-osx-app
#+BEGIN_SRC emacs-lisp :tangle no
(use-package counsel-osx-app
  :if *is-mac*
  :after ivy
  :demand t
  :commands counsel-osx-app
  :config
  (define-key 'macos-prefix-map "a" 'counsel-osx-app))
#+END_SRC

* Tex and Org Mode

#+NAME: core/orgtex
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;;; Org and LateX Group
;; LaTeX Mode
<<orgtex/tex>>
;; Org mode
<<orgtex/org>>
;; End Org Mode
;; org-latex
<<orgtex/org-latex>>
;;; End Org and LaTeX Group
#+END_SRC

** Latex
:PROPERTIES:
:ID:       C2BC6BE6-0295-4540-8E6F-9C8620FCBE0B
:CUSTOM_ID: sec:latex
:END:

#+NAME: orgtex/tex
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; AucTeX
<<tex/auctex>>
;; Tex
<<latex-tex>>
;; Reftex
<<latex-reftex>>
;; Bibtex
<<latex-bibtex>>
;; Company backend for latex completion
<<latex-company-auctex>>
;; Company reftex
<<latex-company-reftex>>
;; Prettify latex buffers
<<latex-magic-latex-buffer>>
;; Extra latex utilities
<<tex/extra>>
;; Cdlatex
<<latex-cdlatex>>
;; Auctex Latexmk
<<latex-auctex-latexmk>>
;; LaTeX Math
<<latex-math>>
;; Latex Preview
<<latex-org-preview>>
;; Texinfo mode
<<latex-texinfo>>
#+END_SRC

*** Auctex

Recent versions of AuCTeX are problematic with straight.
On a clean install, I had to manually run the following command to get
it to work properly:

#+BEGIN_SRC shell :tangle no :results none
( cd $HOME/.emacs.d/straight/repos/auctex && \
      ./autogen.sh && \
      ./configure --with-texmf-dir=`kpsewhich --var-value=TEXMFHOME` && \
      make && make install )
#+END_SRC

#+NAME: tex/auctex
#+BEGIN_SRC emacs-lisp :tangle no
(use-package auctex
  :bind (:map LaTeX-mode-map
              ("M-s l" . TeX-engine-set)))
#+END_SRC

*** Tex

Note that LaTeX packages are loaded, configured, and installed when
='latex= is a member of =org-export-enabled-backends=.

#+NAME: latex-tex
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package tex
    :straight auctex
    :custom
    ;; (TeX-command-default
    ;;  (if (executable-find "latexmk") "LatexMk" "LaTeX"))
    (TeX-error-overview-open-after-TeX-run t)
    (TeX-auto-save t)
    (TeX-parse-self t)
    (TeX-syntactic-comment t)
    ;; nonstopmode
    (TeX-interactive-mode nil)
    ;; Don't insert line-break at inline math
    (LaTeX-fill-break-at-separators nil)
    (LaTeX-item-indent nil)

    :init

    ;; https://emacs.stackexchange.com/a/19475
    (defun latex/view-hook ()
      "Use pdf-tools to open PDF files."
      (add-to-list 'TeX-view-program-list '("PDF Tools" TeX-pdf-tools-sync-view))
      (setf (alist-get 'output-pdf TeX-view-program-selection) '("PDF Tools"))
      (setq TeX-source-correlate-start-server t)
      (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer))

    (defun latex/shell-escape ()
      "Use the shell escape flag with `TeX-command'."
      (setq TeX-command-extra-options "-shell-escape"))

    (defun latex/enable-flyspell ()
      (when (fboundp 'flyspell-mode)
        (flyspell-mode 1)))

    (defun latex/revert-doc-view ()
      (when (fboundp 'doc-view-mode)
        (add-hook 'doc-view-mode 'auto-revert-mode)))

    (defun latex/enable-ggtags ()
      (when (fboundp 'ggtags-mode)
        (ggtags-mode 1)))

    :hook
    (LaTeX-mode . latex/shell-escape)
    (LaTeX-mode . latex/view-hook)
    (LaTeX-mode . latex/enable-flyspell)
    (LaTeX-mode . latex/revert-doc-view)
    (LaTeX-mode . latex/enable-ggtags)
    (LaTeX-mode . LaTeX-math-mode)
    (LaTeX-mode . TeX-fold-mode)
    (LaTeX-mode . TeX-source-correlate-mode)
    (LaTeX-mode . TeX-PDF-mode)
    (LaTeX-mode . display-line-numbers-mode))
#+END_SRC

*** Reftex


RefTeX is a citation and reference tool maintained by the
AucTeX team.

Since Emacs 24.3, its built in with the Emacs distribution.

#+NAME: latex-reftex
#+BEGIN_SRC emacs-lisp :tangle no
(use-package reftex
    :straight nil
    :init
    (defun halidom/latex-reftex-hook ()
      (turn-on-reftex)
      (setq reftex-plug-into-AUCTeX '(nil nil t t t)
            reftex-use-fonts t
            reftex-default-bibliography (list (file-truename "~/Dropbox/org/papers/references.bib"))))
    :hook
    (LaTeX-mode . halidom/latex-reftex-hook))
#+END_SRC

*** BibTex

BibTeX mode is built-in with GNU Emacs. Like /super/ built-in. This is
from the author of the online BibTeX mode manual[fn:10]:

#+BEGIN_QUOTE
I am not the author of this file and am only putting it online because, to my knowledge, it is not available anywhere else anymore and I find it a very valuable reference.  I haven't been able to find out who the current maintainer of the BibTex-Mode for GNU emacs is, but am willing to withdraw this text or add any copyright notice that would be deemed relevant.
#+END_QUOTE

That was from 2009...

These are the recommended settings in the [[https://github.com/jkitchin/org-ref/blob/master/org-ref.org#bibtex-key-format][org-ref]] documentation.

#+NAME: latex-bibtex
#+BEGIN_SRC emacs-lisp :tangle no
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
#+END_SRC

*** Extra
:PROPERTIES:
:ID:       3D058D68-FED6-43C9-B48B-E9280E6F2016
:CUSTOM_ID: sec:extra
:END:

#+NAME: tex/extra
#+BEGIN_SRC emacs-lisp :tangle no
(use-package latex-extra
  :custom
  (latex/no-fill-environments
   '("equation"
     "equation*"
     "align"
     "align*"
     "forest"
     "forest*"
     "tabular"
     "tikzpicture"))

    :bind (:map LaTeX-mode-map
                ("C-c C-a" . latex/compile-commands-until-done)
                ("C-c C-n" . latex/next-section)
                ("C-c C-u" . latex/up-section)
                ("C-c C-f" . latex/next-section-same-level)
                ("C-M-f"   . latex/forward-environment)
                ("C-M-b"   . latex/backward-environment)
                ("C-M-a"   . latex/beginning-of-environment)
                ("C-c C-p" . latex/previous-section)
                ("C-c C-b" . latex/previous-section-same-level)
                ("C-c C-q" . latex/clean-fill-indent-environment))

    :init
    (defun tex/latex-extra ()
      (latex-extra-mode 1))

    :hook
    (LaTeX-mode . tex/latex-extra))

#+END_SRC

*** Preview

#+NAME: latex-org-preview
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Preview Pane
<<latex-latex-preview-pane>>
;; Use single directory to store previews
<<org-preview-directory>>
;; Clear Cache
<<org-preview-clear-cache>>
;; Preview Parsing
<<org-preview-parsing>>
;; Org Preview default
<<org-preview-default>>
;; Org Preview format options
<<org-preview-format>>
;; XeLaTeX Fragments
<<org-preview-xelatex>>
;; LuaLaTeX Fragments
<<org-preview-lualatex>>
;; Preview process hook
<<org-preview-dynamic>>
#+END_SRC

***** LaTeX Preview Pane

Not tangling right now because it's creating a new buffer after every
save.

#+NAME: latex-latex-preview-pane
#+BEGIN_SRC emacs-lisp :tangle no
(use-package latex-preview-pane
    :after (:all pdf-tools tex)
    :init (latex-preview-pane-enable))
#+END_SRC

***** Use single directory for storing latex fragments

#+NAME: org-preview-directory
#+BEGIN_SRC emacs-lisp :tangle no
(let ((ltximg "~/.ltximg/"))
  (when (file-directory-p ltximg)
    (setq org-preview-latex-image-directory ltximg)))
#+END_SRC

***** Clear Cache

#+NAME: org-preview-clear-cache
#+BEGIN_SRC emacs-lisp :tangle no
(defun org-preview-clear-cache ()
  (interactive)
  (let ((preview-cache
         (f-join default-directory org-preview-latex-image-directory)))
    (if (f-directory? preview-cache)
        (f-delete preview-cache t)
      (message "%s" "Directory 'ltximg' does not exist."))))
#+END_SRC

***** Set the default preview process

#+NAME: org-preview-default
#+BEGIN_SRC emacs-lisp :tangle no
(if (image-type-available-p 'imagemagick)
    (setq org-preview-latex-default-process 'imagemagick)
  (setq org-preview-latex-default-process 'dvisvgm))
#+END_SRC

***** Format Options

#+NAME: org-preview-format
#+BEGIN_SRC emacs-lisp :tangle no
(when (boundp 'org-format-latex-options)
  (plist-put org-format-latex-options :scale 1.2))
#+END_SRC

***** Parsing keywords

#+NAME: org-preview-parsing
#+BEGIN_SRC emacs-lisp :tangle no
(defun org-preview/process-keyword  (p)
  (interactive)
  (org-element-map (org-element-parse-buffer) 'keyword
    (lambda (k)
      (if (string= p (org-element-property :key k))
          (intern (org-element-property :value k))))
    nil t))

(defun org-preview/process-compiler ()
  (or (org-preview/process-keyword "LATEX_COMPILER")
     org-latex-compiler))

(defun org-preview/set-process ()
  (or (org-preview/process-keyword "PREVIEW")
     org-preview-latex-default-process))

(defun org-preview/process-class ()
  (or (org-preview/process-keyword "LATEX_CLASS")
     org-latex-default-class))

(defun org-preview/orgling-p ()
  (let ((latex-class (org-preview/process-class)))
    (string= "orgling" latex-class)))

(defun org-preview/uclacs-p ()
  (let ((latex-class (org-preview/process-class)))
    (string= "uclacs" latex-class)))

#+END_SRC

***** XeLaTeX fragments

#+NAME: org-preview-xelatex
#+BEGIN_SRC emacs-lisp :tangle no
(defcustom xelatex-preview-header org-format-latex-header
  "The preamble to use for previewing LaTeX fragments with XeLaTeX."
  :type 'string)

(defcustom xelatex-preview-process-alist
  '((dvipng
     :programs
     ("xelatex" "dvipng")
     :description "dvi > png"
     :message "You need to install the programs: xelatex and dvipng"
     :image-input-type "dvi"
     :image-output-type "png"
     :image-size-adjust (1.3 1.3)
     :latex-compiler
     ("xelatex -interaction nonstopmode -output-directory %o %f")
     :image-converter
     ("dvipng -fg %F -bg %B -D %D -T tight -o %O %f"))
    (dvisvgm
     :programs
     ("latex" "dvisvgm")
     :description "dvi > svg"
     :message "you need to install the programs: xelatex and dvisvgm."
     :use-xcolor t
     :image-input-type "xdv"
     :image-output-type "svg"
     :image-size-adjust
     (1.7 . 1.5)
     :latex-compiler
     ("xelatex -no-pdf -interaction nonstopmode -output-directory %o %f")
     :image-converter
     ("dvisvgm %f -n -b min -c %S -o %O"))
    (imagemagick
     :programs ("xelatex" "convert")
     :description "pdf > png"
     :message "You need to install xelatex and imagemagick"
     :use-xcolor t
     :image-input-type "pdf"
     :image-output-type "png"
     :image-size-adjust (1.0 1.0)
     :latex-compiler ("xelatex -interaction nonstopmode -output-directory %o %f")
     :image-converter
     ("convert -density %D -trim -antialias %f -quality 100 %O")))
  "Preview engines for xelatex."
  :type '(alist
          :tag "LaTeX to image backends"
          :value-type (plist)))

(defun org-preview-xelatex ()
  (interactive)
  (let ((preview-file  (emacs-etc-dir "preview" "orgling-preview.tex")))
    (set (make-local-variable 'org-preview-latex-process-alist)
         xelatex-preview-process-alist)

    (when (assoc 'latex org-babel-load-languages)
      (setq org-edit-latex-frag-master preview-file))


    (set (make-local-variable 'org-format-latex-header)
         (if (org-preview/orgling-p)
             (read-file-contents preview-file)
           xelatex-preview-header)))
  )
#+END_SRC

***** LuaLaTeX Fragments

#+NAME: org-preview-lualatex
#+BEGIN_SRC emacs-lisp :tangle no
(defcustom lualatex-preview-header nil
  "The preamble to use for previewing LaTeX fragments with LuLaTeX."
  :type 'string)

(defcustom lualatex-preview-process-alist
  '((dvipng
     :programs
     ("lualatex" "dvipng")
     :description "dvi > png"
     :message "You need to install the programs: lualatex and dvipng"
     :image-input-type "dvi"
     :image-output-type "png"
     :image-size-adjust (1.3 1.3)
     :latex-compiler
     ("lualatex -interaction nonstopmode -output-directory %o %f")
     :image-converter
     ("dvipng -fg %F -bg %B -D %D -T tight -o %O %f"))
    (dvisvgm
     :programs
     ("latex" "dvisvgm")
     :description "dvi > svg"
     :message "you need to install the programs: lualatex and dvisvgm."
     :use-xcolor t
     :image-input-type "xdv"
     :image-output-type "svg"
     :image-size-adjust
     (1.7 . 1.5)
     :latex-compiler
     ("lualatex -no-pdf -interaction nonstopmode -output-directory %o %f")
     :image-converter
     ("dvisvgm %f -n -b min -c %S -o %O"))
    (imagemagick
     :programs ("lualatex" "convert")
     :description "pdf > png"
     :message "You need to install lualatex and imagemagick"
     :use-xcolor t
     :image-input-type "pdf"
     :image-output-type "png"
     :image-size-adjust (1.0 1.0)
     :latex-compiler ("lualatex -interaction nonstopmode -output-directory %o %f")
     :image-converter
     ("convert -density %D -trim -antialias %f -quality 100 %O")))
  "Preview engines for lualatex."
  :type '(alist
          :tag "LaTeX to image backends"
		      :value-type (plist)))


(defun org-preview-lualatex ()
  (interactive)
  (let ((preview-file (emacs-etc-dir "preview" "uclacs-preview.tex")))
    (set (make-local-variable 'org-preview-latex-process-alist)
         lualatex-preview-process-alist)

    (when (assoc 'latex org-babel-load-languages)
      (setq org-edit-latex-frag-master preview-file))

    (set (make-local-variable 'org-format-latex-header)
         (if (org-preview/uclacs-p)
             (concat lualatex-preview-header
                     (read-file-contents preview-file))
           lualatex-preview-header))))
#+END_SRC

***** Per-buffer latex fragment previews

Generate latex fragments based on the latex compiler and class in the current buffer.

#+NAME: org-preview-dynamic
#+BEGIN_SRC emacs-lisp :tangle no
  (defun org-preview-with-compiler ()
    (interactive)
    (let ((latex-compiler (org-preview/process-compiler)))
      (when-let (preview-process (org-preview/set-process))
        (set (make-local-variable 'org-preview-latex-default-process)
             preview-process))

      (when (or  (string= latex-compiler "xelatex")
                (string= latex-compiler "xetex"))
        (org-preview-xelatex))

      (when (string= latex-compiler "lualatex")
        (org-preview-lualatex))))

(add-hook 'org-mode-hook 'org-preview-with-compiler)
#+END_SRC

*** Company Auctex

#+NAME: latex-company-auctex
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-auctex
  :demand t
  :after (:all company tex)
  :init
  (company-auctex-init))
#+END_SRC

*** Company Reftex

#+NAME: latex-company-reftex
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-reftex
  :demand t
  :after (:all company reftex))
#+END_SRC

*** cdlatex

#+NAME: latex-cdlatex
#+BEGIN_SRC emacs-lisp :tangle no
(use-package cdlatex
  :custom
  ;; Disable auto label insertion in expanded template.
  ;; Labels conflict when used in conjunction with `org-ref'
  (cdlatex-insert-auto-labels-in-env-templates t)
  :hook
  ;; with AucTeX LaTeX mode
  ;; (LaTeX-mode . turn-on-cdlatex)
  ;; with Emacs latex mode
  ;; (latex-mode . turn-on-cdlatex)
  (org-mode . org-cdlatex-mode))
#+END_SRC

*** Magic Latex Buffer

Prettify dedicated org-mode latex buffers.

#+NAME: latex-magic-latex-buffer
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package magic-latex-buffer
      :custom
      (magic-latex-enable-block-highlight t)
      (magic-latex-enable-suscript nil)
      (magic-latex-enable-pretty-symbols t)
      (magic-latex-enable-block-align nil)
      (magic-latex-enable-inline-image nil)
      :hook
      (LaTeX-mode . magic-latex-buffer))
#+END_SRC

*** Auctex Latexmk

#+NAME: latex-auctex-latexmk
#+BEGIN_SRC emacs-lisp :tangle no
(use-package auctex-latexmk
    :custom
    (auctex-latexmk-inherit-TeX-PDF-mode t)
    :init
    (auctex-latexmk-setup))
#+END_SRC

*** Texinfo

#+NAME: latex-texinfo
#+BEGIN_SRC emacs-lisp :tangle no
(use-package texinfo
  :defines texinfo-section-list
  :commands texinfo-mode
  :mode
  ("\\.texi\\'" . texinfo-mode))
#+END_SRC

*** LaTeX Math

#+NAME: latex-math
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Math Symbols
<<latex-math-symbols>>
;; Company Math
<<latex-math-completion>>
#+END_SRC

**** Company Math

#+NAME: latex-math-completion
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-math
  :after (company)
  :demand t
  :init
  (add-to-list 'company-backends 'company-math-symbols-unicode))
#+END_SRC

**** Math Symbols

Entered on [2018-06-13 Wed 11:42]

#+NAME: latex-math-symbols
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package math-symbols
    :init

    (defun latex/font (math-input before after)
     "Insert a LaTeX font.

   MATH-INPUT is the input method to toggle in math environments.

   The BEFORE and AFTER arguments are the strings to insert around
   the marked region, when active. If the thing at point is a word,
   then wrap the word. Otherwise the two elements are joined at point."
     (cond ((texmathp)
            (if current-input-method
                (set-input-method nil)
              (set-input-method math-input)))
           ((region-active-p)
            (save-excursion
              (goto-char (region-beginning))
              (insert before)
              (goto-char (region-end))
              (insert after)))
           ((thing-at-point 'word)
            (save-excursion
              (goto-char (beginning-of-thing 'word))
              (insert before)
              (goto-char (end-of-thing 'word))
              (insert after)))
           (t
            (save-excursion
              (insert (concat before after)))
            (goto-char (+ (point) (length before))))))

    (defun latex/prettify-symbols-extra ()
      (if osx-browse-mode
          (osx-browse-mode nil))

      (when (fboundp 'prettify-symbols-mode)
        (prettify-symbols-mode 1))

      (setq prettify-symbols-alist
            '(("\\complement" . "∁"))))

    (setq-default abbrev-mode t)
    (setq latex-mode-abbrev-table nil)

    (define-abbrev-table 'latex-mode-abbrev-table
        '(("uiff"  "⟷")
          ("uif"  "⟶")
          ("uand" "∧")
          ("ulambda" "𝜆")
          ("uor" "∨")
          ("uxor" "⨁")
          ("uexists" "∃")
          ("unexists" "∄")
          ("usubset" "⊂")
          ("unsubset" "⊄")))

    (defun latex/unbind-osx-browse ()
      (when (fboundp 'osx-browse-mode)
        (let ((map osx-browse-mode-map))
          (define-key map (kbd "s-b") nil)
          (define-key map (kbd "s-i") nil))))

    (defun latex/font-italic ()
      "Insert a literal italic typeset command, or toggle input method
  in math environments with unicode math enabled."
      (interactive)
      (latex/font "math-symbols-italic" "\\textit{" "}"))

    (defun latex/font-bold ()
      "Insert a literal bold typeset command, or toggle input method
  in math environments with unicode math enabled."
      (interactive)
      (latex/font "math-symbols-bold" "\\textbf{" "}"))

    (let ((map LaTeX-mode-map))
      (define-key map (kbd "s-b") 'latex/font-bold)
      (define-key map (kbd "s-i") 'latex/font-italic))

    :hook
    (LaTeX-mode . latex/unbind-osx-browse)
    (LaTeX-mode . latex/prettify-symbols-extra))

#+END_SRC

** Org Mode
:PROPERTIES:
:ID:       C2106106-C5F8-4B9B-815D-058678CB9242
:END:

#+NAME: orgtex/org
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Org command map
<<org/commander>>
;; Org Babel
<<org/ob>>
;; Org UI
<<org/appearance>>
;; Org docmgr
<<org/structure>>
;; Concept Mapping
<<org/concept>>
;; Org taskmgr
<<org/tasks>>
;; Org ideamgr
<<org-ideamgr>>
;; Org export
<<org/ox>>
#+END_SRC

*** Org Command Map
#+NAME: org/commander
#+BEGIN_SRC emacs-lisp :tangle no
  (define-prefix-command 'halidom/org-command-map)

  ;; (let ((map halidom/org-command-map))
  ;;   (define-key map "j" 'org-journal-new-entry))

  (define-key 'halidom-prefix-map (kbd "o")
   'halidom/org-command-map)

  (which-key-add-prefix-title "M-m o" "Org")
#+END_SRC
 

*** Org Babel

#+NAME: org/ob
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Begin Org Babel
; ob-http
<<org-ob-http>>
;; ob-cljs
<<org-ob-cljs>>
;; Load languages
<<org-ob-load-langs>>
;; End Org Babel
#+END_SRC

**** Ob Http

#+NAME: org-ob-http
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ob-http
  :after (ob)
  :demand t)
#+END_SRC

**** Ob ClojureScript

[[https://github.com/emacsmirror/ob-clojurescript][ob-clojurescript]] uses [[https://github.com/anmonteiro/lumo][lumo]] to evaluate ClojureScript code blocks in
=org-mode= buffers.

#+NAME: org-ob-cljs
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ob-clojurescript
  :if (executable-find "lumo")
  :after (ob)
  :demand t)
#+END_SRC

**** Load Languages

#+NAME: org-ob-load-langs
#+BEGIN_SRC emacs-lisp :tangle no
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((C . t)
     (clojure . t)
     (clojurescript . t)
     (dot . t)
     (ditaa . t)
     (latex . t)
     (lisp . t)
     (emacs-lisp . t)
     (http . t)
     (perl . t)
     (python . t)
     (plantuml . t)
     (java . t)
     (ruby . t)
     (R . t)
     (shell . t)
     (org . t)))
#+END_SRC

*** Org Appearance

These settings subjectively improve the overall viewable-ness of
org-mode buffers.

#+NAME: org/appearance
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Enable visual fill column
<<org-ui-fill>>
;; UI Fixed Width Block
<<org-ui-fixedwidth-image>>
;; UI Org Bullets
<<org-ui-org-bullets>>
;; UI Toc Org
<<org-ui-toc-org>>
;; UI Column View
<<org-ui-column-view>>
;; UI Equation Renumbering
<<org-ui-equation-renumbering>>
;; Outline Numbering
<<org-ui-outline-numbering>>
;; Radio Button
<<org-ui-radiobutton>>
#+END_SRC

**** Org visual fill

#+NAME: org-ui-fill
#+BEGIN_SRC emacs-lisp :tangle no

(defun halidom/vfc-hook ()
  (visual-fill-column-mode 1)
  (visual-line-mode 1))


(add-hook 'org-mode-hook #'halidom/vfc-hook)


#+END_SRC

**** Per-image display width

Specify image width in org buffer on per-image basis.

#+NAME: org-ui-fixedwidth-image
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-image-actual-width nil)
#+END_SRC

**** Org Bullets

Inspired by this [[http://nadeausoftware.com/articles/2007/11/latency_friendly_customized_bullets_using_unicode_characters][article]] on creating latency-friendly unicode bullets,
the [[https://github.com/sabof/org-bullets][org-bullets]] library provides support for displaying org-mode
bullets as UTF-8 characters.

- The default set ::  ◉ ○ ✸ ✿
- Smaller set :: ► • ★ ▸
- Alternative options :: ♥ ● ◇ ✚ ✜ ☯ ◆ ♠ ♣ ♦ ☢ ❀ ◆ ◖ ▶


The default set of bullet points can be modified via the
=[[help:org-bullets-bullet-list][org-bullets-bullet-list]]= variable.


#+NAME: org-ui-org-bullets
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-bullets
    :demand t
    :custom
    (org-bullets-bullet-list '("‣" "•"))
    :init
    (defun org-bullets/enable ()
      (org-bullets-mode +1))

    (defun org-bullets/pretty ()
      (setq org-pretty-entities t)
      (setq org-pretty-entities-include-sub-superscripts nil)
      (setq org-hide-emphasis-markers t)
      (setq org-fontify-quote-and-verse-blocks t))

    :hook
    (org-mode . org-bullets/enable)
    (org-bullets . org-bullets/pretty))
#+END_SRC

**** TOC Org

The [[https://github.com/snosov1/toc-org][toc-org]] package automatically generates a table of contents for
the org-mode document on save.

The org header represented by a TOC entry can be visited via the
=org-open-at-point= command, which is bound to the keystroke =C-c C-o=
by default.

Note that this functionality is provided by =toc-org= modifying the
value of =org-link-translation-function= to the library internal
=toc-org-unhrefify=, so it won't work if this symbol is non-nil at
time of install.

#+NAME: org-ui-toc-org
#+BEGIN_SRC emacs-lisp :tangle no
(use-package toc-org
  :init
  (add-hook 'org-mode-hook 'toc-org-enable))
#+END_SRC

**** Column View

#+NAME: org-ui-column-view
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-columns-default-format "%50ITEM(Task) %10CLOCKSUM %16TIMESTAMP_IA")
#+END_SRC

**** Equation Renumbering

Anotha [[http://kitchingroup.cheme.cmu.edu/blog/2016/11/07/Better-equation-numbering-in-LaTeX-fragments-in-org-mode/][one]] from the kitchin group!

#+NAME: org-ui-equation-renumbering
#+BEGIN_SRC emacs-lisp :tangle no
(defun org-renumber-environment (orig-func &rest args)
  (let ((results '())
        (counter -1)
        (numberp))

    (setq results
          (loop for (begin .  env) in
               (org-element-map (org-element-parse-buffer) 'latex-environment
                 (lambda (env)
                   (cons
                    (org-element-property :begin env)
                    (org-element-property :value env))))
             collect
               (cond
                 ((and (string-match "\\\\begin{equation}" env)
                     (not (string-match "\\\\tag{" env)))
                  (incf counter)
                  (cons begin counter))
                 ((string-match "\\\\begin{align}" env)
                  (prog2
                      (incf counter)
                      (cons begin counter)
                    (with-temp-buffer
                      (insert env)
                      (goto-char (point-min))
                              ;; \\ is used for a new line. Each one leads to a number
                      (incf counter (count-matches "\\\\$"))
                      ;; unless there are nonumbers.
                      (goto-char (point-min))
                      (decf counter (count-matches
                                     "\\nonumber")))))
                         (t
                          (cons begin nil)))))

    (when (setq numberp (cdr (assoc (point) results)))
      (setf (car args)
            (concat
             (format "\\setcounter{equation}{%s}\n" numberp)
             (car args)))))

  (apply orig-func args))

;; (advice-add 'org-create-formula-image
;;           :around #'org-renumber-environment)

#+END_SRC

**** Org radiobutton
:PROPERTIES:
:ID:       EA7D1F8C-6A3E-4154-B1ED-581F8B5446C3
:END:

The [[https://github.com/Fuco1/org-radiobutton][org-radiobutton]] package a minor mode which automates the property
requirements for radiobutton lists.

See this [[https://fuco1.github.io/2018-03-11-Use-org-radiobutton-to-select-an-option-from-a-list.html][blogpost]] for more information.

#+NAME: org-ui-radiobutton
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-radiobutton
  :init
  (when (fboundp 'global-org-radiobutton-mode)
    (global-org-radiobutton-mode)))
#+END_SRC

**** Org Outline Numbering

#+NAME: org-ui-outline-numbering
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-outline-numbering
    :custom-face
    (org-outline-numbering-face
     ((t (:family "Sans" :weight book :inherit (default)))))
    :init
    (defun org/outline-numbering ()
      (org-outline-numbering-mode 1)))

#+END_SRC

*** Structure and Editing

#+NAME: org/structure
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Begin Org Doc Manager Section
;; Org Capture
<<org-docmgr-capture>>
;; Org Journal
<<org-docmgr-journal>>
;; Org ID
<<org-docmgr-id>>
;; Org Download
<<org-docmgr-download>>
;; Org Links
<<org-docmgr-links>>
;; Org Web Tools
<<org-docmgr-web>>
;; org index
<<org-docmgr-index>>
;; Interleave
<<org-docmgr-interleave>>
;; Attach
<<org-docmgr-attach>>
;; End Org Doc Manager
#+END_SRC

**** Org Capture

#+NAME: org-docmgr-capture
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; org capture templates
<<org-capture-templates>>
<<org-protocol-mac>>
;; org capture html
<<org-capture-html>>
;; org capture contacts
<<org-capture-contacts>>
#+END_SRC

#+NAME: org-capture-templates
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-capture-templates
      '(("t" "Todo" entry (file+headline "~/Dropbox/org/todos/TODOs.org" "Tasks")
         "* TODO %?\n %i\n %a")))

(defvar org-capture/created-property-string "
  :PROPERTIES:
  :CREATED: %U
  :END:")
#+END_SRC

***** Org Protocol Handler :disabled:

#+NAME: org-protocol-handler
#+BEGIN_SRC emacs-lisp :tangle no
(require 'org-protocol)

(defvar org-protocol-install-directory (no-littering-expand-var-file-name "org-protocol-handler"))

(defun org-protocol-handler-install ()
  (interactive)
  (let* ((install-dir org-protocol-install-directory)
         (op-app-path (expand-file-name "Org Protocol Handler.app" install-dir)))
    (unwind-protect
         (unless (f-dir-p install-dir)
           (mkdir install-dir)
           (when (featurep 'magit)
             (magit-clone
              "https://github.com/aaronbieber/org-protocol-handler.git" install-dir))
           (f-symlink op-app-path "/Applications/")))))

(defun org-protocol-handler-uninstall ()
  (interactive)
  (let ((app-link-path "/Applications/Org Protocol Handler.app"))
  (when (yes-or-no-p "Are you sure you want to uninstall org-protocol-handler? ")
    (when (file-exists-p app-link-path)
      (delete-file app-link-path t))
    (when (file-directory-p org-protocol-install-directory)
      (delete-directory org-protocol-install-directory t t)))))

;; (with-eval-after-load 'server
;;   (unless (server-running-p)
;;     ;; (setq server-socket-dir (f-expand "server" user-emacs-directory))
;;     (server-start))

;; 	(if (and *is-mac* (server-running-p))
;; 	    (org-protocol-handler-install)))
(if *is-mac*
    (org-protocol-handler-install))

(add-to-list 'org-capture-templates
             '("l" "A link, for reading later." entry
               (file+headline "notes.org" "Reading List")
               "* %:description\n%u\n\n%c\n\n%i"
               :empty-lines 1))
#+END_SRC

***** Org Mac Protocol

#+NAME: org-protocol-mac
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-mac-protocol
    :config
  (defun org-mac-protocol-install ()
    (interactive)
     "Install system dependencies provided by org-mac-protocol."
     (cl-flet ((f (file)
                  (let ((app-dir (no-littering-expand-var-file-name
                                  "org-mac-protocol"))
                       (script-dir (user-home "Library" "Scripts"))
                       (file-path (concat (straight-dir "repos" "org-mac-protocol") file)))
                   (if-not (file-directory-p app-dir)
                       (progn
                         (mkdir app-dir)
                         (message "Created directory %s" app-dir)))
                   (cond ((and (file-directory-p file-path)
                               (not (file-directory-p
                                     (concat script-dir (file-name-base file-path)))))
                          (copy-directory file-path script-dir))
                         ((string= (file-name-extension file-path) "scpt")
                          (copy-file file-path script-dir t))
                         ((string= (file-name-extension file-path) "applescript")
                          (copy-file file-path app-dir t))))))
       (let ((files (remove ".git" (directory-files-no-wildcards
                                    (straight-dir "repos" "org-mac-protocol")))))
         (mapcar #'f files)))))
#+END_SRC

***** Org Protocol Capture HTML

#+NAME: org-capture-html
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-protocol-capture-html
  :straight (org-protocol-capture-html
             :host github
             :repo "alphapapa/org-protocol-capture-html")
  :after (org-capture)
  :init
  (add-to-list 'org-capture-templates
               '("w" "Web site" entry
                 (file "~/Dropbox/org/capture.org")
                   "* %a :website:\n\n%U %?\n\n%:initial"))

  (defun opch-install-shell-script ()
    (interactive)
    (let* ((opch-shell-script-path
            (emacs-var-dir
             "org-protocol-capture-html"
             "org-protocol-capture-html.sh"))
           (opch-directory (file-name-directory opch-shell-script-path)))

    (unless (file-directory-p opch-directory)
      (mkdir opch-directory))

    (unless (file-exists-p opch-shell-script-path)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/alphapapa/org-protocol-capture-html/master/org-protocol-capture-html.sh"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (when (re-search-backward "^\\#!/bin/bash" (point-min) t)
          (write-region (point) (point-max) opch-shell-script-path)
          (set-file-modes opch-shell-script-path #o755)
          (message "Installed to %s" opch-shell-script-path)))))))

#+END_SRC

***** Org Contacts

#+NAME: org-capture-contacts
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-contacts
  :straight org
  :config
  (push '("c" "Contacts" entry (file "~/Dropbox/org/contacts.org")
           "* %(org-contacts-template-name)
              :PROPERTIES:
              :EMAIL: %(org-contacts-template-email)
              :END:")
        org-capture-templates))
#+END_SRC

**** Org Attach

#+NAME: org-docmgr-attach
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-attach
    :straight org
    :custom
    (org-attach-auto-tag "attach"))

#+END_SRC

**** Org Journal

#+NAME: org-docmgr-journal
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-journal
    :if *is-mac*
    :bind (:map halidom/org-command-map
                ("j" . org-journal-new-entry))
    :custom
    (org-journal-enable-agenda-integration t)
    ;; :bind
    ;; (("M-m j" . org-journal-new-entry))
    :config
    (progn
      (setq org-journal-dir (concat (file-name-as-directory org-directory) "journal")
            org-journal-date-prefix "#+TITLE: "
            org-journal-date-format "%A, %B %d %Y"
            org-journal-time-prefix "* "
            org-journal-time-format "")
      (push '("j" "Journal" entry
              (file+olp+datetree "~/Dropbox/org/journal.org")
              "* %?\nEntered on %U\n %i\n %a")
            org-capture-templates)))

#+END_SRC

**** Org ID

#+NAME: org-docmgr-id
#+BEGIN_SRC emacs-lisp :noweb yes :tangle no :exports none
<<org-id-create-custom>>
<<org-id-custom-id>>
#+END_SRC

#+NAME: org-id-create-custom
#+BEGIN_SRC emacs-lisp :tangle no

(require 'org-id)
(setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)

#+END_SRC

***** Custom ID

Functions shamelessly taken from Lee Hinman's [[https://writequit.org/articles/emacs-org-mode-generate-ids.html][blogpost]] on generating
custom org heading ids.


#+NAME:  org-id-custom-id
#+BEGIN_SRC emacs-lisp :noweb yes :tangle no :exports none
<<org-id-get-custom>>
<<org-id-headline-ids>>
#+END_SRC


****** Get Custom ID

From [[https://writequit.org/articles/emacs-org-mode-generate-ids.html][Emacs Org Mode Generate Ids]] blogpost:

#+NAME: org-id-get-custom
#+BEGIN_SRC emacs-lisp :tangle no
(defun org-custom-id-get (&optional pom create prefix)
  "Get the CUSTOM_ID property of the entry at point-or-marker POM.
   If POM is nil, refer to the entry at point. If the entry does
   not have an CUSTOM_ID, the function returns nil. However, when
   CREATE is non nil, create a CUSTOM_ID if none is present
   already. PREFIX will be passed through to `org-id-new'. In any
   case, the CUSTOM_ID of the entry is returned."
  (interactive)
  (org-with-point-at pom
    (let ((id (org-entry-get nil "CUSTOM_ID")))
      (cond
       ((and id (stringp id) (string-match "\\S-" id))
        id)
       (create
        (setq id (org-id-new (concat prefix "h")))
        (org-entry-put pom "CUSTOM_ID" id)
        (org-id-add-location id (buffer-file-name (buffer-base id))))))))
#+END_SRC

***** Add IDs to Headlines in file

#+NAME: org-id-headline-ids
#+BEGIN_SRC emacs-lisp :tangle no
(defun org-add-ids-to-headlines-in-file ()
  "Add CUSTOM_ID properties to all headlines in the current
  file which do not already have one. Only adds ids if the `auto-id' option is set a non-nil value in the file.

  i.e `#+OPTIONS: auto-id:t`"

  (interactive)
  (save-excursion
    (widen)
    (goto-char (point-min))
    (when (re-search-forward "^\\#+OPTIONS:.*auto-id:t"  (point-max)  t)
      (org-map-entries
       (lambda ()
         (org-custom-id-get (point) 'create))))))

(add-hook 'org-mode-hook
	  (lambda ()
	    (add-hook 'before-save-hook
                (lambda ()
                  (when (and (eq major-mode 'org-mode)
                             (eq buffer-read-only nil))
                    (org-add-ids-to-headlines-in-file))))))
#+END_SRC

**** Org Index


#+NAME: org-docmgr-index
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-index)
#+END_SRC

**** Org Interleave

#+NAME: org-docmgr-interleave
#+BEGIN_SRC emacs-lisp :tangle no
(use-package interleave)
#+END_SRC

**** Org Download

Drag and Drop images directly from a web browser to an org-mode buffer.

#+NAME: org-docmgr-download
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-download
  :defines (org-download-image-dir)
  :commands (org-download-enable  org-download-yank org-download-screenshot)
  :init
  (when *is-mac*
    (setq-default org-download-image-dir "~/Dropbox/org/img/"))
  :hook
  ((dired-mode org-mode) . org-download-enable))
#+END_SRC

**** Org Web Tools

#+NAME: org-docmgr-web
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-web-tools)
#+END_SRC

**** Org Links

#+NAME: org-docmgr-links
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Org Tags
 <<org-links-tags>>
;; Cliplink
<<org-links-cliplink>>
;; Org elisp help
<<org-links-elisp-help>>
;; Org YouTube
<<org-links-youtube>>
;; Org links minor mode
<<org-links-minor>>
;; Org Bookmark Heading
<<org-links-bookmark>>
#+END_SRC

***** Add Tags Link

#+NAME: org-links-tags
#+BEGIN_SRC emacs-lisp :tangle no
(defun halidom/tag-link (tag)
  "Display a list of TODO headlines with tag TAG.
With prefix argument, also display headlines without a TODO keyword."
  (org-tags-view (null current-prefix-arg) tag))

(org-add-link-type
 "tag" 'halidom/tag-link)
#+END_SRC

***** Org Elisp Help Links

#+NAME: org-links-elisp-help
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-elisp-help
  :straight t)
#+END_SRC


***** Org YouTube

From [[http://endlessparentheses.com/embedding-youtube-videos-with-org-mode-links.html][Endless Parentheses]] blogpost:

Embed YouTube Links in iframe.

#+NAME: org-links-youtube
#+BEGIN_SRC emacs-lisp :tangle no
(org-link-set-parameters
 "youtube"
 :follow (lambda (path)
	   (browse-url (format "https://youtu.be/%s" path)))
 :export (lambda (path desc backend)
	   (cond
	    ((eq 'md backend)
	     (format "[%s](%s)

<a href=\"https://www.youtube.com/watch?v=%s\">
<img src=\"http://img.youtube.com/vi/%s/0.jpg\"></a>"
		     (or desc (format "https://youtu.be/%s" path))
		     (format "https://youtu.be/%s" path)
		     path path))))
 :help-echo "A youtube video. Click to open in browser.")

#+END_SRC

***** Org Link Minor Mode

#+NAME: org-links-minor
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-link-minor-mode
  :hook (prog-mode . org-link-minor-mode))
#+END_SRC

***** Org Bookmark Heading

:PROPERTIES:
:ID:       B7904803-C4A6-439D-BD21-E449CF0B79F5
:END:

#+NAME: org-links-bookmark
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-bookmark-heading)
#+END_SRC

*** Task Management

#+NAME: org/tasks
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Begin Org Task Manager
;; Org Habit
<<org-taskmgr-habit>>
;; Org Agenda
<<org-taskmgr-agenda>>
;; Org Pomodoro
<<org-taskmgr-pomodoro>>
;; Google Maps
<<org-taskmgr-maps>>
;; Calfw
<<org-taskmgr-calfw>>
;; Org Counsel Clock
<<org-taskmgr-coclock>>
;; Org Projectile
<<org-taskmgr-projectile>>
;; Org Mru
<<org-taskmgr-mru-clock>>
;; End Org Task Manager
#+END_SRC

**** Org Habit

#+NAME: org-taskmgr-habit
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-habit
    :straight org
    :init
    (require 'org-habit))
#+END_SRC

**** Org Agenda

#+NAME: org-taskmgr-agenda
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Org Agenda
<<agenda/org-agenda>>
;; org ng
<<agenda/ng>>
;; org ql
<<agenda/ql>>
;; Side bar
<<agenda/sidebar>>
;; End Org Agenda
#+END_SRC

I use per-project agenda files for the most part (now being managed
using [[#org-projectile][org-projectile]]), but I like having a designated global one for miscellaneous or arbitrary tasks.


#+NAME: agenda/org-agenda
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-agenda

    :straight org
    :custom
    (org-tags-column 0)
    (diary-file (expand-file-name "diary.org" org-directory))
    (org-agenda-skip-deadline-if-done t)
    (org-agenda-skip-deadline-prewarning-if-scheduled t)
    (org-agenda-time-leading-zero t)
    ;; http://cachestocaches.com/2016/9/my-workflow-org-agenda/
    (org-refile-targets (quote ((nil  :maxlevel . 9)
                                (org-agenda-files :maxlevel . 9))))

    :init

    (defun goto-agenda-dir ()
      (interactive)
      (dired (agenda-dir)))


    (define-key goto-map "a" #'goto-agenda-dir)



    (setq org-agenda-category-icon-alist
     `(("syntax"     ,(list "Ᾱ")  nil nil :ascent center)
       ("phonetics"  ,(list "ə")  nil nil :ascent center)
       ("algorithms" ,(list "𝛺") nil nil :ascent center)
       ("languages"  ,(list "𝜆") nil nil :ascent center)))

    (defvar-local org-use-level-faces nil)
    (defvar org-level-remap-face nil)

    (defun halidom/remap-org-level-faces ()
      "Use minimal foreground face in `org-agenda-files' buffers."

      (let ((foreground (face-foreground 'default nil 'default)))
        (unless org-use-level-faces
          (mapcar
           (lambda (face)
             (add-to-list 'org-level-remap-face
                          (face-remap-add-relative
                           face
                           :foreground foreground)))
           org-level-faces)
          (setq-local org-use-level-faces t))))

    (defun halidom/org-agenda-face ()
      (cond ((org-agenda-file-p) (halidom/remap-org-level-faces))
            (org-use-level-faces
             (mapcar
              (lambda (f)
                (setq face-remapping-alist
                      (delq f face-remapping-alist)))
              org-level-remap-face))))

    (defvar halidom/default-agenda-file "~/Dropbox/org/todos/TODOs.org")
    (when (file-exists-p halidom/default-agenda-file)
      (add-to-list 'org-agenda-files halidom/default-agenda-file))

    :hook
    (org-mode . halidom/org-agenda-face))
#+END_SRC

***** Agenda ng

#+NAME: agenda/ng
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-agenda-ng
  :straight (org-agenda-ng :host github
                           :repo "alphapapa/org-agenda-ng"
                           :files ("org-agenda-ng.el")))

#+END_SRC

***** Org ql

#+NAME: agenda/ql
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-ql
    :straight
    (org-ql
      :type git
      :host github
      :repo "alphapapa/org-agenda-ng"
      :files ("org-ql.el")))

(use-package org-ql-agenda
    :straight
    (org-ql-agenda
      :type git
      :host github
      :repo "alphapapa/org-agenda-ng"
      :files ("org-ql-agenda.el")))

#+END_SRC

***** Org Sidebar

#+NAME: agenda/sidebar
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-sidebar
    :straight
    (org-sidebar
     :host github
     :repo "alphapapa/org-sidebar")

    :init
    (require 'org-ql)
    :config
      (org-sidebar-defsidebar ling103/sidebar
                              :header "Syntax"
        :sidebars (((and (not (done))
                       (or (deadline <=)
                          (scheduled <=)))))
        :super-groups '((:time-grid t)
                        (:name "Overdue" :scheduled past :deadline past)
                        (:name "Due"   :scheduled today :deadline today)
                        (:name "Homework" :tag "homework")
                        (:priority "A"))
        :files '("~/Dropbox/courses/ling165b/TODOs.org"))


      (defun syntax-sidebar ()
        (interactive)
        (sidebar/syntax))

      (org-sidebar-defsidebar cs131/sidebar
        :header "Syntax"
        :sidebars (((and (not (done))
                       (or (deadline <=)
                          (scheduled <=)))))
        :super-groups '((:time-grid t)
                        (:name "Overdue" :scheduled past :deadline past)
                        (:name "Due"   :scheduled today :deadline today)
                        (:name "Homework" :tag "homework")
                        (:priority "A"))
        :files '("~/Dropbox/courses/cs131/TODOs.org")))

    (defun cs131-sidebar ()
      (interactive)
      (cs131/sidebar))

#+END_SRC

**** Org Projectile
:PROPERTIES:
:ID:       D469E868-7FCB-45FD-AB3E-609018F4BC58
:CUSTOM_ID: org-projectile
:END:

#+NAME: org-taskmgr-projectile
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-projectile
    :commands (org-projectile-files-to-agenda)
    :after (projectile)
    :bind (:map projectile-command-map
                ("n" . org-projectile-project-todo-completing-read))
    :custom
    (org-projectile-per-project-filepath "TODOs.org")

    (org-projectile-capture-template
     (format
      "%s%s" "** TODO %?"
      org-capture/created-property-string))

    :init

    (defun org-projectile-files-to-agenda ()
      "Add projectile project files to agenda."
      (interactive)
      (cl-flet*
          ((project-agenda-filepath (p)
                                    (expand-file-name
                                     "TODOs.org"
                                     p))
           (todo-file-p (p)
                        (file-exists-p (project-agenda-filepath p)))
           (build-agenda (ps)
                         (setq org-agenda-files
                               (seq-uniq (append org-agenda-files ps)))))

          (->> projectile-known-projects
             (seq-filter #'todo-file-p)
             (mapcar #'project-agenda-filepath)
             build-agenda)))

    :hook
    (org-agenda-mode . org-projectile-files-to-agenda)
    (dashboard-mode . org-projectile-files-to-agenda)

    :config

    (org-projectile-per-project)

    (add-to-list 'org-capture-templates
                 (org-projectile-capture-for-current-project
                  :capture-character "p"
                  :capture-heading "Linked Project TODO")))

#+END_SRC

**** Org Gcal :disabled:


The [[https://github.com/myuhe/org-gcal.el][org-gcal]] package provides org-mode integration with Google
Calendar.

#+NAME: org-taskmgr-gcal
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-gcal
    :init
  (require 'secrets)
  (require 'org-gcal)
  :custom
  (org-gcal-file-alist
   '(("jchaffin@g.ucla.edu" . "~/Dropbox/org/agenda/schedule.org")))
  :hook
  (org-agenda-mode . org-gcal-sync)
  (org-capture-after-finalize . org-gcal-sync))

#+END_SRC

**** Google maps

#+NAME: org-taskmgr-maps
#+BEGIN_SRC emacs-lisp :tangle no
(use-package google-maps)
#+END_SRC

**** calfw

#+NAME: org-taskmgr-calfw
#+BEGIN_SRC emacs-lisp :tangle no
(use-package calfw
  :custom
  (cfw:org-capture-template
     '("c" "calfw2org" entry
       (file "agenda/schedule.org")
       "*  %?
   %(cfw:org-capture-day)"))
  (cfw:render-line-breaker 'cfw:render-line-breaker-wordwrap)
  (cfw:display-calendar-holidays nil)
  (cfw:fchar-junction ?╋)    
  (cfw:fchar-vertical-line ?┃)          
  (cfw:fchar-horizontal-line ?━)          
  (cfw:fchar-left-junction ?┣)          
  (cfw:fchar-right-junction ?┫)          
  (cfw:fchar-top-junction ?┯)          
  (cfw:fchar-top-left-corner ?┏)          
  (cfw:fchar-top-right-corner ?┓)
    
  :hook
  (cfw:details-mode . org-link-minor-mode))

(use-package calfw-org
  :demand t
  :custom
  (cfw:org-capture-template
   '("c" "calfw2org" entry
     (file "agenda/schedule.org")
     "*  %?\n %(cfw:org-capture-day)"))
  :init
  (require 'calfw)
  (defun cfw:open-calendar ()
   (interactive)
   (let ((cp
          (cfw:create-calendar-component-buffer
           :view 'month
           :contents-sources
           (list
            (cfw:org-create-file-source
             "syntax" "~/Dropbox/courses/ling165b/TODOS.org" "#91E5DD")
            (cfw:org-create-file-source
             "phonetics" "~/Dropbox/courses/ling103/TODOs.org" "purple")
            (cfw:org-create-file-source
             "programming languages" "~/Dropbox/courses/cs131/TODOs.org" "tomato1")))))
     (switch-to-buffer (cfw:cp-get-buffer cp))))

  (define-key 'halidom/org-command-map (kbd "c") '(" Calendar" . cfw:open-calendar)))
#+END_SRC

**** Org Pomodoro
:PROPERTIES:
:ID:       3600535E-2C20-4E33-8572-E933319E87B3
:CUSTOM_ID: org-pomodoro
:END:

#+NAME: org-taskmgr-pomodoro
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-pomodoro
  :bind (:map org-mode-map
              ("C-c M-RET p" . org-pomodoro))
  :config
  (progn
    (defalias #'org-pomodoro-path
      (apply-partially #'emacs-dir "etc" "pomodoro"))

    (setq org-pomodoro-audio-player "/usr/bin/afplay"
          org-pomodoro-tick-sound
          (org-pomodoro-path "clock-ticking-2.wav")
          ;; Start Settings
          org-pomodoro-start-sound-p t ;; enable starting sound
          org-pomodoro-start-sound-args "--volume 0.08"
          org-pomodoro-start-sound
          (org-pomodoro-path "Victory.wav")
        ;; Finished Settings
          org-pomodoro-finished-sound-args "--volume 0.2"
          org-pomodoro-finished-sound
          (org-pomodoro-path "Waves.wav")
          ;; Short Break Settings
          org-pomodoro-short-break-length 5
          org-pomodoro-short-break-sound-args "--volume 0.2"
          org-pomodoro-short-break-sound org-pomodoro-finished-sound
          ;; Long Break Settings
          org-pomodoro-long-break-length 15
          org-pomodoro-long-break-sound-args "--volume 0.2"
          org-pomodoro-long-break-sound
          (org-pomodoro-path "Complete.wav"))))
#+END_SRC

**** Counsel Org Clock

#+NAME: org-taskmgr-coclock
#+BEGIN_SRC emacs-lisp :tangle no
(use-package counsel-org-clock
  :straight (:host github
                   :repo "akirak/counsel-org-clock")
  :after (:all org-agenda ivy))
#+END_SRC

**** Org Mru Clock

The [[https://github.com/unhammer/org-mru-clock][org-mru-clock]] package prefills clock history with clocks from
org agenda files.

#+NAME: org-taskmgr-mru-clock
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-mru-clock
  :after (:all org-agenda ivy)
  :demand t
  :bind (("C-c C-x i" . org-mru-clock-in)
         ("C-c C-x C-j" . org-mru-clock-select-recent-task))
  :init
  (progn
    (setq org-mru-clock-how-many 50
          org-mru-completing-read #'ivy-completing-read)))
#+END_SRC

Check out this [[http://mbork.pl/2018-04-28_org-mru-clock][article]] for how these two packages compare.[fn:11].

*** Concept Mapping
:PROPERTIES:
:ID:       0D754B3F-C800-409F-B8A2-140CB8EDD1E3
:CUSTOM_ID: sec:concept-mapping
:END:

#+NAME: org/concept
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
<<org-ideamgr-brain>>
<<org-ideamgr-drill>>
#+END_SRC

**** Org Brain

#+NAME: org-ideamgr-brain
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-brain
  :if *is-mac*
  :defines (org-brain-path)
  :init
  (setq org-brain-path (concat (file-name-as-directory org-directory) "brain"))
  :config
  (progn
    (setq org-id-track-globally t
          org-brain-visualize-default-choices 'all
          org-brain-title-max-length 12)
    (push '("b" "Brain" plain (function org-brain-goto-end)
            "* %i%?" :empty-lines 1)
          org-capture-templates)))
#+END_SRC

*** Org Hacks
:PROPERTIES:
:ID:       872F7F61-7971-42E4-BC24-FEA9D67634D2
:END:

#+NAME: org-hacks-spec
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin Org Hacks
;; Hidden cursor in folded subtree fix
<<org-hacks-saveplace-fix>>
;; Extract hyperlinks
<<org-hacks-extract-hyperlink>>
;; Dynamically adjust tag position
;; <<org-hacks-tag-pos>>
;; End Org Hacks
#+END_SRC

From Thomas Frössman's [[http://thomasf.github.io/solarized-css/test/org-hacks.html#sec-1-8-5][org hacks]]:

**** Reveal cursor in folded subtree.
:PROPERTIES:
:ID:       088BEAF5-B9FE-43F4-995D-5E26FB6DCB16
:END:

Fix problem with  which puts point back in a folded position.

#+NAME: org-hacks-saveplace-fix
#+BEGIN_SRC emacs-lisp :tangle no
(add-hook 'org-mode-hook
          (lambda ()
            (when (outline-invisible-p)
              (save-excursion
                (outline-previous-visible-heading 1)
                (org-show-subtree)))))
#+END_SRC

**** Hyperlink extraction

#+NAME: org-hacks-extract-hyperlink
#+BEGIN_SRC emacs-lisp :tangle no

  (defun org-extract-link ()
    "Extract the link location at point and put it on the killring."
    (interactive)
    (when (org-in-regexp org-bracket-link-regexp 1)
      (kill-new (org-link-unescape (org-match-string-no-properties 1)))))


  (defun browse-url-extract-org-link (orig-fun &rest args)
    "If `thing-at-point' is a org-link, then call `org-extract-link'
  and apply ORIG-FUN with the extracted url in the car of original ARGS."
    (when (and (eq major-mode 'org-mode)
               (string= (car (org-thing-at-point)) "link"))
      (setcar args (org-extract-link)))
    (apply orig-fun args))

    (advice-add 'osx-browse-url :around #'browse-url-extract-org-link)
#+END_SRC

**** Export to datetree :disabled:

#+NAME: org-hacks-datetree-export
#+BEGIN_SRC emacs-lisp :tangle no
(require 'org-datetree)

(setq org-archive-location "%s_archive::date-tree")
(defadvice org-archive-subtree
  (around org-archive-subtree-to-data-tree activate)
  "org-archive-subtree to date-tree"
  (if
      (string= "date-tree"
               (org-extract-archive-heading
                (org-get-local-archive-location)))
      (let* ((dct (decode-time (org-current-time)))
             (y (nth 5 dct))
             (m (nth 4 dct))
             (d (nth 3 dct))
             (this-buffer (current-buffer))
             (location (org-get-local-archive-location))
             (afile (org-extract-archive-file location))
             (org-archive-location
              (format "%s::*** %04d-%02d-%02d %s" afile y m d
                      (format-time-string "%A" (encode-time 0 0 0 d m y)))))
        (message "afile=%s" afile)
        (unless afile
          (error "Invalid `org-archive-location'"))
        (save-excursion
          (switch-to-buffer (find-file-noselect afile))
          (org-datetree-find-year-create y)
          (org-datetree-find-month-create y m)
          (org-datetree-find-day-create y m d)
          (widen)
          (switch-to-buffer this-buffer))
        ad-do-it)
    ad-do-it))


#+END_SRC

**** Dynamically set tag position :disabled:

#+NAME: org-hacks-tag-pos
#+BEGIN_SRC emacs-lisp :tangle no
  (setq ba/org-adjust-tags-column nil)

  (defun ba/org-adjust-tags-column-reset-tags ()
    "In org-mode buffers it will reset tag position according to
  `org-tags-column'."
    (when (and
           (not (string= (buffer-name) "*Remember*"))
           (eql major-mode 'org-mode))
      (let ((b-m-p (buffer-modified-p)))
        (condition-case nil
            (save-excursion
              (goto-char (point-min))
              (command-execute 'outline-next-visible-heading)
              ;; disable (message) that org-set-tags generates
              (cl-flet ((message (&rest ignored) nil))
              (org-set-tags 1 t))
              (set-buffer-modified-p b-m-p))
              (error nil)))))

  (defun ba/org-adjust-tags-column-now ()
    "Right-adjust `org-tags-column' value, then reset tag position."
    (set (make-local-variable 'org-tags-column)
         (- (- (window-width) (length org-ellipsis))))
    (ba/org-adjust-tags-column-reset-tags))

  (defun ba/org-adjust-tags-column-maybe ()
    "If `ba/org-adjust-tags-column' is set to non-nil, adjust tags."
    (when ba/org-adjust-tags-column
      (ba/org-adjust-tags-column-now)))

  (defun ba/org-adjust-tags-column-before-save ()
    "Tags need to be left-adjusted when saving."
    (when ba/org-adjust-tags-column
       (setq org-tags-column 1)
       (ba/org-adjust-tags-column-reset-tags)))

  (defun ba/org-adjust-tags-column-after-save ()
    "Revert left-adjusted tag position done by before-save hook."
    (ba/org-adjust-tags-column-maybe)
    (set-buffer-modified-p nil))

  ; automatically align tags on right-hand side
  (add-hook 'window-configuration-change-hook
            'ba/org-adjust-tags-column-maybe)
  (add-hook 'before-save-hook 'ba/org-adjust-tags-column-before-save)
  (add-hook 'after-save-hook 'ba/org-adjust-tags-column-after-save)
  (add-hook 'org-agenda-mode-hook '(lambda ()
                                    (setq org-agenda-tags-column (- (window-width)))))

  ; between invoking org-refile and displaying the prompt (which
  ; triggers window-configuration-change-hook) tags might adjust,
  ; which invalidates the org-refile cache
  (defadvice org-refile (around org-refile-disable-adjust-tags)
    "Disable dynamically adjusting tags"
    (let ((ba/org-adjust-tags-column nil))
      ad-do-it))
  (ad-activate 'org-refile)
#+END_SRC

*** Ox
:PROPERTIES:
:ID:       46A0BACE-34F1-4547-8EC4-367FD085E1B5
:CUSTOM_ID: sec:ox
:END:

#+NAME: org/ox
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Backends Interface
<<ox/backends>>
;; Enable Extras
<<ox/extra>>
;; Org Publish
<<ox/publish>>
;; ox org
<<ox/org>>
;; ox latex
(when (halidom/org-export-enabled-backend-p 'latex)
  <<ox/latex>>
)

;; ox linguistics
(when (halidom/org-export-enabled-backend-p 'linguistics)
  <<ox/linguistics>>
)

;; ox bibtex
(when (halidom/org-export-enabled-backend-p 'bibtex)
  <<ox/bibtex>>
)

;; ox gfm
(when (halidom/org-export-enabled-backend-p 'gfm)
  <<ox/gfm>>
)


;; ox pandoc
(when (halidom/org-export-enabled-backend-p 'pandoc)
  <<ox/pandoc>>
)

;; ox hugo
(when (halidom/org-export-enabled-backend-p 'hugo)
  <<ox/hugo>>
)

;; ox html
(when (halidom/org-export-enabled-backend-p 'html)
  <<ox/html>>
)

#+END_SRC

*** Ox Backends
:PROPERTIES:
:ID:       59AEA962-792E-4AB7-ACDE-3EC61C45D279
:CUSTOM_ID: sec:ox-backends
:END:

#+NAME: ox/backends
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; utilities
<<backends/utilities>>
;; enable by default
<<backends/default>>
#+END_SRC

**** Utilities for export backend

#+NAME: backends/utilities
#+BEGIN_SRC emacs-lisp :tangle no
(defvar org-export-enabled-backends '()
  "alist of symbols representing enabled `org-mode' export backends")

(defun halidom/org-export-enabled-backend-p (backend)
  (member backend org-export-enabled-backends))
#+END_SRC

And opt-in to all back ends when on local machine.

**** Enable By Default

#+NAME: backends/default
#+BEGIN_SRC emacs-lisp :tangle no
(when *is-mac*
  (mapcar (lambda (backend)
            (setq org-export-enabled-backends
                  (cons backend org-export-enabled-backends)))
          '(extra gfm latex hugo html pandoc linguistics)))
#+END_SRC

*** Ox Extra

Ignores headlines tagged =:ignore:=. Unlike =:noexport:=, the contents
and subtrees of the ignored headlines will be retained.

#+NAME: ox/extra
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ox-extra
  :straight org
  :demand t
  :config
  (ox-extras-activate '(ignore-headlines
                        org-export-filter-parse-tree-functions)))
#+END_SRC

*** Ox Publish

#+NAME: ox/publish
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ox-publish
  :straight org
  :after (ox)
  :demand t
  :bind (("M-m r p" . org-publish-project)))
#+END_SRC

*** Ox Org

#+NAME: ox/org
#+BEGIN_SRC emacs-lisp :tangle no
(defun org-to-org-handle-includes ()
  "Copy the contents of the current buffer to OUTFILE,
recursively processing #+INCLUDEs."
  (let* ((s (buffer-string))
     (fname (buffer-file-name))
     (ofname (format "%s.I.org" (file-name-sans-extension fname))))
    (setq result
      (with-temp-buffer
        (insert s)
        (org-export-handle-include-files-recurse)
        (buffer-string)))
    (find-file ofname)
    (delete-region (point-min) (point-max))
    (insert result)
    (save-buffer)))
#+END_SRC

*** Ox Latex
:PROPERTIES:
:CUSTOM_ID: sec:ox-latex
:END:

#+NAME: ox/latex
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
(require 'ox-latex)
;; Prefer user labels
<<oxl/labels>>
;; Subfigure 
<<oxl/subfigure>>
;; PDF Process Interface
<<oxl/pdf>>
;; Hyperref Template
<<oxl/hyperref>>
;; Custom classes
<<oxl/classes>>
#+END_SRC

**** Prefer user provided labeling

#+NAME: oxl/labels
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-latex-prefer-user-labels t)
#+END_SRC

**** Subfigure Export

#+NAME: oxl/subfigure
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ox-latex-subfigure
  :straight
  (ox-latex-subfigure
   :type git
   :host github
   :repo "linktohack/ox-latex-subfigure")
  :config
  (require 'ox-latex-subfigure)
  (add-to-list 'org-latex-packages-alist (("" "subcaption" nil))))

#+END_SRC

**** Minted

Allow toggling of minted inclusion in exported header. This might be necessary when using a custom latex class or loading minted manually.

#+NAME: oxl/minted
#+BEGIN_SRC emacs-lisp :tangle no
(eval-and-compile
  (defvar enable-default-minted nil))

(setq org-latex-listings 'minted)

(setq org-latex-packages-alist '(("" "booktabs" nil)))
(setq org-latex-minted-options
      '(("mathescape" "true")
        ("linenos" "true")
        ("breaklines" "true")
        ("numbersep" "5pt")
        ("frame" "lines")
        ("framesep" "2mm")))

(defun latex-toggle-default-minted ()
  (interactive)
  (if (not enable-default-minted)
      (progn
        (setq org-latex-packages-alist
              (append org-latex-packages-alist '(("newfloat" "minted"))))
        (setq enable-default-minted t)
        (message "%s" "Exporting with default minted."))
    (progn
      (setq enable-default-minted nil)
      (dolist (elt org-latex-packages-alist)
        (if (string= (cadr elt) "minted")
            (setq org-latex-packages-alist (remove elt org-latex-packages-alist))))
      (message "%s" "Disabled default minted."))))


#+END_SRC


**** Set latex pdf process

[[https://ctan.org/pkg/latexmk?lang=en][Latexmk]] automates the proces of building LaTeX documents to pdf.

It can be done through the =org-mode= latex export dispatcher in a single command:

#+NAME: oxl/pdf
#+BEGIN_SRC emacs-lisp :tangle no
(setq latex-process-latex
  '("%latex -interaction nonstopmode -output-directory %o %f"
    "%latex -interaction nonstopmode -output-directory %o %f"
    "%latex -interaction nonstopmode -output-directory %o %f"))

(setq latex-process-pdflatex
  '("latexmk -pdflatex='pdflatex -interaction=nonstopmode -shell-escape' -synctex=1 -pdf -bibtex -f %f"))

(setq latex-process-xelatex
  '("latexmk -pdf -synctex=1 -shell-escape -xelatex -f %f"))

(setq latex-process-lualatex
  '("latexmk -pdf -synctex=1 -shell-escape -lualatex -f %f"))

(defcustom halidom-latex-pdf-engines
  '(("latex" . latex-process-latex)
    ("lualatex" . latex-process-lualatex)
    ("xelatex" . latex-process-xelatex)
    ("pdflatex" . latex-process-pdflatex))
  "A list of LaTeX commands available to run when
`org-latex-export-to-pdf' is invoked."
  :type '(cons string symbol))

(setq org-latex-pdf-process latex-process-xelatex)

(defvar org-latex-pdf-process-set-hook nil)

(defun org-latex-pdf-process-set (&optional process)
  (interactive)
  (let* ((process (or
                   process
                   (assoc (completing-read "Process: " halidom-latex-pdf-engines nil nil)
                          halidom-latex-pdf-engines)))
         (cmd-string (cdr process)))
    (setq org-latex-pdf-process (symbol-value cmd-string))
    (setq org-latex-compiler (car process))
    (run-hooks 'org-latex-pdf-process-set-hook)))


(add-hook 'org-mode-hook
          (lambda () (local-set-key (kbd "M-s l") 'org-latex-pdf-process-set)))


#+END_SRC

**** Hyperref Template

The default cross-referencing and hyperlink styles provided by
=hyperref= are awful. This makes them less awful.

#+NAME: oxl/hyperref
#+BEGIN_SRC emacs-lisp :tangle no
  (setq org-latex-hyperref-template
        (concat "\\hypersetup{\n"
                " colorlinks=true,"
                " urlcolor=black"
                " linkcolor=black"
                "\n}"))
#+END_SRC

**** Export classes

#+NAME: oxl/classes
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Org Ling
<<ox-class/orgling>>
;; UCLA CS
<<ox-class/uclacs>>
;; Humanities
<<ox-class/humanities>>
;; Article No Default Packages
<<ox-class/article-standalone>>
;; Unicode math
<<ox-class/unicode-math>>
#+END_SRC

***** Article no default packages

#+NAME: ox-class/article-standalone
#+BEGIN_SRC emacs-lisp :tangle no
(add-to-list 'org-latex-classes
	     '("article-standalone"
	       "\\documentclass{article}
          [NO-DEFAULT-PACKAGES]
          [PACKAGES]
          [EXTRA]" ;; header-string
	       ("\\section{%s}" . "\\section*{%s}")
	       ("\\subsection{%s}" . "\\subsection*a{%s}")
	       ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
	       ("\\paragraph{%s}" . "\\paragraph*{%s}")
	       ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC

***** Orgling

#+NAME: ox-class/orgling
#+BEGIN_SRC emacs-lisp :tangle no
(if (and (executable-find "kpsewhich")
         (shell-command-to-string "kpsewhich orgling.cls"))

    (add-to-list 'org-latex-classes
                 '("orgling"
                   "\\documentclass{orgling}
                    [NO-DEFAULT-PACKAGES]
                    [EXTRA]"
                   ("\\section{%s}" . "\\section*{%s}")
                   ("\\subsection{%s}" . "\\subsection*{%s}")
                   ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                   ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+END_SRC

***** UCLA CS

#+NAME: ox-class/uclacs
#+BEGIN_SRC emacs-lisp :tangle no
(add-to-list 'org-latex-classes
             '("uclacs"
               "\\documentclass{uclacs}
                [NO-DEFAULT-PACKAGES]
                [EXTRA]"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC

***** Humanities

My custom mla-style LaTeX class.

#+NAME: ox-class/humanities
#+BEGIN_SRC emacs-lisp :tangle no
(add-to-list 'org-latex-classes
             '("humanities"
               "\\documentclass{humanities}
                [NO-DEFAULT-PACKAGES]
                [EXTRA]"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC

***** Unicode Math

#+NAME: ox-class/unicode-math
#+BEGIN_SRC emacs-lisp :tangle no
  (add-to-list 'org-latex-classes
    '("unicode-math"
      "\\documentclass{article}
       [PACKAGES]
       [NO-DEFAULT-PACKAGES]
       [EXTRA]
       \\usepackage{fontspec}
       \\usepackage{amsmath}
       \\usepackage{xltxtra}
       \\usepackage{unicode-math}
       \\setmathfont{STIX2Math}[
         Path/Users/jacobchaffin/Library/Fonts/,
         Extension={.otf},
         Scale=1]
       \\setmainfont{STIX2Text}[
         Path/Users/jacobchaffin/Library/Fonts/,
         Extension={.otf},
         UprightFont={*-Regular},
         BoldFont={*-Bold},
         ItalicFont={*-Italic},
         BoldItalicFont={*-BoldItalic}]"
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
      ("\\paragraph{%s}" . "\\paragraph*{%s}")
      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+END_SRC

*** Ox Linguistics

#+NAME: ox/linguistics
#+BEGIN_SRC emacs-lisp :tangle no

(use-package ox-linguistics
    :straight (ox-linguistics
               :host github
               :repo "wyleyr/ox-linguistics"
               :files ("lisp/*.el"))
    :after (ox-latex)
    :init
    (require 'ox-linguistics)
    :demand t)

#+END_SRC

*** Ox Bibtex

#+NAME: ox/bibtex
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
(use-package ox-bibtex
  :straight org
  :mode
  (("\\.org.bib\\'" . org-mode))
  :after (ox)
  :demand t
  :config
  (progn
    (require 'org-bibtex)
    (setq org-bibtex-file "references.org")))
#+END_SRC

*** Ox Pandoc

[[https://pandoc.org/][Pandoc]] is a document conversion tool that can convert pretty much
anything. The [[https://github.com/kawabata/ox-pandoc][ox-pandoc]] package allows us to utiliize this capability
for exporting org-mode documents to various formats.

#+NAME: ox/pandoc
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ox-pandoc
  :if (executable-find "pandoc")
  :after (:all ox org-ref)
  :custom

  (org-pandoc-options '((standalone . t)))

  :demand t
  :config
  (progn

    ;; LaTeX-Beamer-PDF
    (defun ox-pandoc--pdf-engine ()
      "Set the default latex pdf engine to the one set by `org-latex-pdf-process'. "
      (let ((syms (mapcar (lambda (x) (cdr x)) halidom-latex-pdf-engines))
            (pred (lambda (sym) (eq (symbol-value sym) org-latex-pdf-process)))
            (sep "latex-process-"))
        (cadr (split-string (symbol-name (car (seq-filter pred syms))) sep))))

    (setq org-pandoc-options-for-beamer-pdf
          `((pdf-engine . ,(ox-pandoc--pdf-engine)))
          org-pandoc-options-for-latex-pdf
          `((pdf-engine . ,(ox-pandoc--pdf-engine))))

    (defun org-pandoc-pdf-engine-set (&optional process)
      "Set the latex pdf engine for `org-pandoc-export-to-latex-pdf'."
      (interactive)
      (let* ((process (or process
                          (assoc
                           (completing-read "Pandoc Process: "
                                            halidom-latex-pdf-engines nil nil)
                           halidom-latex-pdf-engines)))
             (sym (substring-no-properties (car process))))
        (setq org-pandoc-options-for-beamer-pdf
              `((pdf-engine . ,sym))
              org-pandoc-options-for-latex-pdf
              `((pdf-engine . ,sym)))))

    ;; Open MS .doc?x files with system viewer.
    (when (symbolp 'org-file-apps)
      (add-to-list 'org-file-apps '("\\.docx?\\'" . system)))))
#+END_SRC

*** Ox GFM

#+NAME: ox/gfm
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ox-gfm
  :after (ox)
  :demand t)
#+END_SRC

*** Ox Hugo

[[https://ox-hugo.scripter.co/][ox-hugo]] is an org exporter for Hugo-compatible markdown.

#+NAME: ox/hugo
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ox-hugo
  :after (ox))
#+END_SRC

*** Ox HTML

#+NAME: ox/html
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-html-themes
    :straight
    (org-html-themes
      :host github
      :repo "fniessen/org-html-themes"
      :local-repo-name org-html-themes
      :files ("setup/*" "styles/*")))
#+END_SRC

** Org Latex

#+NAME: orgtex/org-latex
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; LateX editing
<<org-latex-editing>>
;; Org Ref
<<org-latex-org-ref>>
;; Org Latex PDF
<<org-latex-pdf>>
;; Org highlight latex and related
<<org-latex-highlight-tex>>
#+END_SRC

*** LaTeX in Org Buffers

#+NAME: org-latex-editing
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Org Edit Latex
<<org-latex-edit-latex>>
;; Org Highlight LaTeX
<<org-latex-highlight-tex>>
#+END_SRC

*** Edit Latex

#+NAME: org-latex-edit-latex
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-edit-latex)
#+END_SRC

*** Highlight inline LaTeX fragments
:PROPERTIES:
:ID:       8E0531C6-0E85-4F0A-9340-2868F54F3A6D
:END:

#+NAME: org-latex-highlight-tex
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-highlight-latex-and-related '(latex))
#+END_SRC

*** Org Ref
:PROPERTIES:
:ID:       1038C1B0-F5E1-4246-A360-B29BFBA82AC2
:CUSTOM_ID: org-ref
:END:

#+NAME: org-latex-org-ref
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Org Ref
<<org-ref-config>>
(with-eval-after-load 'org-ref
  ;; Org ref vref
  <<org-ref-vref>>
  ;; Org ref pdf
  <<org-ref-pdf>>
)
#+END_SRC

#+NAME: org-ref-config
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-ref
    :after ivy
    :demand t
    :custom

    (org-ref-completion-library 'org-ref-ivy-cite)
    (org-ref-default-bibliography
     (list (dropbox-dir "org" "ref" "references.bib")))
    (org-ref-bibliography-notes
     (dropbox-dir "org" "ref" "refnotes.org"))
    (org-ref-pdf-directory
     (dropbox-dir "org" "papers" "pdfs"))
    (org-ref-show-citation-on-enter t)
    (org-ref-show-broken-links t)
    (org-ref-bibtex-hydra-key-binding "\C-cj")

    :init
    ;; https://github.com/jkitchin/org-ref/issues/428
    (progn
      (require 'doi-utils)
      (require 'org-ref-url-utils)
      (require 'org-id)
      (require 'org-ref-latex)
      (require 'org-ref-bibtex)
      (require 'org-ref-pdf)
      (require 'org-ref-scopus)
      (require 'org-ref-isbn)
      (require 'org-ref-pubmed)
      (require 'org-ref-arxiv)
      (require 'org-ref-sci-id)
      (require 'org-ref-wos)
      (require 'org-ref-worldcat)
      (require 'x2bib))

    :config
    (defun goto-org-ref-manual (&optional path)
      (interactive)
      (if-not path
          (setq path (emacs-dir "straight" "repos" "org-ref" "org-ref.org")))
      (find-file path))


    ;; Hydra
    ;; See [[file:straight/repos/org-ref/org-ref.org::#citations][Citations]] section of the manual
    (key-chord-define-global "kk" 'org-ref-cite-hydra/body)

    ;; Org Ref Bibtex Interface
    (defcustom halidom-org-ref-journal-abbrevs '()
      "Extra abbreviations to add to `org-ref-bibtex-journal-abbreviations.'
  Each abbreviation is a list of the form (string journal-abbreviation journal-full-name)."
      :type '(alist :value-type (group string)))


    (setq journal-abbrevs-extra
          '(("CST" "The Handbook of Contemporary Syntactic Theory" )))

    (setq halidom-org-ref-journal-abbrevs
          (seq-concatenate 'list
                           halidom-org-ref-journal-abbrevs
                           journal-abbrevs-extra))



    (with-eval-after-load 'org-ref
      (dolist (elt halidom-org-ref-journal-abbrevs)
        (add-to-list 'org-ref-bibtex-journal-abbreviations elt))))

#+END_SRC

**** Support =vref= links

#+NAME: org-ref-vref
#+BEGIN_SRC emacs-lisp :tangle no
(defun org-ref-vref-export (keyword desc format)
  "An export function for vref links."
  (cond
   ((eq format 'html)
    (format "<a href=\"#%s\">%s</a>" keyword (or desc keyword)))
   ((eq format 'latex) (format "\\vref{%s}" keyword))))


(org-ref-link-set-parameters "vref"
   :follow #'org-ref-ref-follow
   :export #'org-ref-vref-export
   :complete #'org-ref-complete-link
   :face 'org-ref-ref-face-fn
   :help-echo #'org-ref-ref-help-echo)

(setq org-ref-ref-types '("ref" "eqref" "pageref" "nameref"
                          "autoref" "cref" "Cref" "vref"))

#+END_SRC

**** Open Pdf at point

See [[https://github.com/jkitchin/org-ref/blob/master/org-ref.org#using-doc-view-or-pdf-tools][Using Doc View or PDF Tools]] section of =org-ref= documentation.

#+NAME: org-ref-pdf
#+BEGIN_SRC emacs-lisp :tangle no
(defun org-ref-open-pdf-at-point ()
  "Open the pdf for bibtex key under point if it exists."
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file))
         (key (car results))
         (pdf-file (funcall org-ref-get-pdf-filename-function key)))
    (if (file-exists-p pdf-file)
        (find-file pdf-file)
      (message "No PDF found for %s" key))))

(setq org-ref-open-pdf-function 'org-ref-open-pdf-at-point)
#+END_SRC

*** Org PDF

#+NAME: org-latex-pdf
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
(when (display-graphic-p)
  <<org-pdf-pdftools>>
  <<org-pdf-pdfview>>
)
#+END_SRC

**** PDF Tools

[[https://github.com/politza/pdf-tools][PDF Tools]] adds several features and enhancements for interacting with
PDF documents in Emacs. It serves as a replacement for DocView mode.

Credits to Dr. Ben Maughan over at Pragmatic Emacs for this
[[http://pragmaticemacs.com/category/emacs/][blogpost]] demonstrating how to get the most out of this package.

#+NAME: org-pdf-pdftools
#+BEGIN_SRC emacs-lisp :tangle no
(use-package pdf-tools
  :mode (("\\.pdf\\'" . pdf-view-mode))
  :bind (:map pdf-view-mode-map
              ("C-s" . isearch-forward)
              ("h"   . pdf-annot-add-highlight-markup-annotation)
              ("t"   . pdf-annot-add-text-annotation)
              ("D"   . pdf-annot-delete))
  :init
  (pdf-tools-install)
  :config
  (progn
    (setq-default pdf-view-display-size 'fit-page)
    (setq pdf-annot-activate-created-annotations t)
    (setq pdf-view-resize-factor 1.1)))
#+END_SRC

**** Org PDF View

Now we can open pdf files with =org-pdfview= [fn:12]:

#+NAME: org-pdf-pdfview
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-pdfview
  :after (:all pdf-tools)
  :demand t
  :config
  (progn
    (add-hook 'org-mode-hook
              (lambda ()
                (add-to-list 'org-file-apps
                             '("\\.pdf\\'" .
                               (lambda (file link)
                                 (org-pdfview-open link))))))))
#+END_SRC

* Customizing Emacs
** Project Management
*** Projectile

#+NAME: project-projectile
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package projectile
  :bind-keymap
  ("C-c p" . projectile-command-map)
  :custom
  (projectile-completion-system 'ivy)
  (projectile-switch-project-action #'projectile-dired)
  (projectile-find-dir-includes-top-level t)
  (projectile-indexing-method 'turbo-alien)
  (projectile-enable-caching t)

  :init
  (el-patch-feature projectile)

  (el-patch-defun projectile-run-compilation (cmd)
    "Run external or Elisp compilation command CMD."
    (if (functionp cmd)
        (funcall cmd)
      (compile cmd (el-patch-add t))))

  :config

  ;; Which Key integration
  (which-key-add-key-based-replacements "C-c p" " Projectile")

  (push '((nil . "projectile-\\(.+\\)") . (nil . "\\1"))
        which-key-replacement-alist)

  (setq projectile-globally-ignored-directories
        (append projectile-globally-ignored-directories
                '("gradle" "target" ".meghanada"
                  ".gradle" "build" "bin" "node_modules"
                  "ltximg" "CMakeFiles" ".cquery_cached_index")))

  (defvar halidom/ignored-project-directories
    '("~/.emacs.d/straight"))

  (defun projectile-ignore-projects-in-directory (project-root)
    "Ignore directories in `halidom/ignored-project-directories'."
    (cl-flet ((ignored-dir-or-subdir-p
               (path)
               (f-descendant-of?
                (f-expand project-root)
                path)))
      (->> halidom/ignored-project-directories
         (seq-filter #'ignored-dir-or-subdir-p)
         seq-empty-p not)))

  (setq projectile-ignored-project-function
        #'projectile-ignore-projects-in-directory))
#+END_SRC

**** Projectile Codesearch

#+NAME: project-codesearch
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile-codesearch
      :after (projectile)
      :bind (:map projectile-command-map
                  ("s c" . projectile-codesearch-search)))
#+END_SRC

**** Projectile Ripgrep

#+NAME: project-ripgrep
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package projectile-ripgrep
      :after (projectile)
      ;; takes a cons in the form of `(binary . package-name)`
      :ensure-system-package (rg . ripgrep))

#+END_SRC

*** Skeletor

#+NAME: skeletor-spec
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package skeletor
    :custom
    (skeletor-user-directory (emacs-etc-dir "skeletons"))
    (skeletor-completing-read-function 'ivy-completing-read)
    (skeletor-python-bin-search-path
     '("/usr/local/bin" "/usr/bin"))
    (skeletor-project-directory (projects-dir))

    :init
    (defun skeletor-add-pyenv-pythons ()
      "Add python binaries managed by pyenv to
   `skeletor-python-bin-search-path'."
      (let* ((pyenv-dir (or (getenv "PYENV_ROOT")
                           (user-home ".pyenv")))
             (pyenv-version-dir
              (and pyenv-dir (resolve-path pyenv-dir "versions")))
             (pyenv-versions
              (directory-files-no-wildcards pyenv-version-dir t))
             (python-bins
              (mapcar
               (lambda (d)
                 (resolve-path d "bin"))
               pyenv-versions)))
        (dolist (python-bin python-bins)
          (add-to-list 'skeletor-python-bin-search-path
                       python-bin))))

    (skeletor-add-pyenv-pythons)


    :config
    (add-to-list 'skeletor-global-substitutions
                 (cons "__TIME__"
                       (lambda () (format-time-string "%c"))))

    (skeletor-define-template "cmake-unix-makefiles"
      :requires-executables
      '(("cmake". "https://cmake.org")
        ("make" . "https://www.gnu.org/software/make"))

      :substitutions
      (list
       (cons "__DESCRIPTION__"
             (lambda ()
               (read-string "Description: ")))
       (cons "__TARGET_NAME__"
             (lambda ()
               (read-string "Target: ")))
       (cons "__PROJECT-VARS__" ".dir-locals"))

      :after-creation
      (lambda (dir)
        (skeletor-async-shell-command "mkdir build")
        (skeletor-async-shell-command
         (concat "("
                 " cd build &&"
                 " cmake -G 'Unix Makefiles'"
                 " -DCMAKE_EXPORT_COMPILE_COMMANDS=ON .. "
                 ")"))
        (skeletor-async-shell-command
         "ln -s `pwd`/build/compile_commands.json .")
        (dired dir)
        (revert-buffer)))



    (defun skeletor/lsp-blacklist ()
      (with-eval-after-load 'lsp
        (add-to-list
         'lsp-project-blacklist
         skeletor--directory)))

    (defun skeletor/projectile-ignore ()
      (with-eval-after-load 'projectile
        (add-to-list
         'projectile-project-ignored-directories
         skeletor--directory)))

    :hook
    (lsp-mode . skeletor/lsp-blacklist)
    (project-mode .skeletor/projectile-ignore))

#+END_SRC

**** Projectile Code Search

#+NAME: project-code-search
#+BEGIN_SRC emacs-lisp :tangle no
(use-package projectile-codesearch)
#+END_SRC

*** Find File in Project

#+NAME: project-ffip
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package find-file-in-project)
#+END_SRC

** File System
*** Dired
**** Asynchronous Processing

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package async
  :after dired
  :commands (dired-async-mode async-smtpmail-send-it)
  :init
  (with-eval-after-load 'async
    (require 'smtpmail-async)
    (setq message-send-mail-function 'async-smtpmail-send-it)
    (dired-async-mode 1)))
#+END_SRC

**** Reuse dired buffer when moving to parent directory

From [[https://www.emacswiki.org/emacs/DiredReuseDirectoryBuffer][emacswiki.org]]

#+BEGIN_QUOTE
When moving to parent directory by `^´, Dired by default creates a new
buffer for each movement up. The following rebinds `^´ to use the same
buffer.
#+END_QUOTE


#+BEGIN_SRC emacs-lisp :tangle yes
(defun halidom/dired-reuse-buffer-hook ()
	(define-key dired-mode-map (kbd "^")
	  (lambda () (interactive) (find-alternate-file ".."))))
#+END_SRC

**** Use other dired buffer as default directory

When split frames with two dired buffers, defaut to the other buffer
as the current directory.

See docstring for =dired-dwim-target=.

#+BEGIN_SRC emacs-lisp :tangle yes
(setq dired-dwim-target t)
#+END_SRC

**** Dired+

Adds extensions and functionality to dired mode.

#+NAME: dired-plus-config
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package dired+
  :init
  (add-hook #'dired-mode-hook #'dired-hide-details-mode))
#+END_SRC

**** Open org directory links with dired


#+BEGIN_SRC emacs-lisp :tangle yes
(when (symbolp 'org-file-apps)
  (add-to-list 'org-file-apps '(directory . emacs)))
#+END_SRC

*** Neotree

[[https://github.com/jaypei/emacs-neotree][Neotree]][fn:13] is a [[https://github.com/scrooloose/nerdtree][Nerdtree]]-like file explorer for managing projects in Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package neotree
  :after (projectile)
  :demand t
  :commands (neotree-project-dir)
  :bind
  (([f8] . neotree-project-dir))
  :custom
  (neo-theme (if (display-graphic-p) 'icons 'arrow))
  (neo-smart-open t)
  :config
  (progn
    ;; @source https://www.emacswiki.org/emacs/NeoTree
    (defun neotree-project-dir ()
      "Open NeoTree using the git root"
      (interactive)
      (let ((project-dir (projectile-project-root))
            (file-name (buffer-file-name)))
        (neotree-toggle)
        (if project-dir
            (if (neo-global--window-exists-p)
                 (progn
                   (neotree-dir project-dir)
                   (neotree-find file-name)))
          (message "Project root not found."))))))
#+END_SRC

*** Treemacs

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package treemacs)
#+END_SRC

*** Speedbar

#+NAME: speed-sr
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package sr-speedbar)
#+END_SRC

#+NAME: projectile-speedbar
#+BEGIN_SRC emacs-lisp :tangle no
(use-package projectile-speedbar
    :bind ("M-<f2>" . projectile-speedbar-open-current-buffer-in-tree))
#+END_SRC

** Search
*** Codesearch

#+NAME: search/codesearch
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package codesearch)
#+END_SRC

*** Avy
Jump to arbitrary point in Buffer

#+NAME: search/avy
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package avy
    :bind
    ("C-:" . avy-goto-char))
#+END_SRC

*** ack

#+NAME: search/ack
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ack
  :if (executable-find "ack")
  :straight t)
#+END_SRC

*** ag

#+NAME: ag-config
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ag)
#+END_SRC

*** grep+

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package grep+)

#+END_SRC

***** Open With

#+NAME: open-with-spec
#+BEGIN_SRC emacs-lisp :tangle no
(use-package openwith
  :straight t)
#+END_SRC

***** Dired Sidebar

#+NAME: dired-sidebar-config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired-sidebar
      :commands (dired-sidebar-toggle-sidebar)
      :custom
      (dired-sidebar-should-follow-file nil)
      (dired-sidebar-theme 'none)
      :init
      :bind
      ("C-c d" . dired-sidebar-toggle-sidebar))
#+END_SRC

*** rg

#+NAME: ripgrep
#+BEGIN_SRC emacs-lisp :tangle no
(use-package rg
  :ensure-system-package
  (rg . ripgrep))

#+END_SRC

*** Visual Replace

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package visual-regexp
    :bind
    (("C-c r" . vr/replace)
     ("C-c q" . vr/query-replace)
     ("C-c m" . vr/mc-mark)))
#+END_SRC

*** Undo Tree

Visualize buffer modifications during an Emacs session as an
interactive tree .

#+NAME: search/undo-tree
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package undo-tree
  :init
  (global-undo-tree-mode))
#+END_SRC

** Startup

#+NAME: startup-spec
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;;; Begin Startup Group
;; startup buffer
<<startup-buffer>>
;; startup scratch and message
<<startup-scratch>>
;; startup frame
<<startup-frame>>
;;; End Startup Group
#+END_SRC

*** Buffer

#+NAME: startup-buffer
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Page break lines
<<buffer/page-break-lines>>
;; Emacs dashboard
<<buffer/dashboard>>
;; Autorevert
<<buffer/revert>>
;; Fireplace
<<buffer/fireplace>>
#+END_SRC

The default splash screen is great when you're starting out,
but it's more so an annoyance than anything else once you
know you're around.

**** Page Break Lines

Global minor-mode that turns ~^L~ form feed characters into
horizontal line rules.

#+NAME: buffer/page-break-lines
#+BEGIN_SRC emacs-lisp :tangle no
(use-package page-break-lines
  :init
  (global-page-break-lines-mode))
#+END_SRC

**** Emacs Dashboard

[[https://github.com/rakanalh/emacs-dashboard][Dashboard]] is a highly customizable splash screen
replacement library used in the popular [[https://github.com/syl20bnr/spacemacs][spacemacs]] framework.
It's a nice way of consolidating any combination of tasks,
agenda items, bookmarks, and pretty much any other enumerable
list that one may use in the wacky world of Emacs.

#+NAME: buffer/dashboard
#+BEGIN_SRC emacs-lisp :tangle no
(use-package dashboard
  :init
  (defun halidom/dashboard-banner ()
      "Set a dashboard banner including information on
  package initialization time and garbage collections."
      (setq dashboard-banner-logo-title
            (format
             (concat "Emacs ready in %.2f seconds "
                       "with %d garbage collections.")
             (float-time (time-subtract
                          after-init-time
                          before-init-time))
             gcs-done)))


    (unless global-page-break-lines-mode
      (global-page-break-lines-mode))

    (dashboard-setup-startup-hook)

    :config
    ;; (defun goto-dashboard ()
    ;;   "Switch to the *dashboard* buffe"
    ;;   (interactive)
    ;;   (if (seq-contains
    ;;        (mapcar #'buffer-name (buffer-list))
    ;;        "*dashboard*")
    ;;       (switch-to-buffer "*dashboard*")))

    ;; (define-key goto-map "d" #'goto-dashboard)

    (add-to-list 'dashboard-items '(agenda) t)
    ;; Get the week agenda.
    ;; See `dashboard-get-agenda' for how this
    ;; variable is being used.
    (setq show-week-agenda-p t)

    (setq dashboard-items '(( agenda . 10)
                            ( projects . 5)
                            ( recents . 3)
                            ( bookmarks . 5)))

    (defun dashboard/refresh ()
      (dashboard-refresh-buffer)
      (setq initial-buffer-choice (lambda () (or (get-buffer "*dashboard*") nil))))

    :hook
    (after-init     . dashboard/refresh)
    (dashboard-mode . halidom/dashboard-banner))


#+END_SRC

**** Auto Revert Mode

#+NAME: buffer/revert
#+BEGIN_SRC emacs-lisp :tangle no
(use-package autorevert
  :straight nil
  :config
  (global-auto-revert-mode 1))

#+END_SRC

**** Fireplace

Just for the hell of it.
#+NAME: fireplace-spec
#+BEGIN_SRC emacs-lisp :tangle no
(use-package fireplace
  :straight t)
#+END_SRC

*** Inhibit stuff

#+NAME: startup-scratch
#+BEGIN_SRC emacs-lisp :tangle no
  (setq initial-scratch-message nil
        inhibit-startup-message t
        inhibit-startup-echo-area-message t
        inhibit-startup-screen t)
  #+END_SRC

*** Frame

#+NAME: startup-frame
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Disable toolbar and scrollbar
<<frame-tool-and-scroll>>
;; Disable menubar unless system is macOS.
<<frame-menubar>>
;; Display Time
<<frame-time>>
;; Transpose frame
<<frame-transpose>>
#+END_SRC

**** Disable Frame peripherals

Disable scroll bars and tool bar on all system types.

***** Frame and Scrollbar

#+NAME: frame-tool-and-scroll
#+BEGIN_SRC emacs-lisp :tangle no
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+END_SRC

***** Menubar

On macOS, the menu bar is integrated into the UI.

Disabling it will just empty the menu tab options for Emacs.app,
so we'll leave it there.

#+NAME: frame-menubar
#+BEGIN_SRC emacs-lisp :tangle no
(unless *is-mac*
  (menu-bar-mode -1))
#+END_SRC

**** Display Time

#+NAME: frame-time
#+BEGIN_SRC emacs-lisp :tangle no
(display-time-mode 1)
#+END_SRC

**** Default Frame Appearance

Starting in Emacs 26, the =default-frame-alist= variable can be used
create a natural title bar in the GUI. Setting the default frame
properties to the following values has the same effect as the
'--with-natural-title-bar' option provided by the Homebrew [[https://github.com/d12frosted/homebrew-emacs-plus/blob/master/Formula/emacs-plus.rb#L97-L100][formula]]
recommended for Spacemacs users on macOS[fn:14].

#+BEGIN_SRC emacs-lisp :tangle yes
(setq default-frame-alist
      '((ns-transparent-titlebar . t)
        (ns-appearance . dark)))
#+END_SRC

**** Transpose Frame

#+NAME: frame-transpose
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package transpose-frame)
#+END_SRC

*** Window Manager

**** Window Resize

Default keybindings for window resize:

- =C-x ^= :: makes current window taller [[help:enlarge-window][`enlarge-window']]
- =C-x }= :: make it larger [[help:enlarge-window-horizontally][`enlarge-window-horizontally']]
- =C-x {= :: make it narrower [[help:shrink-window-horizontally][`shrin-window-horizontally']]

This following block modifies the keybindings for these commands to
use the arrow keys instead. I use the "C-s" modifier because it just
so happens this prefix can be extended by every key in the arrow pad
without causing a conflict with external keymaps on my system.

The suggested keybindings from the footnoted EmacsWiki page may be more
accessible for you [fn:15].

#+NAME: window-resize-keybindings
#+BEGIN_SRC emacs-lisp :tangle yes
(global-set-key (kbd "C-s-<left>") 'shrink-window-horizontally)
(global-set-key (kbd "C-s-<right>") 'enlarge-window-horizontally)
(global-set-key (kbd "C-s-<down>") 'shrink-window)
(global-set-key (kbd "C-s-<up>") 'enlarge-window)
#+END_SRC

**** Winner Mode

[[https://www.emacswiki.org/emacs/WinnerMode][Winner mode]] is a global minor mode that allows easy switching across
different window configurations.

#+NAME: winner-mode-config
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package winner-mode
  :straight nil
  :init
  (when (fboundp 'winner-mode)
    (winner-mode 1)))
#+END_SRC

**** Ace Window

#+NAME: window/ace
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package ace-window
      :bind 
      ("M-o" . ace-window)
      :custom
      (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
      (aw-background nil))

#+END_SRC

**** Popwin

#+NAME: popwin-config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package popwin
    :defines popwin:keymap
    :bind-keymap ("C-z" . popwin:keymap)
    :init
    (require 'popwin)
    :config
    (popwin-mode 1))
#+END_SRC

**** Poporg

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package poporg
      :bind (("C-c /" . poporg-dwim)))
#+END_SRC

**** Golden Ratio

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package golden-ratio
  :init
  (setq golden-ratio-auto-scale t))
#+END_SRC

**** Purpose

#+NAME: purpose
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package window-purpose)

  (use-package ivy-purpose
      :custom (pop-up-frames nil)
      :after (window-purpose)
      :init
      (ivy-purpose-setup)
      :config
      ;; give help buffers the 'popup-frame purpose
      (add-to-list 'purpose-user-mode-purposes
                  '(help-mode . popup-frame))
      (add-to-list 'purpose-special-action-sequences
                   '(popup-frame
                     purpose-display-reuse-window-buffer
                     purpose-display-reuse-window-purpose
                     purpose-display-pop-up-frame)))
#+END_SRC

**** Perspective

#+NAME: persp-spec
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Perspective
<<persp/perspective>>
;: Persp Projectile
<<persp/projectile>>
#+END_SRC


#+NAME: persp/perspective
#+BEGIN_SRC emacs-lisp :tangle no
(use-package perspective)
#+END_SRC

***** Persp Projectile

#+NAME: persp/projectile
#+BEGIN_SRC emacs-lisp :tangle no
(use-package persp-projectile
  :after (:all projectile counsel-projectile perspective)
  :bind ((:map projectile-mode-map
               ("s-S" . projectile-persp-switch-project))))
#+END_SRC



**** Copy and Paste

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package mark-forward-sexp
  :bind (("C-c o" . mark-forward-sexp)
         ("C-c O" . mark-backward-sexp)
         ("C-c i" . mark-inside-forward-sexp)
         ("C-c I" . mark-inside-backwad-sexp)))
#+END_SRC

** Emacs+
*** Help+

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package help+
    :demand t)

(use-package help-macro+
    :demand t)

(use-package help-fns+
    :demand t)

(use-package help-mode+
    :demand t)
#+END_SRC

*** Helpful

#+NAME: help-helpful
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package helpful
    :commands (helpful-at-point helpful-function helpful-command)
    :after hydra
    :init
    (defhydra 'helpful (global-map "M-m h")
        "Helpful"
        ("d" helpful-at-point)
        ("f" helpful-function)
        ("c" helpful-command))

    (which-key-add-key-based-replacements
        "M-m h" "helpful"))
#+END_SRC

**** Image+

[[https://github.com/mhayashi1120/Emacs-imagex][Image+]] provides extensions for image file manipulation in Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package image+
    :if (display-graphic-p)
    :after (image)
    :config
    (eval-after-load 'image+
      `(when (require 'hydra nil t)
         (defhydra imagex-sticky-binding (global-map "C-x C-l")
           "Manipulating image"
           ("+" imagex-sticky-zoom-in "zoom in")
           ("-" imagex-sticky-zoom-out "zoom out")
           ("M" imagex-sticky-maximize "maximize")
           ("O" imagex-sticky-restore-original "restore orginal")
           ("S" imagex-sticky-save-image "save file")
           ("r" imagex-sticky-rotate-right "rotate right")
           ("l" imagex-sticky-rotate-left "rotate left")))))
#+END_SRC

**** blimp :disabled:

#+NAME: image/blimp
#+BEGIN_SRC emacs-lisp :tangle no
(use-package blimp)
#+END_SRC

**** Info+

#+NAME: info=plus
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package info+
  :straight t)
#+END_SRC

**** FontLock+

#+NAME: font-lock-plus
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package font-lock+)

#+END_SRC

**** Color+

****** Rainbow Mode

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-mode)
#+END_SRC

****** Col Highlight

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package col-highlight)
#+END_SRC

*** Frame+

#+NAME: frame-plus
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package frame+)
#+END_SRC

*** Frame-fns

#+NAME: frame-fns-config
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package frame-fns)
#+END_SRC

*** posframe

#+NAME: posframe-spec
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package posframe)
#+END_SRC

*** Thingatpt+
n
#+NAME: thingatpt-plus
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package thingatpt+)

(use-package misc-fns)
#+END_SRC

*** Bookmark

#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
<<bookmark-plus>>
<<bookmark-bm>>
<<bookmark-zsh>>
#+END_SRC

**** Bookmark File
#+BEGIN_SRC emacs-lisp :tangle no
(setq bookmark-default-file
 (no-littering-expand-var-file-name "bookmarks"))

#+END_SRC
**** Bookmark+

#+NAME: bookmark-plus
#+BEGIN_SRC emacs-lisp :tangle no
(use-package bookmark+)
#+END_SRC

**** Bm

#+NAME: bookmark-bm
#+BEGIN_SRC emacs-lisp :tangle no
(use-package bm)
#+END_SRC

**** zsh sync

Converts Emacs into bookmarks for zsh[fn:16].

#+BEGIN_EXAMPLE shell :shebang /bin/zsh
setopt cd_able_vars
[[ -r ~/.zsh.bmk ]] && source ~/.zsh.bmk
#+END_EXAMPLE


#+NAME: bookmark-zsh
#+BEGIN_SRC emacs-lisp :tangle no
  (defadvice bookmark-write-file
        (after local-directory-bookmarks-to-zsh-advice activate)
     (local-directory-bookmarks-to-zsh))

  (defun local-directory-bookmarks-to-zsh ()
        (interactive)
        (when (and (require 'tramp nil t)
                   (require 'bookmark nil t))
          (set-buffer (find-file-noselect "~/.zsh.bmk" t t))
          (delete-region (point-min) (point-max))
          (insert "# -*- mode:sh -*-\n")
          (let (collect-names)
            (mapc
             (lambda (item)
               (let ((name
                      (replace-regexp-in-string
                       "-" "_" (car item)))
                    (file (cdr
                            (assoc 'filename
                                   (if (cddr item)
                                       item
                                     (cadr item))))))
                 (when (and (not (tramp-tramp-file-p file))
                          (file-directory-p file))
                   (setq collect-names
                         (cons (concat "~" name) collect-names))
                   (insert
                    (format
                     "%s=\"%s\"\n"
                     name
                     (expand-file-name file)
                     name)))))
             bookmark-alist)
            (insert ": "
                    (mapconcat 'identity collect-names " ") "\n"))
          (let ((backup-inhibited t)) (save-buffer))
          (kill-buffer (current-buffer))))
#+END_SRC

*** Bug Tracking

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package debbugs
  :straight (debbugs
             :type git
             :repo "https://git.savannah.gnu.org/git/emacs/elpa.git"
             :files ("packages/debbugs/*.el"
                     "packages/debbugs/Debbugs.wsdl")
             :local-repo "elpa"))

#+END_SRC

** Multimedia

#+NAME: media-spec
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; EMMS
<<media-emms>>
;; SoundCloud
<<media-soundcloud>>

#+END_SRC

*** emms

#+NAME: media-emms
#+BEGIN_SRC emacs-lisp :tangle no
(use-package emms
    :custom
    (emms-source-file-default-directory
     (pcase system-type
       (`darwin (dropbox-dir "Music" "iTunes" "iTunes Media" "Music"))
       (`linux (user-home "Music"))))
    :init
    (require 'emms-setup)
    (emms-all)
    (emms-default-players)
    :config
    ;; add flv and ogv
    (define-emms-simple-player mplayer '(file url)
      (regexp-opt '(".ogg" ".mp3" ".mp4" ".wav" ".mpg"
                    ".mpeg" ".wmv" ".wma" ".mov" ".avi"
                    ".divx" ".ogm" ".asf" ".mkv" "http://"
                    "mms://" ".rm" ".rmvb" ".mp4" ".flac"
                    ".vob" ".m4a" ".flv" ".ogv" ".pls"))
      "mplayer" "-slave" "-quiet" "-really-quiet" "-fullscreen"))
#+END_SRC

*** Sound Cloud

#+NAME: media-soundcloud
#+BEGIN_SRC emacs-lisp :tangle no
(use-package soundcloud)
#+END_SRC

* User Interface

Credits to [[https://github.com/domtronn][domtronn]] for a solid portion of this stuff. Dude makes really fantastic Emacs UI libraries and enhancements.

#+NAME: core/ui
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin UI
<<ui/theme>>
;; Cursor
<<ui/cursor>>
;; Fonts
<<ui/fonts>>
;; Icons
<<ui/icons>>
; Modeline
<<ui/modeline>>
;; Scrolling
<<ui/scroll>>
;; Buttons
<<ui/buttons>>
;; Pretty
<<ui/pretty>>
;; End UI
#+END_SRC

** Theme

#+NAME: ui/theme
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;;; Begin Theme Group
;; Theme interface
<<theme-interface>>
;; Custom themes
<<theme-custom-theme>>
;; Zenburn theme
<<theme-zenburn>>
;; Poet Theme
<<theme-poet>>
;; Base16 Themes
<<theme-base16>>
;; Load Theme
<<theme-load-theme>>
;; Org Mode faces
<<theme-org-mode>>
;; Italicize keywords for modes
<<theme-italicize-for-modes>>
;; Per Buffer theme
<<theme/per-buffer>>
;;; End Theme Group
#+END_SRC

*** Theme Defaults

#+NAME: theme-interface
#+BEGIN_SRC emacs-lisp :tangle no
(defcustom halidom--theme-style 'dark
  "The default theme mode. Only symbols 'dark and 'light are considered."
  :type '(choice
          (const :tag "Use a dark theme by default." dark)
          (const :tag "Use a light theme by default" light)
          (const :tag "Ignore the value of this variable" nil)))

(defcustom halidom-term-theme 'wombat
  "The default term theme."
  :type 'symbol)

(defcustom halidom-prose-theme 'tsdh-light
   "The default theme for writing text."
   :type 'symbol)

(defcustom halidom-light-theme 'tsdh-light
  "The light theme."
  :type 'symbol)

(defcustom halidom-dark-theme 'tsdh-dark
  "The dark theme."
  :type 'symbol)

(defcustom halidom-theme 'tsdh-dark
  "The default theme to load."
  :type 'string)

(defcustom halidom-theme-colors nil
  "plist of colors for the current theme."
  :type '(plist :key-type symbol :value-type sexp))
#+END_SRC

*** Custom Theme Settings

This disables Emacs asking questions about loading a new theme.

#+NAME: theme-custom-theme
#+BEGIN_SRC emacs-lisp :tangle no
(setq custom-safe-themes t)
(setq custom-theme-directory (emacs-dir "themes"))
#+END_SRC

*** Org Beautify Theme :deprecate:
:PROPERTIES:
:ID:       4612DA55-904D-44D4-9E3D-98E6D7AF72E2
:CUSTOM_ID: org-beautify-theme
:END:

#+NAME: ob-theme
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-beautify-theme
  ;; Minor modifications for better compatibility with atom-one-dark
  ;; theme.
  :straight (org-beautify-theme
             :host github
             :repo "jchaffin/org-beautify-theme"
             :files ("org-beautify-theme.el"))
  :config
  (defun org-beautify-load-theme ()
    (setq org-beautify-theme-use-box-hack nil)
    (add-to-list 'custom-enabled-themes 'org-beautify)
    (load-theme 'org-beautify)))
#+END_SRC

*** Zenburn Theme

#+NAME: theme-zenburn
#+BEGIN_SRC emacs-lisp :tangle no
(use-package zenburn-theme
  :straight t)
#+END_SRC

*** Poet Theme

#+NAME: theme-poet
#+BEGIN_SRC emacs-lisp :tangle no
(use-package poet-theme
  :init
  (setq halidom-light-theme 'poet))
#+END_SRC

*** Base16 Themes

#+NAME: theme-base16
#+BEGIN_SRC emacs-lisp :tangle no
(use-package base16-theme
    :init
    (setq halidom-dark-theme 'base16-oceanicnext
          halidom-light-theme 'base16-default-light)
     (require 'base16-oceanicnext-theme)

     (defun halidom--base16-p (&optional theme)
      (let ((theme (or theme halidom-theme "")))
        (string-prefix-p "base16-" (symbol-name theme))))

    (add-to-list 'custom-theme-load-path
                 (expand-file-name "straight/build/base16-theme"
                                   user-emacs-directory))
    :config
    (setq base16-distinct-fringe-background nil))

#+END_SRC

*** Load Theme

#+NAME: theme-load-theme
#+BEGIN_SRC emacs-lisp :tangle no
  (setq-default custom-enabled-themes (list halidom-theme))

  (defun remove-themes ()
    "Forcibly load the themes listed in `custom-enabled-themes'."
    (mapc #'disable-theme custom-enabled-themes))

  (defvar halidom/load-theme-hook nil)

  (defun halidom/load-theme (&optional theme)
    (interactive "P")
    (let* ((options (mapcar 'symbol-name (custom-available-themes)))
           (theme-name (if (interactive-p)
                           (completing-read "Theme: " options)
                         (eval (intern
                                (concat
                                 "halidom-"
                                 (format "%s"
                                 (symbol-value
                                 'halidom--theme-style))
                                 "-theme")))))
           (theme-symbol
            (if (symbolp theme-name)
                theme-name
              (intern theme-name))))
      (remove-themes)
      (if (not window-system)
          (load-theme halidom-term-theme)
        (setq halidom-theme theme-symbol)
        (if (halidom--base16-p halidom-theme)
            (setq halidom-theme-colors
                  (symbol-value
                   (intern
                    (eval
                     `(concat
                       ,(symbol-name
                         (symbol-value 'halidom-theme))
                       "-colors")))))
          (setq halidom-theme-colors nil))
        (load-theme halidom-theme)
        (run-hooks 'halidom/load-theme-hook))))

  (defun halidom/load-theme-with-frame (frame)
    (with-selected-frame frame
      (unless (daemonp)
        (halidom/load-theme))))

  (defun halidom--toggle-theme-style ()
    (interactive)
    (if (eq halidom--theme-style 'dark)
        (setq halidom--theme-style 'light)
      (setq halidom--theme-style 'dark)))

  (defun halidom/toggle-theme ()
    (interactive)
    (halidom--toggle-theme-style)
    (halidom/load-theme))

  (add-hook 'after-init-hook #'halidom/load-theme)
  ;; (add-hook 'after-make-frame-functions #'halidom/load-theme-with-frame)

#+END_SRC

*** Org Mode Faces

#+NAME: theme-org-mode
#+BEGIN_SRC emacs-lisp :tangle no

  ;; Org Mode faces
    (defun halidom/org-faces ()
      "Customize `org-mode' faces for base-16 themes."
      (let ((fg (face-foreground 'default nil 'default))
      (fg2 (or (plist-get halidom-theme-colors :base04)))
      (bg2 (or (plist-get halidom-theme-colors :base01)))
      (sans-font "Source Sans Pro")
      (header-font "EtBembo"))
        (when (and fg2 bg2)

          (set-face-attribute 'org-block-begin-line nil
                              :height 1.0
                              :foreground fg2
                              :background bg2
                              :inherit 'org-meta-line)

          (set-face-attribute 'org-document-info-keyword nil
                              :foreground fg2
                              :slant 'italic
                              :inherit 'org-document-info-face))

        (set-face-attribute 'org-level-2 nil
                            :family header-font
                            :height 1.2
                            :inherit 'outline-2)
        (set-face-attribute 'org-level-1 nil
                            :family sans-font
                            :height 1.6
                            :inherit 'outline-1)
        (set-face-attribute 'org-level-2 nil
                            :family sans-font
                            :height 1.3
                            :inherit 'outline-2)
        (set-face-attribute 'org-level-3 nil
                            :family sans-font
                            :height 1.2
                            :slant 'normal
                            :inherit 'outline-3)
        (set-face-attribute 'org-level-4 nil
                            :family sans-font
                            :height 1.1
                            :slant 'normal
                            :inherit 'outline-3)
        (set-face-attribute 'org-level-5 nil
                            :family sans-font
                            :height 1.1
                            :slant 'normal
                            :inherit 'outline-4)
        (set-face-attribute 'org-level-6 nil
                            :family sans-font
                            :height 1.1
                            :slant 'normal
                            :inherit 'outline-3)
        (set-face-attribute 'org-level-7 nil
                            :family sans-font
                            :height 1.0
                            :slant 'normal
                            :inherit 'outline-3)

        (set-face-attribute 'org-block nil
                            :height 1.0
                            :slant 'normal
                            :foreground fg)

        (set-face-attribute 'org-document-title nil
                            :family header-font
                            :foreground fg
                            :height 1.8
                            :underline nil
                            :inherit 'variable-pitch)

        (set-face-attribute 'org-block-end-line nil
                            :inherit 'org-block-begin-line)))

    ;; https://github.com/syl20bnr/spacemacs/pull/7667
    (defun halidom/org-restart ()
      "Restart all open org-mode buffers."
      (let ((org-buffers (org-buffer-list)))
        (dolist (buf org-buffers)
    (with-current-buffer buf
      (org-mode-restart)))))

    (defun halidom/org-theme-hook ()
        (halidom/org-faces)
        (halidom/org-restart))

    (defun halidom/disable-scroll-bar (&optional frame)
      (if frame
          (with-selected-frame frame
            (toggle-scroll-bar -1))
        (toggle-scroll-bar -1)))

    ;; Add Hooks
    (add-hook 'halidom/load-theme-hook #'halidom/org-theme-hook)
    (add-hook 'halidom/load-theme-hook #'halidom/disable-scroll-bar)
    (add-hook 'after-make-frame-functions #'halidom/disable-scroll-bar)
#+END_SRC

*** Italicize font lock keyword face

#+NAME: theme-italicize-for-modes
#+BEGIN_SRC emacs-lisp :tangle no
(defcustom halidom-italicize-keyword-modes '(emacs-lisp-mode js2-mode)
  "Major modes for which an italicized font lock keyword
face shall be used."
  :type '(symbol))

(defun halidom/italicize-keyword-fn ()
(face-remap-add-relative 'font-lock-keyword-face
                         '(:slant italic
                           :family "Operator Mono")))

(defun halidom/italicize-keyword-faces ()
  (cl-flet ((mode->hook (mode)
              (intern (concat (symbol-name mode) "-hook"))))
    (cl-loop
       for mode in halidom-italicize-keyword-modes
       for hooksym = (mode->hook mode)
       do
         (add-hook hooksym 'halidom/italicize-keyword-fn))))


(add-hook 'after-init-hook 'halidom/italicize-keyword-faces)

#+END_SRC

**** Per buffer Themes

#+NAME: theme/per-buffer
#+BEGIN_SRC emacs-lisp :tangle no
(use-package per-buffer-theme)
#+END_SRC

** Cursor

#+NAME: ui/cursor
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Disable blink
<<cursor/blink>>
;; disable cursor in non selected window
<<cursor/window>>
;; Smart color
<<cursor/smart-color>>
;; multiple cursors mode
<<cursor/mc>>
;; centered cursor mode
<<cursor/centered>>
;; bar cursor
<<cursor/bar>>
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle yes
*** Bar Cursor

#+NAME: cursor/bar
#+BEGIN_SRC emacs-lisp :tangle no
(use-package bar-cursor
  :init (bar-cursor-mode 1))
#+END_SRC

*** Disable Blink

Ultimately, I'd like to set a longer blink interval, like the "phase"
~caret_style~ setting in Sublime Text.

#+NAME: cursor/blink
#+BEGIN_SRC emacs-lisp :tangle no
(blink-cursor-mode -1)
#+END_SRC

*** Only show cursor in selected window

#+NAME: cursor/window
#+BEGIN_SRC emacs-lisp :tangle no
(setq-default cursor-in-non-selected-windows nil
              x-stretch-cursor nil)
#+END_SRC

*** Smart Cursor Color

#+NAME: cursor/smart-color
#+BEGIN_SRC emacs-lisp :tangle no

(use-package smart-cursor-color
  :config
  (smart-cursor-color-mode 1))

#+END_SRC

*** Multiple Cursors

#+NAME: cursor/mc
#+BEGIN_SRC emacs-lisp :tangle no
(use-package multiple-cursors
  :init
  (global-unset-key (kbd "M-<down-mouse-1>"))
  :bind
  (("C-c C-s-." . mc/edit-lines)
   ("C->" . mc/mark-next-like-this)
   ("C-M->" . mc/mark-next-lines)
   ("C-c C->" . mc/mark-all-like-this)
   ("M-<mouse-1>" . mc/add-cursor-on-click)))
#+END_SRC

*** Centered Cursor Mode

#+NAME: cursor/centered
#+BEGIN_SRC emacs-lisp :tangle no
(use-package centered-cursor-mode
    :init
  (centered-cursor-mode 1))
#+END_SRC

** Fonts

#+NAME: ui/fonts
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; font variables
<<fonts/variables>>
;; set font interactively
<<fonts/interactive>>
;; Default font
<<fonts/default>>
;; unicode fonts
<<fonts/unicode>>
#+END_SRC

*** Font variables

#+NAME: fonts/variables
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar font-list nil
  "An alist of fonts which can be interactively chosen
   using the `set-font' function.

   Each font entry is a cons cell composed of the font-family as a string and
   the associated font weight as an unquoted symbol.

   See `font-weight-table' for a list of available options.

   e.g (\"FONT-FAMILY\" . WEIGHT)"
  )


#+END_SRC

*** Set font interactively

#+NAME: fonts/interactive
#+BEGIN_SRC emacs-lisp :tangle no
(when *is-mac*
  (let ((font-weight-xs '(("Andale Mono" . extralight)
                          ("Droid Sans Mono" . normal)
                          ("Fira Code" . light)
                          ("Hack" . normal)
                          ("Inconsolata" . medium)
                          ("Operator Mono" . extralight)
                          ("SF Mono" . normal)
                          ("Programma" . normal))))
  (mapcar (lambda (font-weight-x)
	    (add-to-list 'font-list font-weight-x))
	  font-weight-xs)))


(defun set-font (&optional font)
  "Set the custom FONT with completion"
  (interactive)
  (let* ((font (or font (assoc
			 (completing-read "Font: " font-list nil nil)
			 font-list)))
	 (family (car font))
	 (weight (cdr font)))
    (run-at-time "0.2 sec" nil
		 `(lambda () (when (not (eq (face-attribute 'default :family)
				       ,family))
			  (set-face-attribute 'default nil :family ,family
					      :weight (quote ,weight)))))))
#+END_SRC

*** Set the default font

#+NAME: fonts/default
#+BEGIN_SRC emacs-lisp :tangle no
  (defcustom halidom-fonts
    '(("Fira Code" . light)
      ("Operator Mono" . extralight)
      ("SF Mono" . normal)
      ("Lucida Sans Typewriter" . nil)
      ("Ubuntu Mono" . nil)
      ("Menlo" . nil)
      ("Inconsolota" . nil)
      ("Input Mono" . nil)
      ("Courier New" . nil))
    "The default font stack to use for setting the font
  on startup and new frame."
    :type '(string))

  (defcustom halidom-macos-default-font-size 12
    "The default font size in pixels."
    :type 'number)


  (defun halidom/font-setup ()
    (interactive)
    (let* ((font-family
            (or
             (car (seq-intersection
                   (mapcar #'car halidom-fonts) (font-family-list)))
             (face-attribute 'fixed-pitch :family)))
           (weight (or (cdr (assoc font-family halidom-fonts)) 'normal)))
      (run-at-time "0.2 sec" nil
                   `(lambda ()
                      (when (not (eq (face-attribute 'default :family)
                                   ,font-family))
                        (set-face-attribute
                         'default nil
                         :family ,font-family
                         :weight (quote ,weight)
                         :height 120))))))

  (defun halidom/font-setup-for-frame (frame)
    (with-selected-frame frame
        (halidom/font-setup)))

  (add-hook 'after-init-hook 'halidom/font-setup)
  ;; (add-hook 'after-make-frame-functions 'halidom/font-setup-for-frame)

#+END_SRC

*** Unicode

#+NAME: fonts/unicode
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Unicode Fonts
<<unicode/fonts>>
;; Emojis
<<unicode/emojis>>
#+END_SRC

**** Unicode Fonts

#+NAME: unicode/fonts
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package unicode-fonts
    :init
    (unicode-fonts-setup))
#+END_SRC

**** Emojis

#+NAME: unicode/emojis
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Unicode Emoticons
<<emoji/unicode-emoticons>>
;; Symbol Font
<<emoji/symbol-font>>
;; Company Emoji
<<emoji/company>>
#+END_SRC

***** Symbol Font

#+NAME: emoji/symbol-font
#+BEGIN_SRC emacs-lisp :tangle no
  (cond
   ((eq system-type 'gnu/linux)
    (set-fontset-font "fontset-default" nil "Symbola" nil 'append))
   ((eq system-type 'darwin)
    (set-fontset-font
     t 'symbol
  	 (font-spec :family "Apple Color Emoji") nil 'prepend)
    (set-fontset-font
     t 'symbol
     (font-spec :family "Apple Symbols") nil 'append)))

#+END_SRC

***** Unicode Emoticons

#+NAME: emoji/unicode-emoticons
#+BEGIN_SRC emacs-lisp :tangle no
(use-package unicode-emoticons)
#+END_SRC

***** Company Emoji

#+NAME: emoji/company
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-emoji
  :after (:all company emojify-mode)
  :demand t
  :init
    ;; https://github.com/dunn/company-emoji#emoji-font-support
  (defun --set-emoji-font (frame)
    "Adjust the font settings of FRAME so Emacs can display emoji properly."
    (if (eq system-type 'darwin)
        ;; For NS/Cocoa
        (set-fontset-font t 'symbol (font-spec :family "Apple Color Emoji") frame 'prepend)
      ;; For Linux
      (set-fontset-font t 'symbol (font-spec :family "Symbola") frame 'prepend)))
  (--set-emoji-font nil)

  ;; Hook for when a frame is created with emacsclient
  (add-hook 'after-make-frame-functions '--set-emoji-font)

  :config
  (defun company-emoji-setup ()
    (let ((backends (cons 'company-emoji company-backends)))
      (set (make-local-variable 'company-backends) backends)))

  (add-hook 'emojify-mode-hook #'company-emoji-setup))

#+END_SRC

** Icons

#+NAME: ui/icons
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Begin icons Group
;; VS Code Icons
<<icons/vscode>>
;; All the Icons
<<icons/all-the-icons>>
;; All the icons dired
<<icons/dired>>
;; All the icons ivy
<<icons/ivy>>
;; End icons Group
#+END_SRC

*** VS Code Icons

#+NAME: icons/vscode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package vscode-icon
  :init
  (require 'vscode-icon)
  :commands (vscode-icon-for-file))

#+END_SRC

*** All the icons

[[https://github.com/domtronn/all-the-icons.el][All The Icons]] is a utility package for icons in Emacs.

#+NAME: icons/all-the-icons
#+BEGIN_SRC emacs-lisp :tangle no
(use-package all-the-icons)
#+END_SRC

*** Dired Icons

#+NAME: icons/dired
#+BEGIN_SRC emacs-lisp :tangle no
(use-package all-the-icons-dired
    :hook
    (dired-mode . all-the-icons-dired-mode))
#+END_SRC

*** Ivy All the Icons

#+NAME: icons/ivy
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package all-the-icons-ivy
    :after (:all ivy all-the-icons)
    :init
    (all-the-icons-ivy-setup))

#+END_SRC

** Modeline

#+NAME: ui/modeline
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;;; Begin Modeline Group
;; Customization interface
<<ml/interface>>
;; Smart Mode Line
<<ml/sml>>
;; Spaceline
<<ml/spaceline>>
;; Powerline
<<ml/powerline>>
;; Eyeliner
<<ml/eyeliner>>
;; Setup the modeline
<<ml/setup>>
;; End Modeline Group
#+END_SRC

*** Modeline Customization

#+NAME: ml/interface
#+BEGIN_SRC emacs-lisp :tangle no
(defcustom halidom-modeline 'spaceline
  "When non-nil, the modeline framework to use at startup.
Options are 'spaceline, 'sml, 'powerline, and 'eyeliner."
  :type '(choice
          (const :tag "Use the default modeline." nil)
          (const :tag "Use spaceline" spaceline)
          (const :tag "Use smart-mode-line" sml)
          (const :tag "Use powerline" powerline)
          (const :tag "Use eyeline"  eyeliner))
  :initialize 'custom-initialize-default)
#+END_SRC

*** Spaceline

#+NAME: ml/spaceline
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
<<sl/spaceline>>
;; Spaceline icons
<<sl/icons>>
;; setup spaceline
<<sl/setup>>
#+END_SRC

**** Spaceline Mode

#+NAME: sl/spaceline
#+BEGIN_SRC emacs-lisp :tangle no
(use-package spaceline)
#+END_SRC

**** Spaceline All the Icons

#+NAME: sl/icons
#+BEGIN_SRC emacs-lisp :tangle no
(use-package spaceline-all-the-icons
  :after (:all all-the-icons spaceline))
#+END_SRC

**** Spaceline setup

#+NAME: sl/setup
#+BEGIN_SRC emacs-lisp :tangle no
  (defun ml-spaceline-setup ()
    "Setup the modeline for spaceline."
    (setq spaceline-all-the-icons-separator-type 'arrow)
    (require 'spaceline)
    (require 'spaceline-segments)
    (require 'spaceline-config)
    (require 'all-the-icons)
    (require 'spaceline-all-the-icons)
    (spaceline-all-the-icons--setup-neotree)
    (spaceline-all-the-icons-theme 'mu4e-alert 'org-pomodoro)
    (spaceline-toggle-all-the-icons-flycheck-status-off))
#+END_SRC

*** Smart Mode Line

#+NAME: ml/sml
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
<<sml/smart-mode-line>>
;; Smart Mode Line setup
<<sml/setup>>
#+END_SRC

#+NAME: sml/smart-mode-line
#+BEGIN_SRC emacs-lisp :tangle no
(use-package smart-mode-line)
#+END_SRC

#+NAME: sml/setup
#+BEGIN_SRC emacs-lisp :tangle no

(defun ml-smline-setup ()
  "Setup the modeline for smart-mode-line."
  (require 'smart-mode-line)
  (setq sml/no-confirm-load-theme t)
  (setq sml/theme 'respectful)
  (sml/setup)
  (run-hooks 'sml-setup-hook))
#+END_SRC

*** Powerline

#+NAME: ml/powerline
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
<<pl/powerline>>
;; Powerline setup
<<pl/setup>>
#+END_SRC

#+NAME: pl/powerline
#+BEGIN_SRC emacs-lisp :tangle no
(use-package powerline
    :straight t)
#+END_SRC

**** Setup Powerline

#+NAME: pl/setup
#+BEGIN_SRC emacs-lisp :tangle no
(defun ml-powerline-setup ()
  "Setup the modeline for powerline."
  (require 'powerline)
  (powerline-default-theme))
#+END_SRC

*** Eyeliner

#+NAME: ml/eyeliner
#+BEGIN_SRC emacs-lisp :tangle no
(use-package eyeliner
    :straight (eyeliner
               :type git
               :host github
               :repo "dustinlacewell/eyeliner")
    :init
    (defun ml-eyeliner-setup ()
      (require 'eyeliner)
      (eyeliner/install)))

#+END_SRC

*** Set the modeline format

#+NAME: ml/setup
#+BEGIN_SRC emacs-lisp :tangle no

(defun halidom/modeline-setup ()
  "Setup the modeline."
  (interactive)
  (pcase halidom-modeline
    (`spaceline (ml-spaceline-setup))
    (`powerline (ml-powerline-setup))
    (`sml (ml-smline-setup))
    (`eyeliner (ml-eyeliner-setup))))

(defun halidom/modeline-setup-frame (frame)
  (with-selected-frame frame
    (when (daemonp)
      (if (display-graphic-p)
          (halidom/modeline-setup)
        (ml-smline-setup)))))

(add-hook 'after-init-hook 'halidom/modeline-setup)
(add-hook 'after-make-frame-functions 'halidom/modeline-setup-frame)
#+END_SRC

** Scrolling

#+NAME: ui/scroll
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Begin Scroll
;; Scroll to first error on compilation
<<scroll/compile-error>>
;; Smooth scrolling
<<scroll/smooth>>
;; Subliminity
<<scroll/subliminity>>
;; End Scroll
#+END_SRC

*** Scroll to first error on compilation

#+NAME: scroll/compile-error
#+BEGIN_SRC emacs-lisp :tangle yes
(setq compilation-scroll-output 'first-error)
#+END_SRC

*** Smooth Scrolling

#+NAME: scroll/smooth
#+BEGIN_SRC emacs-lisp :tangle no
(use-package smooth-scrolling
  :init
  (smooth-scrolling-mode 1)
  :config
  (setq scroll-preserve-screen-position t
        scroll-margin 0
        scroll-conservatively 101))
#+END_SRC

*** Sublimity Scroll

#+NAME: scroll/subliminity
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package sublimity
      :init
    (require 'sublimity-scroll))
#+END_SRC

** Buttons

#+NAME: ui/buttons
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
<<button/lock>>
#+END_SRC

*** Button Lock

#+NAME: button/lock
#+BEGIN_SRC emacs-lisp :tangle no
(use-package button-lock)
#+END_SRC

** Pretty

#+NAME: ui/pretty
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Prettify Symbols Mode
<<pretty/symbols>>
;; Pretty Mode
<<pretty/mode>>
;; pretty utils
<<pretty/utils>>
;; Ekaschalk Display Layer
<<pretty/ekaschalk>>
#+END_SRC

*** Prettify Symbols

Seems to be problems rendering symbols on Debian. Not sure if this is
because the necessary fonts are not installed or if it's because of
the absence of a window system. I'll check for the latter for now.

#+NAME: pretty/symbols
#+BEGIN_SRC emacs-lisp :tangle no
  (when (display-graphic-p)
    (add-hook 'prog-mode-hook 'prettify-symbols-mode))
#+END_SRC

*** Pretty Mode

#+NAME: pretty/mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package pretty-mode
    :hook
  (emacs-lisp-mode . turn-on-pretty-mode)
  (LaTeX-mode . turn-on-pretty-mode))
#+END_SRC

*** Prettify Utilities

#+NAME: pretty/utils
#+BEGIN_SRC emacs-lisp :tangle no
(use-package prettify-utils
  :straight (prettify-utils
             :host github
             :repo "Ilazki/prettify-utils.el")
  :init
  (require 'prettify-utils))

#+END_SRC

*** Modern Emacs
*** Pretty Eshell

From Eric Kaschalk's [[https://github.com/ekaschalk/.spacemacs.d][spacemacs display layer]].[fn:19]

#+NAME: ekaschalk/eshell
#+BEGIN_SRC emacs-lisp :tangle no
(use-package pretty-eshell
  :if (file-exists-p (emacs-etc-dir "local/pretty-eshell/pretty-eshell.el"))
  :straight nil
  :load-path "~/.emacs.d/etc/local/pretty-eshell"
  :custom-face
  (eshell-prompt ((t (:foreground "gray83"))))
  :custom
  ;; Eshell prompt header
  ;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
  ;; your login, these can be the same.
  (eshell-prompt-regexp "λ ")   ; or "└─> "
  :init
  (progn
    (require 'pretty-eshell)
    (setq pretty-eshell-header "\n ")
    (setq pretty-eshell-prompt-string "λ ")
    ;; Directory
    (pretty-eshell-section
     esh-dir
     "\xf07c"  ; 
     (abbreviate-file-name (eshell/pwd))
     '(:foreground "gold" :bold ultra-bold :underline t))

    ;; Git Branch
    (pretty-eshell-section
     esh-git
     "\xe907"  ; 
     (magit-get-current-branch)
     '(:foreground "pink"))

    ;; Python Virtual Environment
    (pretty-eshell-section
     esh-python
     "\xe928"  ; 
     pyvenv-virtual-env-name)

    ;; Time
    (pretty-eshell-section
     esh-clock
     "\xf017"  ; 
     (format-time-string "%H:%M" (current-time))
     '(:foreground "forest green"))

    ;; Prompt Number
    (pretty-eshell-section
     esh-num
     "\xf0c9"  ; 
     (number-to-string pretty-eshell-prompt-num)
     '(:foreground "brown"))

    (setq pretty-eshell-funcs
          (list esh-dir esh-git esh-python esh-clock esh-num))))
#+END_SRC

* Completion

#+NAME: completion-spec
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;;; Begin Completion Group
;; Begin Company
<<completion-company>>
;; End Company
;; Begin Snippets
<<completion-snippets>>
;; End Snippets
;; Begin Minibuffer
<<completion-minibuffer>>
;; End Minibuffer
;;; End Completion Group
#+END_SRC

** Company

#+NAME: completion-company
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Company
<<company-spec>>
;; Company quickhelp
<<company-doc>>
;; Company Statistics
<<company-stats>>
;; Company box
<<company-dropdown>>
;; End Company
#+END_SRC

Emacs has two popular packages for code completion --
[[https://github.com/auto-complete/auto-complete][autocomplete]] and [[https://github.com/company-mode/company-mode][company]]. This reddit [[https://www.reddit.com/r/emacs/comments/2ekw22/autocompletemode_vs_companymode_which_is_better/][thread]] was enough for
me to go with company.

If you need more convincing, [[https://github.com/company-mode/company-mode/issues/68][company-mode/company-mode#68]]
offers a comprehensive discussion on the two.

The ticket is from the ‘company-mode‘ repository, so there's
probably some bias there, but company-mode hasn't provided
any reason for me reconsider my choice.

#+NAME: company-spec
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package company
    :commands global-company-mode
    :bind (("TAB" . company-indent-or-complete-common)
           ("C-c /" . company-files)
           ("M-SPC" . company-complete)
            (:map company-mode-map
                  ("M-n" . company-select-next-or-abort)
                  ("M-p" . company-select-previous-or-abort)))
    :init
    (add-hook 'after-init-hook 'global-company-mode)
    :config
    (setq company-tooltip-limit 20
          company-tooltip-align-annotations t
          company-minimum-prefix-length 3
          company-idle-delay 0.1
          company-begin-commands '(self-insert-command)))
#+END_SRC

*** Company Quick Help

[[https://github.com/expez/company-quickhelp][Company Quick Help]] emulates =autocomplete= documentation-on-idle behavior, but using the less-buggy =pos-tip= package rather than =popup-el=.

#+NAME: company-doc
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-quickhelp
  :after (company)
  :commands (company-quickhelp-manual-begin)
  :bind
  (:map company-active-map
        ("C-c h" . company-quickhelp-manual-begin))
  :config
  (company-quickhelp-mode 1))
#+END_SRC

*** Company Statistics

[[https://github.com/company-mode/company-statistics][Company statistics]] uses a persisent store of completions to rank the
top candidates for completion.

#+NAME: company-stats
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-statistics
  :after (company)
  :demand t
  :init
  (company-statistics-mode))
#+END_SRC

*** Company Box

#+NAME: company-dropdown
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-box
    :custom (company-box-enable-icon nil)
    :hook (company-mode . company-box-mode))
#+END_SRC

** Snippets

#+NAME: completion-snippets
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Yasnippet
<<snippets-yasnippet>>
;; Code Library
<<snippets-code-library>>
#+END_SRC

*** YASnippet

[[https://github.com/joaotavora/yasnippet][YASnippet]] is a template system based off the TextMate snippet syntax.

Here, I create a variable for my personal snippets directory.

After installation and enabling the package, add the personal snippets
directory to the list of directories where YASnippet should look for snippets.

#+NAME: snippets-yasnippet
#+BEGIN_SRC emacs-lisp :tangle no
(use-package yasnippet
    :bind
    (:map goto-map
          ("s" . goto-snippet-dir))

    :init
    (defvar snippet-directory (emacs-etc-dir "yasnippet" "snippets")
      "Directory for yasnippets.")

    (defun goto-snippet-dir ()
      "Goto `snippet-directory'."
      (interactive)
      (let ((default-directory snippet-directory))
        (dired default-directory)))

    (yas-global-mode 1))

#+END_SRC

YASnippet can also be used as a non-global minor mode on a per-buffer
basis.

Invoking ~yas-reload-all~ will load the snippet tables, and then
calling ~yas-minor-mode~ from the major mode hooks will load the
snippets corresponding to the major mode of the current buffer mode.

#+BEGIN_EXAMPLE emacs-lisp
(yas-reload-all)
(add-hook 'prog-mode-hook #'yas-minor-mode)
#+END_EXAMPLE

*** Code Library

#+NAME: snippets-code-library
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package code-library
    :after (org)
    :init
    (progn
      (setq code-library-directory (emacs-etc-dir "codelibrary"))
      (if-not (file-exists-p code-library-directory)
          (if (yes-or-no-p
               (format-message "Directory `%s' doesn't exist. Make directory?" code-library-directory))
              (mkdir code-library-directory))))
    :config
    (progn
      (append 'code-library-mode-file-alist
              '((latex-mode . "latex.org")
                (org-mode .  "latex.org")
                (clojure-mode . "clojure.org")
                (makefile-mode . "makefile.org")
                (makefile-gmake-mode . "makefile.org")))n
      (setq code-library-sync-to-gist t)))
#+END_SRC

** Minibuffer

#+NAME: completion-minibuffer
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Minibuffer Prompt Properties
<<mb-prompt>>
;; Ivy Group
<<mb-ivy>>
;; Counsel
<<mb-counsel>>
;; Swiper
<<mb-swiper>>
;; Smex
<<mb-smex>>
;; Omnibox
<<mb-omnibox>>
#+END_SRC

*** Prompt Properties

Don't let the cursor go into the minibuffer prompt.

From Xah Lee's [[http://ergoemacs.org/emacs/emacs_stop_cursor_enter_prompt.html][emacs-stop-cursor-enter-prompt]], found in the [[https://github.com/syl20bnr/spacemacs/blob/bd7ef98e4c35fd87538dd2a81356cc83f5fd02f3/layers/%2Bdistributions/spacemacs-base/config.el#L128-L131][config.el]] file of the spacemacs base layer.

#+NAME: mb-prompt
#+BEGIN_SRC emacs-lisp :tangle no
(setq minibuffer-prompt-properties
      '(read-only t point-entered minibuffer-avoid-prompt face minibuffer-prompt))
#+END_SRC

*** Ivy

#+NAME: mb-ivy
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Ivy
<<ivy/spec>>
;; Ivy Xref
<<ivy/xref>>
;; Ivy Todo
<<ivy/todo>>
;; Ivy rich
<<ivy/rich>>
;; Ivy pages
<<ivy/pages>>
;; Ivy Prescient
<<ivy/prescient>>
#+END_SRC

[[https://github.com/abo-abo/swiper][Ivy]] is a completion and selection framework in the same vein
as helm.

It doesn't have the same kind of ecosystem or interopability,
but its easy to configure, offers a minimalistic interface,
and is every bit as good of a completion tool as helm is,
if not better.

I prefer the default regex matcher, but if you want fuzzy matching as a fallback or replacement checkout this [[https://oremacs.com/2016/01/06/ivy-flx/][article]].

#+NAME: ivy/spec
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ivy
  :bind (("C-c C-r" . ivy-resume))
  :init
  (ivy-mode +1)
  :custom
  (ivy-use-virtual-buffers t)
  (ivy-initial-inputs-alist nil)
  (ivy-sort-max-size 50000)
  (ivy-re-builders-alist '((t . ivy--regex-plus)))
  (ivy-use-selectable-prompt nil))
#+END_SRC

**** Prescient

#+NAME: ivy/prescient
#+BEGIN_SRC emacs-lisp :tangle no
;; Package `prescient' is a library for intelligent sorting and
;; filtering in various contexts. It is not published to MELPA, so we
;; must define a recipe here.
(use-package prescient
  :config
  ;; Remember usage statistics across Emacs sessions.
  (prescient-persist-mode +1))

;; Package `ivy-prescient' provides intelligent sorting and filtering
;; for candidates in Ivy menus.
(use-package ivy-prescient
  :demand t
  :after ivy
  :config
  ;; Use `prescient' for Ivy menus.
  (ivy-prescient-mode +1))

;; Package `company-prescient' provides intelligent sorting and
;; filtering for candidates in Company completions.
(use-package company-prescient
  :demand t
  :after company
  :config

  ;; Use `prescient' for Company menus.
  (company-prescient-mode +1))

#+END_SRC

**** Ivy Xref

#+NAME: ivy/xref
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ivy-xref
    :init
  (setq xref-show-xrefs-function #'ivy-xref-show-xrefs))
#+END_SRC

**** Ivy Todos

#+NAME: ivy/todo
#+BEGIN_SRC emacs-lisp :tangle no

  (use-package ivy-todo
    :custom
    (ivy-todo-file (agenda-dir "ivy-todo.org")))


#+END_SRC

**** Ivy Rich

#+NAME: ivy/rich
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ivy-rich
      :after (counsel)
      :init
    (ivy-rich-mode 1))
#+END_SRC

**** Ivy Pages

#+NAME: ivy/pages
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ivy-pages
    :after (ivy))
#+END_SRC


*** Counsel

#+NAME: mb-counsel
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Counsel
<<counsel-spec>>
;; Counsel Projectile
<<counsel-projectile-config>>
;; Counsel Gtags
<<counsel-ggtags-config>>
;; Counsel iTunes
<<counsel-itunes-config>>
;; Counsel spotify
<<counsel-spotify-config>>
;; Counsel Dash
<<counsel-dash-config>>
;; Counsel Tramp
<<counsel-tramp-config>>
;; Counsel Code Search
<<counsel-codesearch-config>>
#+END_SRC

#+NAME: counsel-spec
#+BEGIN_SRC emacs-lisp :noweb no :tangle no
  (use-package counsel
    :bind (("<f2> u" . counsel-unicode-char)
           ("<f1> l" . counsel-find-library)
           ("C-c l" . counsel-load-library)
           ("C-c g" . counsel-git)
           ("C-c G" . counsel-git-grep)
           ("C-c k" . counsel-ag)
           ("C-x l" . counsel-locate)
           (:map minibuffer-local-map
                 ("C-r" . counsel-minibuffer-history))
           (:map org-mode-map
                 ("C-c C-j" . counsel-org-goto)
                 ("C-c M-t" . counsel-org-tag)
                 ("C-c f"   . counsel-org-file))
           (:map org-agenda-mode-map
                 ("C-c M-t" . counsel-org-tag-agenda)
                 ("C-c C-j" . counsel-org-agenda-headlines)))
    :init
    (counsel-mode +1)

    :config
    (setq-default counsel-git-grep-cmd counsel-git-grep-cmd-default)
    (setq counsel-mode-override-describe-bindings t)

    :blackout t)

#+END_SRC

**** Counsel Projectile

[[https://github.com/ericdanan/counsel-projectile][Counsel Projectile]] provides a project management interface via ivy and
friends.

#+NAME: counsel-projectile-config
#+BEGIN_SRC emacs-lisp :tangle no
(use-package counsel-projectile
    :after (:all projectile counsel)
    :demand t
    :init
    (counsel-projectile-mode t))
#+END_SRC

**** Counsel Gtags

#+NAME: counsel-ggtags-config
#+BEGIN_SRC emacs-lisp :tangle no
(use-package counsel-gtags
  :custom
	(counsel-gtags-ignore-case t)
  (counsel-gtags-auto-update t)

  :bind
  (:map counsel-gtags-mode-map
        ("M-m g d" . counsel-gtags-find-definition)
        ("M-m g r" . counsel-gtags-find-reference)
        ("M-m g s" . counsel-gtags-find-symbol)
        ("M-m g ," . counsel-gtags-go-backward))

  :config
  (which-key-add-key-based-replacements "M-m g"
      '("ggtags" . "Counsel Gtags"))

  :hook
  (c-mode-common . counsel-gtags-mode))
#+END_SRC

**** Counsel iTunes

#+NAME: counsel-itunes-config
#+BEGIN_SRC emacs-lisp :tangle no
(use-package counsel-itunes
  :if (executable-find "osascript")
  :straight
  (counsel-itunes
   :host github
   :repo "jchaffin/counsel-itunes")
  :demand t
  :after (:all counsel ivy)
  :init
   ;; make prefix command
  (define-prefix-command 'counsel-itunes-prefix-map)

   (let ((map counsel-itunes-prefix-map))
     (define-key map "-" '("Volume Down" . counsel-itunes-volume-down))
     (define-key map "+" '("Volume Up" .  counsel-itunes-volume-up))
     (define-key map "t" '("Tracklist" . counsel-itunes-tracklist))
     (define-key map "p" '("Playlist" . counsel-itunes-playlist))
     (define-key map "c" '("Now Playing" . counsel-itunes-current-track))
     (define-key map "P" '("Playlist" . counsel-itunes-playlist))
     (define-key map "n" '("Next" . counsel-itunes-next-track))
     (define-key map "b" '("Previous" . counsel-itunes-previous-track))
     (define-key map "s" '("Shuffle" . counsel-itunes-shuffle)))
   
  (define-key 'macos-prefix-map (kbd "i") 'counsel-itunes-prefix-map)
  (which-key-add-prefix-title "M-m m i" "iTunes"))

#+END_SRC

**** Counsel Spotify

#+NAME: counsel-spotify-config
#+BEGIN_SRC emacs-lisp :tangle no
(use-package counsel-spotify
  :straight t)
#+END_SRC

**** Counsel Dash

Counsel dash provides a simple wrapper around [[https://github.com/areina/helm-dash][helm-dash]] bindings to provide
ivy integration with dash docsets. This is not great, as installing
=helm-dash= requires installing =helm= itself.

See my [[#macos-dash][implementation]] if you are running macOS, have [[https://kapeli.com/dash][Dash]] installed on
your system, and would like to open docsets natively in the Dash
documentation browser.

#+NAME: counsel-dash-config
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package counsel-dash
    :after (:all counsel)
    :if *is-mac*
    :ensure-system-package
    ("/Applications/Dash.app" . "brew cask install dash"))

#+END_SRC

**** Counsel Codesearch

#+NAME: counsel-codesearch-config
#+BEGIN_SRC emacs-lisp :tangle no
(use-package counsel-codesearch
    :requires codesearch)
#+END_SRC

**** Counsel Tramp

#+NAME: counsel-tramp-config
#+BEGIN_SRC emacs-lisp :tangle no
(use-package counsel-tramp
    :bind
    ("C-c t" . counsel-tramp)
    :init
    (defun straight-recipes-installed (pkg)
      (f-dir? (f-join user-emacs-directory "straight" "build" (symbol-name pkg))))
    (defalias #'package-installed-p #'straight-recipes-installed)
    :after counsel)
#+END_SRC

*** Swiper

#+NAME: mb-swiper
#+BEGIN_SRC emacs-lisp :tangle no
(use-package swiper
    :custom
    (enable-recursive-minibuffers t)
    :bind
    ("\C-s" . swiper))
#+END_SRC

*** Smex

A smart M-x enhancement for Emacs.

#+NAME: mb-smex
#+BEGIN_SRC emacs-lisp :tangle no
(use-package smex
  :after (ivy)
  :init
  (setq-default smex-history-length 32))
#+END_SRC

*** Omnibox

#+NAME: mb-omnibox
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Omnibox
<<omnibox/spec>>
#+END_SRC


#+NAME: omnibox/spec
#+BEGIN_SRC emacs-lisp :tangle no
(use-package omnibox
  :commands omnibox-M-x
  :bind (:map omnibox-mode-map
              ("M-x" . omnibox-M-x)))
#+END_SRC

**** Icons in terminal :disabled:

#+NAME: omnibox/icons
#+BEGIN_SRC emacs-lisp :tangle no
(use-package icons-in-terminal
  :straight nil
  :if (file-directory-p "~/.local/share/icons-in-terminal")
  :load-path "~/.local/share/icons-in-terminal"
  :init
  (when (locate-library "font-lock+")
    (require 'font-lock+)
    (require 'icons-in-terminal))
  :config
  (when (featurep 'all-the-icons)
    (with-eval-after-load 'all-the-icons
      (defun icons-in-terminal-data ()
        (let (result)
          (dolist (icon icons-in-terminal-alist result)
            (setq result
                  (append
                   result
                   (list (cons (symbol-name (car icon)) (cdr icon))))))))


      (setq all-the-icons-data/icons-in-terminal-alist (icons-in-terminal-data))


      (define-icon icon-in-terminal all-the-icons-data/icons-in-terminal-alist "icons-in-terminal"))))

#+END_SRC

* Terminal

#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; With Editor
<<term-with-editor>>
;; Sane Term
<<term-sane>>
;; Xterm
<<term-xterm>>
;; Shell
<<term-shell>>
;; Tramp
<<term-tramp>>
;; Unix
<<term-unix>>
#+END_SRC

** With Editor

#+NAME: terminal-with-editor
#+BEGIN_SRC emacs-lisp :tangle no
(use-package with-editor
  :config
  (progn
    (add-to-hooks #'with-editor-export-editor
                  '(shell-mode-hook
                    term-exec-hook
                    eshell-mode-hook))))
#+END_SRC

** Sane Term

#+NAME: term-sane
#+BEGIN_SRC emacs-lisp :tangle no
(use-package sane-term
  :bind
  (("C-c M-RET t" . sane-term)
   ("C-c M-RET T" . sane-term-create))
  :config
  (when *is-mac*
    (setq sane-term-shell-command "/bin/zsh")))
#+END_SRC

** Compilation Command
*** Colorize Compilation Buffer

See this StackOverflow [[https://stackoverflow.com/a/3072831][ticket]]:

#+NAME: compilation-colors
#+BEGIN_SRC emacs-lisp :tangle yes

(require 'ansi-color)
(defun colorize-compilation-buffer ()
  "Escape ANSI color sequence in the compilation buffer."
  (let ((inhibit-read-only t))
    (ansi-color-apply-on-region (point-min) (point-max))))

(add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
(add-hook 'comint-output-filter-functions 'ansi-color-process-output)

(defun display-ansi-colors ()
  (interactive)
  (ansi-color-apply-on-region (point-min) (point-max)))

(defun display-ansi-file ()
  (when (string= "ansi" (file-name-extension (buffer-file-name)))
    (display-ansi-colors)))

(add-hook 'find-file-hook #'display-ansi-file)
#+END_SRC

** xterm

#+NAME: term-xterm
#+BEGIN_SRC emacs-lisp :tangle no
(xterm-mouse-mode 1)
#+END_SRC

** Run Bash On Windows/PC
- [[https://www.masteringemacs.org/article/running-shells-in-emacs-overview][Mastering Emacs - Running Shells in Emacs]]

#+BEGIN_SRC emacs-lisp :tangle yes
(when *is-windows*
  (progn
    (setq explicit-shell-file-name "C:/path/to/bash.exe"
          shell-file-name "bash"
          explicit-bash.exe-args '("--noediting" "--login" "-i"))
    (setenv "SHELL" shell-file-name)
    (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m)))
#+END_SRC

** Eshell

#+NAME: eshell-spec
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
  ;; Begin Eshell
  ;; eshell bookmark
  <<esh-bookmark>>
  ;; eshell z
  <<esh-z>>
  ;; End Eshell
#+END_SRC

*** Eshell Bookmark

#+NAME: esh-bookmark
#+BEGIN_SRC emacs-lisp :tangle no
(use-package eshell-bookmark
    :config (add-hook 'eshell-mode-hook 'eshell-bookmark-setup))
#+END_SRC

*** Eshell Z

#+NAME: esh-z
#+BEGIN_SRC emacs-lisp :tangle no

(use-package eshell-z
    :init
    (defun eshell-z/enable ()
      (require 'eshell-z))
    :hook
    (eshell-mode . eshell-z/enable))

#+END_SRC

** Shell

#+NAME: term-shell
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; ZSH Shell Fix
<<shell-zsh-macfix>>
;; Shell script style
<<shell-style>>
;; Shell Command to List
<<shell-cmd-to-list>>
#+END_SRC

*** Shell script Indentation
#+NAME: shell-style
#+BEGIN_SRC emacs-lisp :tangle no
(setq sh-basic-offset 2)
#+END_SRC

*** ZSH Macfix

Zsh is whack when running the emacs =shell= function. This fixes that problem.

#+NAME: shell-zsh-macfix
#+BEGIN_SRC emacs-lisp :tangle no
(when *is-mac*
  (setq explicit-shell-file-name "/bin/sh"
	      shell-file-name "sh")
  (setenv "SHELL" shell-file-name))
#+END_SRC

*** Shell Command to list

#+NAME: shell-cmd-to-list
#+BEGIN_SRC emacs-lisp :tangle no
(defun shell-command-to-list (command)
    "Store stdout as an elisp list."
    (interactive "sCommand: " )

    (--> command
         (shell-command-to-string it)
         (split-string it)
         (if (interactive-p)
             (message "%s" it)
           it)))
#+END_SRC

** Remote

*** SSH

#+NAME: ssh-spec
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ssh
    :init
  (defun halidom/ssh-mode-hook ()
    (setq ssh-directory-tracking-mode t)
    (shell-dirtrack-mode t)
    (setq dirtrackp nil))
    :hook (ssh-mode . halidom/ssh-mode-hook))

#+END_SRC

*** SCP

#+NAME: scp-spec
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package scp)
#+END_SRC

** Tramp

#+NAME: term-tramp
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
<<tramp-default>>
<<tramp-any>>
#+END_SRC

*** Default Method

#+NAME: tramp-default
#+BEGIN_SRC emacs-lisp :tangle no
(setq tramp-default-method "ssh")
#+END_SRC

*** Anything Tramp

#+NAME: tramp-any
#+BEGIN_SRC emacs-lisp :tangle no
(use-package anything-tramp
  :bind (("C-c s" . anything-tramp)))
#+END_SRC
x
** Unix Programs
:PROPERTIES:
:ID:       A7B09543-4100-4352-AB2A-3D47BB87B2D9
:END:

#+NAME: term-unix
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
;; Wget
<<unix/wget>>
#+END_SRC

*** Wget

#+NAME: unix/wget
#+BEGIN_SRC emacs-lisp :tangle no
(use-package wget
    :ensure-system-package wget
    :init
    (require 'wget))

#+END_SRC

* Web

#+NAME: web-spec
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Browser
<<web-browser>>
;; Email
<<web-email>>
;; Cloud
<<web-cloud>>
#+END_SRC

** Web Servers and Utilities

#+NAME: emacs-web-serve
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package simple-httpd
    :straight (simple-httpd
               :type git
               :host github
               :repo "skeeto/emacs-web-server"
               :local-repo "simple-httpd"))

(use-package websocket)

(use-package uuidgen)

(use-package web-server)

#+END_SRC

** Browsing

#+NAME: web-browser
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
<<browser-prefix>>
<<browser-xwidget>>
<<browser-url>>
<<browser-macos>>
<<browser-google>>
<<browser-search>>
<<browser-org-advise>>
<<browser-gitremote>>
<<browser-default>>
<<browser-engine>>
#+END_SRC

*** Browser prefix command

#+NAME: browser-prefix
#+BEGIN_SRC emacs-lisp :tangle no
(define-prefix-command 'web-browse-prefix-map)
(define-key 'halidom-prefix-map (kbd "w") 'web-browse-prefix-map)
(which-key-add-prefix-title "M-m w" "Web Browser")

#+END_SRC

*** Webkit xwidget

#+NAME: browser-xwidget
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
<<xwidget-ns>>
<<xwidget-xwidgete>>
#+END_SRC

**** nsxwidget

See [[https://github.com/veshboo/emacs#example-customization-using-xwidget-webkit][veshboo/emacs]].

#+NAME: xwidget-ns
#+BEGIN_SRC emacs-lisp :tangle no
    (use-package xwidget
      :straight nil
      :bind (:map xwidget-webkit-mode-map
                  ("\C-s" . isearch-forward))
      :init/el-patch
      (el-patch-feature xwidget)
      (with-eval-after-load 'xwidget
        (el-patch-defun xwidget-webkit-new-session (url)
          "Create a new webkit session buffer with URL."
          (let*
              ((bufname (generate-new-buffer-name "*xwidget-webkit*"))
               (el-patch-add (inhibit-message t))
               xw)

            (setq xwidget-webkit-last-session-buffer
                  ((el-patch-swap switch-to-buffer switch-to-buffer-other-window)
                   (get-buffer-create bufname)))
            ;; The xwidget id is stored in a text property, so we need to have
            ;; at least character in this buffer.
            ;; Insert invisible url, good default for next `g' to browse url.
            (insert url)
            (put-text-property 1 (+ 1 (length url)) 'invisible t)
            (setq xw (xwidget-insert 1 'webkit bufname
                                     (xwidget-window-inside-pixel-width (selected-window))
                                     (xwidget-window-inside-pixel-height (selected-window))))
            (xwidget-put xw 'callback 'xwidget-webkit-callback)
            (xwidget-webkit-mode)
            (xwidget-webkit-goto-uri (xwidget-webkit-last-session) url))))
      :init
      (when (require 'xwidget)
        (defvar xwidget-webkit-bookmark-jump-new-session) ;; xwidget.el
        (defvar xwidget-webkit-last-session-buffer) ;; xwidget.el

        (require 'bookmark)

        (add-hook 'pre-command-hook
                  (lambda ()
                    (if (eq this-command #'bookmark-bmenu-list)
                        (if-not (eq major-mode 'xwidget-webkit-mode)
                            (setq xwidget-webkit-bookmark-jump-new-session t)
                          (setq xwidget-webkit-bookmark-jump-new-session nil)
                          (setq xwidget-webkit-last-session-buffer
                                (current-buffer))))))

        (defun xwidget-webkit-open-file (&optional file)
          "Render FILE using xwidget-webkit"
          (interactive "fFile: ")
          (xwidget-webkit-browse-url
           (concat "file://"
                   (and (memq system-type '(windows-nt ms-dos)) "/")
                   (expand-file-name (or file (buffer-file-name)))))))
  )
#+END_SRC

**** xwidgete

#+NAME: xwidget-xwidgete
#+BEGIN_SRC emacs-lisp :tangle no
(use-package xwidgete
  :after (xwidget))
#+END_SRC


*** Browse url

- [[https://emacs.stackexchange.com/a/7332][Stack Exchange - How to make eww default browser in emacs]]

#+NAME: browser-url
#+BEGIN_SRC emacs-lisp :tangle no

(use-package browse-url
    :custom (browse-url-chromium-program
             (if *is-mac*
                 "/Applications/Chromium.app/Contents/MacOS/Chromium"
               "chromium"))
  :config
  (progn
    (when (not (display-graphic-p))
      (setq browse-url-browser-function 'eww-browse-url))))

#+END_SRC

*** Browser utilities on macOS

The =osx-browse= library provides several useful commands for using the
Google Chrome, Safari, and Firefox web browsers on macOS.

#+NAME: browser-macos
#+BEGIN_SRC emacs-lisp :tangle no
(use-package osx-browse
  :if *is-mac*
  :defines (osx-browse-mode osx-browse-mode-map)
  :demand t
  :init
  (progn
    (osx-browse-mode 1)))
#+END_SRC

*** Google search at point

#+NAME: browser-google
#+BEGIN_SRC emacs-lisp :tangle no
(defun google-search-query-at-point (&optional edit-query)
  "Search for the expression at point in the default web browser.
If the optional prefix EDIT-QUERY is specified,
the user will be prompted to edit the search string first."
  (interactive "P")
  (let* ((search-prefix "https://google.com/search?q=")
         (thing (if (thing-at-point 'url)
                    (thing-at-point-url-at-point)
                  (concat
                   search-prefix
                   (if (use-region-p)
                       (buffer-substring-no-properties
                        (region-beginning) (region-end))
                     (thing-at-point 'word)))))
         (search (if (or edit-query
                         (and (>= (length thing) (length search-prefix))
                              (string= (substring thing (length search-prefix)) "")))
                     (concat search-prefix
                             (read-from-minibuffer "Search Query: "))
                   thing)))
    (browse-url search)))
#+END_SRC

*** Search Web

#+NAME: browser-search
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package search-web
      :config
    (define-key 'web-browse-prefix-map "s" 'search-web))
#+END_SRC

*** Browse at remote

#+NAME: browser-gitremote
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package browse-at-remote
  :init
  (progn
    (if *is-mac*
        (when (fboundp 'osx-browse-url-chrome)
          (setq browse-url-browser-function 'osx-browse-url-chrome)))))
#+END_SRC

*** Set default browser

Interactively.

#+NAME: browse-default
#+BEGIN_SRC emacs-lisp :tangle yes
(defvar browse-url-browser-alist
      '(("chrome" . browse-url-chrome)
        ("firefox" . browse-url-firefox)
        ("eww" . eww-browse-url)
        ("xwidget-webkit" . xwidget-webkit-browse-url)))

(if *is-mac*
    (progn
      (setf (cdr (assoc "chrome" browse-url-browser-alist))
            #'osx-browse-url-chrome)
      (setf (cdr (assoc "firefox" browse-url-browser-alist))
            #'osx-browse-url-firefox)
      (add-to-list 'browse-url-browser-alist
                   '("safari" . osx-browse-url-safari))))

(defun set-browser-function (browser)
  "Interactively set the browser used by `browse-url'. "
  (interactive
   (list (completing-read "Browser: " browse-url-browser-alist)))
  (when-let ((browser-function (cdr (assoc browser browse-url-browser-alist))))
    (setq browse-url-browser-function browser-function)))
(define-key 'web-browse-prefix-map "B" 'set-browser-function)

  (which-key-add-key-based-replacements "M-m w B" '( "Configure" . "Set the default browser" ))

(cl-defun make-browser-function (browser)
  `(defun ,(intern (concat "set-browser-function-" browser)) ()
     (interactive)
     (set-browser-function ,browser)))

(defmacro make-browser-functions (browsers)
  `(progn ,@(mapcar 'make-browser-function browsers)))


(eval `(make-browser-functions ,(mapcar 'car browse-url-browser-alist)))

(define-prefix-command 'web-browse-browser-prefix-map)

(let ((map web-browse-browser-prefix-map))
  (define-key map "c" 'set-browser-function-chrome)
  (define-key map "e" 'set-browser-function-eww)
  (define-key map "f" 'set-browser-function-firefox)
  (define-key map "s" 'set-browser-function-safari)
  (define-key map "x" 'set-browser-function-xwidget-webkit))

(define-key 'web-browse-prefix-map "b" 'web-browse-browser-prefix-map)


#+END_SRC

*** Engine Mode

#+NAME: browser-engine
#+BEGIN_SRC emacs-lisp :tangle no
(use-package engine-mode
  :init
  (engine-mode t)

  :config

  (setq halidom-web-engine-prefix "M-m w e")

  (when engine/keybinding-prefix
    (define-key engine-mode-map (kbd "C-x /") nil)
    (define-key 'web-browse-prefix-map "e" engine-mode-prefixed-map))

  (defengine cassi
    "http://cassi.cas.org/search.jsp")

  (defengine ctan
    "http://www.ctan.org/search/?x=1&PORTAL=on&phrase=%s"
    :keybinding "c"
    :docstring "Search the Comprehensive TeX Archive Network (ctan.org)")

  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
    :keybinding "h"
    :docstring "Search Github")

  (defengine google
    "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
    :keybinding "g"
    :docstring "Search Google")

  (defengine google-bookmarks
    "chrome://bookmarks/?q=%s"
    :keybinding "Gb"
    :docstring "Search bookmarks in Google Chrome")

  (defengine google-images
    "http://www.google.com/images?hl=en&source=hp&biw=1440&bih=795&gbv=2&aq=f&aqi=&aql=&oq=&q=%s"
    :keybinding "Gi"
    :docstring "Search google-images")

  (defengine google-maps
    "http://maps.google.com/maps?q=%s"
    :keybinding "Gm"
    :docstring "Mappin' it up.")

  (defengine google-schoolar
    "http://scholar.google.com/scholar?q=%s"
    :keybinding "Gs"
    :docstring "Schoolin'it up.")

  (defengine project-gutenberg
    "http://www.gutenberg.org/ebooks/search/?query=%s"
    :docstring "Read good")

  (defengine proquest
    "https://search.proquest.com"
    :keybinding "p"
    :docstring "Search Proquest")

  (defengine rfcs
    "http://pretty-rfc.herokuapp.com/search?q=%s")

  (defengine stack-overflow
    "https://stackoverflow.com/search?q=%s"
    :keybinding "s"
    :docstring "Search StackOverflow.")

  (defengine twitter
    "https://twitter.com/search?q=%s")

  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w"
    :docstring "Search wikipedia.")

  (defengine wiktionary
    "https://www.wikipedia.org/search-redirect.php?family=wiktionary&language=en&go=Go&search=%s")

  (defengine wolfram-alpha
    "http://www.wolframalpha.com/input/?i=%s"
    :keybinding "a"
    :docstring "Search Wolfram Alfa")

  (defengine worldcat
    "https://ucla.worldcat.org/search?q=%s"
    :keybinding "W"
    :docstring "Search Worldcat"
    :browser 'osx-browse-url-chrome)

  (defengine youtube
    "http://www.youtube.com/results?aq=f&oq=&search_query=%s"
    :keybinding "y"
    :docstring "Search Youtube")

  :config

  (when *is-mac*
    (cl-flet* ((ks (&rest k)
                   (let ((p halidom-web-engine-prefix))
                     (if k (join (push p k) " ") p)))
               (wkr (rep &rest k)
                    (let ((kk (apply #'ks k)))
                      (which-key-add-key-based-replacements kk rep))))
      (wkr "Search Engine")
      (wkr " Google" "G")
      (wkr " Images" "G" "i")
      (wkr " Bookmarks" "G" "b")
      (wkr " Maps" "G" "m")
      (wkr " Scholar" "G" "s"))))
#+END_SRC

** Email

#+NAME: web-email
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Offline imap
<<mail/imap>>
;; Mu
<<mail/mu>>
#+END_SRC

*** Offlineimap

#+NAME: mail/imap
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package offlineimap)
#+END_SRC

*** Mu

#+NAME: mail/mu
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Mu4e
<<mu-mu4e>>
;; Mu4e Alert
<<mu-alert>>
;; Mu4e Maildirs extension
<<mu-maildirs>>
#+END_SRC

**** Mu4e

#+NAME: mu-mu4e
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package mu4e
      :straight nil
      :load-path "/usr/local/opt/mu/share/emacs/site-lisp/mu/mu4e"
      :init
      (require 'mu4e)

      :config
      ;; use mu4e for email in emacs
      (setq mail-user-agent 'mu4e-user-agent)

      (setq mu4e-maildir "~/.mail")

      ;; Update with offlineimap
      (setq mu4e-get-mail-command "offlineimap -o -q")

      ;; Let GMAIL/IMAP take care of sent messages
      (setq mu4e-sent-messages-behavior 'delete)

      (require 'smtpmail)

       ;; smtp settings
      (setq message-send-mail-function 'smtpmail-send-it
            smtpmail-stream-type 'starttls
            smtpmail-default-smtp-server "smtp.gmail.com"
            smtpmail-smtp-server "smtp.gmail.com"
            smtpmail-smtp-service 587)

      ;; Kill message buffers on send
      (setq message-kill-buffer-on-exit t)

      ;; mu4e View
      (setq mu4e-attachment-dir "~/Downloads"
            mu4e-view-show-images t
            mu4e-show-addresses t
            mu4e-view-prefer-html t
            mu4e-view-show-images t)


      (when (fboundp 'imagemagick-register-types)
        (imagemagick-register-types))

      (setq mu4e-completing-read-function 'ivy-completing-read)

      ;; Mu4e Contexts
      (setq mu4e-context-policy 'pick-first
            mu4e-compose-context-policy 'ask-if-none)

      (setq mu4e-contexts
            `(,(make-mu4e-context
                :name "personal"
                :enter-func
                (lambda () (mu4e-message "Using Personal gmail account.k"))
                :leave-func
                (lambda () (mu4e-message "leaving Personal gmail account."))
                :match-func
                (lambda (msg)
                  (when msg
                    (string-match-p "^/personal")
                    (mu4e-message-field msg :maildir)))
                :vars
                '((user-mail-address  . "jchaffin57@gmail.com")
                  (user-full-name     . "Jacob Chaffin")
                  (mail-reply-to      . "jchaffin57@gmail.com")
                  (smtpmail-smtp-user . "jchaffin57@gmail.com")
                  (mu4e-sent-folder   . "/personal/sent")
                  (mu4e-drafts-folder . "/personal/drafts")
                  (mu4e-refile-folder . "/personal/archive")
                  (mu4e-trash-folder  . "/personal/trash")
                  (mu4e-compose-signature .
                   (concat
                    "Jacob Chaffin\n"
                    "jchaffin57@gmail.com\n"
                    "jchaffin@ucla.edu"))))

               ,(make-mu4e-context
                 :name "school"
                 :enter-func
                 (lambda () (mu4e-message "Entering UCLA Gmail account"))
                 :leave-func
                 (lambda () (mu4e-message "Leaving UCLA Gmail account."))
                 :match-func
                 (lambda (msg)
                   (when msg
                     (string-match-p "^/school"
                     (mu4e-message-field msg :maildir))))
                 :vars '((user-mail-address  . "jchaffin@ucla.edu")
                         (user-full-name     . "Jacob Chaffin")
                         (mail-reply-to      . "jchaffin@ucla.edu" )
                         (smtpmail-smtp-user . "jchaffin@g.ucla.edu")
                         (mu4e-drafts-folder . "/school/drafts")
                         (mu4e-sent-folder   . "/school/sent")
                         (mu4e-refile-folder . "/school/archive")
                         (mu4e-trash-folder  . "/school/trash")
                         (mu4e-compose-signature .
                          (concat
                           "Jacob Chaffin\n"
                           "UCLA 2019\n"
                           "Linguistics and Computer Science\n"
                           "jchaffin@ucla.edu"))))))

      ;; From [[https://www.djcbsoftware.nl/code/mu/mu4e/Some-context-tricks.html#Some-context-tricks][9.5 - Some Context Tricks]]
      ;; This sets `mu4e-user-mail-address-list' to the concatenation of all
      ;; `user-mail-address' values for all contexts. If you have other mail
      ;; addresses as well, you'll need to add those manually.
      (setq mu4e-user-mail-address-list
            (delq nil
                  (mapcar (lambda (context)
                            (when (mu4e-context-vars context)
                              (cdr
                               (assq
                                'user-mail-address
                                (mu4e-context-vars context)))))
                          mu4e-contexts)))


      (require 'gnus-dired)

      (defun gnus-dired-mail-buffers ()
        "Return a list of active message buffers."
        (let ((buffers))
          (save-current-buffer
            (dolist (buffer (buffer-list t))
              (set-buffer buffer)
              (when (and (derived-mode-p 'message-mode)
                         (null message-sent-message-via))
                (push (buffer-name buffers) buffers))))
          (nreverse buffers)))

      (setq gnus-dired-mail-mode 'mu4e-user-agent)

      (add-hook 'dired-mode-hook 'turn-on-gnus-dired-mode))
#+END_SRC


**** Mu Notifications

#+NAME: mu-alert
#+BEGIN_SRC emacs-lisp :tangle no
(use-package mu4e-alert
    :config
    (mu4e-alert-enable-notifications)
    (mu4e-alert-enable-mode-line-display))
#+END_SRC

**** Mu4e Maildirs Extension

#+NAME: mu-maildirs
#+BEGIN_SRC emacs-lisp :tangle no
(use-package mu4e-maildirs-extension
    :after mu4e
    :init
    (mu4e-maildirs-extension-load))
#+END_SRC

** Cloud Integration

#+NAME: web-cloud
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
<<cloud-onenote>>
#+END_SRC

*** Org OneNote

Work account is for office portal, not a Microsoft account. I need integration or authorization via office.

#+NAME: cloud-onenote
#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-onenote
  :init 
  (require 'secrets)
  (require 'org-onenote)
  :custom
  (org-onenote-token-file
   (emacs-etc-dir "org-onenote-oauth2.plstore")))
#+END_SRC

* Prose

#+NAME: prose-spec
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Spellcheck
<<prose/spellcheck>>
;; Completion
<<prose/completion>>
;; Notes
<<prose/notes>>
;; Readview
<<prose/readview>>
#+END_SRC

** Spelling and Grammar

#+NAME: prose/spellcheck
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Flyspell
<<sc-flyspell>>
;; Langtool
<<sc-langtool>>
;; Academic
<<sc-academic>>
;; Proselint
<<sc-proselint>>
#+END_SRC

Tools for checking lexical and grammatical errors in text
buffers[fn:17].

*** Flyspell

#+NAME: sc-flyspell
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
<<flyspell-base>>
<<flyspell-correct-config>>
#+END_SRC

#+NAME: flyspell-base
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package flyspell
    :init
    (with-eval-after-load 'org
      (add-hook 'org-mode-hook 'flyspell-mode))
    :config
    (progn
      (when (executable-find "hunspell")
        (setq-default ispell-program-name "hunspell")
        (setq-default ispell-dictionary "en_US")
        (setq ispell-really-hunspell t))))
#+END_SRC

**** Flyspell Correct

#+NAME: flyspell-correct-config
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package flyspell-correct-ivy
    :after (:all flyspell ivy)
    :demand t
    :config
    (define-key flyspell-mode-map (kbd "C-;") 'flyspell-correct-previous-word-generic))
#+END_SRC

*** Langtool

LanguageTool is a Java plugin which provides style and grammar
checking for natural language.

#+NAME: sc-langtool
#+BEGIN_SRC emacs-lisp :tangle no
(use-package langtool
  :if *is-mac*
  :after (flyspell)
  :demand t
  :config
  (progn
    (setq langtool-language-tool-jar "/usr/local/opt/languagetool/libexec/languagetool-commandline.jar"
          langtool-mother-tongue "en"
          langtool-disabled-rules '("WHITESPACE_RULE"))))
#+END_SRC

*** Academic Phrases

#+NAME: sc-academic
#+BEGIN_SRC emacs-lisp :tangle no
(use-package academic-phrases)
#+END_SRC

*** Proselint

#+NAME: sc-proselint
#+BEGIN_SRC emacs-lisp :tangle no
  (with-eval-after-load 'flycheck
    (flycheck-define-checker proselint
                             "A linter for prose."
                             :command ("proselint" source-inplace)
                             :error-patterns
                             ((warning line-start (file-name) ":" line ":" column ": "
                                       (id (one-or-more (not (any " "))))
                                       (message) line-end))
                             :modes (text-mode org-mode markdown-mode gfm-mode))
    (add-to-list 'flycheck-checkers 'proselint))

#+END_SRC

** Text Completion

#+NAME: prose/completion
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Company Dictionary
<<completion/company-dict>>
;; Dictionary.el
<<completion/dictionary-el>>
#+END_SRC

*** Company Dict

#+NAME: completion/company-dict
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-dict
  :after (company)
  :demand t
  :init
  (add-to-list 'company-backends 'company-dict)
  :config
  (setq company-dict-enable-fuzzy t
        company-dict-enable-yasnippet t))
#+END_SRC

*** Dictionary.el
:PROPERTIES:
:ID:       98EF59F6-66E8-47B3-A437-B1D53A74832A
:CUSTOM_ID: dictionary-el
:END:

The [[https://github.com/myrkr/dictionary-el][dictionary.el]] package provides an Emacs client which uses an open source
dictionary server to lookup words. What it lacks in bells and
whistles, it makes up for in compatibility and hackability [fn:18].

#+NAME: completion/dictionary-el
#+BEGIN_SRC emacs-lisp :tangle no
(use-package dictionary
  :commands (dictionary-lookup-definition)
  :init
  (define-prefix-command 'dictionary-keymap))
#+END_SRC

** Taking Notes

#+NAME: prose/notes
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Deft
<<notes/deft>>
;; Lorem Ipsum
<<notes/lorem-ipsum>>
;; Org Velocity
<<notes/veocity>>
#+END_SRC

*** Deft

[[https://jblevins.org/projects/deft/][Deft]] is a notetaking application for Emacs.

#+NAME: notes/deft
#+BEGIN_SRC emacs-lisp :tangle no :comments org
(use-package deft
  :if *is-mac*
  :bind ("C-x C-n" . deft)
  :config
  (progn
    (setq deft-extensions '("org")
          deft-directory "~/Dropbox/org/notes/"
          deft-use-filename-as-title t
          deft-default-extension "org")))
#+END_SRC

*** Lorem Ipsum

#+NAME: notes/lorem-ipsum
#+BEGIN_SRC emacs-lisp :tangle no
(use-package lorem-ipsum
  :straight t)
#+END_SRC

*** Org Velocity

#+NAME: notes/velocity
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package org-velocity
    :straight org
    :bind
    (("C-c n" . org-velocity))
    :demand t
    :custom
    (org-velocity-bucket (expand-file-name "bucket.org" org-directory))
    :init
  (require 'org-velocity))
#+END_SRC

** Writing mode

#+NAME: prose-writing
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
;; Olivetti Mode
<<writing-olivetti>>
;; Writeroom Mode
<<writing-writeroom>>
;: Org Variable Pitch Face Font
<<writing-variable-pitch>>
;; Typo Mode
<<writing-typo>>
;; Write good mode
<<writing-writegood>>
#+END_SRC

*** Typo Mode
#+NAME: writing-typo
#+BEGIN_SRC emacs-lisp :tangle no
 (use-package typo)
#+END_SRC

*** Writegood

#+BEGIN_SRC emacs-lisp :tangle no
 (use-package writegood-mode)
#+END_SRC

*** Variable Pitch

#+NAME: writing-variable-pitch
#+BEGIN_SRC emacs-lisp :tangle no
  (defcustom halidom-org-fixed-pitch-faces
    '(org-table
      org-code
      org-special-keyword
      org-verbatim
      org-meta-line
      org-block
      org-block-begin-line
      org-block-end-line
      org-document-info-keyword)
    "Faces to keep fixed-width when using ‘org-variable-pitch-minor-mode’."
    :type '(list symbol))

  (defvar org-fixed-pitch-font
    (face-attribute 'fixed-pitch :family))

  (defvar org-variable-pitch-font
    (face-attribute 'variable-pitch :family))

  (setq org-fixed-pitch-font "Iosevka")
  (setq org-variable-pitch-font "ETBembo")

  (setq face-remapping-alist nil)

  (defun org-toggle-variable-pitch ()
    "Toggle use of face `variable-pitch'.
  This works by frobbing `face-remapping-alist'."
    (interactive)
    (if face-remapping-alist
        (setq face-remapping-alist nil)
      (face-remap-add-relative 'variable-pitch
                               :family org-variable-pitch-font)
      (face-remap-add-relative 'default 'variable-pitch)
      (->> halidom-org-fixed-pitch-faces
          (mapcar (lambda (x) (list x :family org-fixed-pitch-font)))
          (mapcar (lambda (x) (apply #'face-remap-add-relative x))))))
#+END_SRC

*** Olivetti

#+NAME:  writing-olivetti
#+BEGIN_SRC emacs-lisp :tangle no

(use-package olivetti
  :init
  (defun halidom/olivetti-setup ()
    (auto-fill-mode -1)
    (when (fboundp 'centered-cursor-mode)
      (centered-cursor-mode)))
  :hook
  (olivetti-mode . halidom/olivetti-setup))

#+END_SRC

*** Writeroom

#+NAME: writing-writeroom
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package writeroom-mode
    :config
    (defun halidom/writeroom-mode-hook ()
      (org-toggle-variable-pitch)
      (auto-fill-mode -1))
    (add-hook 'writeroom-mode #'halidom/writeroom-mode-hook))
#+END_SRC

** Reading and viewing

#+NAME: prose/readview
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Justify Kp
<<readview-justify>>
;; Nov
<<readview-epub>>
;; Visual Fill Column
<<readview-fc>>
;; Fill Column Indicator
<<readview-fc-indicator>>
;; Adaptive Wrap
<<readview-adaptive-wrap>>
#+END_SRC

*** Justify Kp

#+NAME: readview-justify
#+BEGIN_SRC emacs-lisp :tangle no
(use-package justify-kp
  :straight (:host github
                   :repo "Fuco1/justify-kp"))
#+END_SRC

*** Nov

[[https://github.com/wasamasa/nov.el][Nov.el]] is a major mode for reading EPUB documents in Emacs.

#+NAME: readview-epub
#+BEGIN_SRC emacs-lisp :tangle no
(use-package nov
  :mode (("\\.epub\\'" . nov-mode))
  :config
  (progn

    (require 'justify-kp)


    (defun nov-setup ()
      (face-remap-add-relative 'variable-pitch
                               :family "Bookmania")
      (visual-line-mode 1)
      (visual-fill-column-mode 1)

      (setq nov-text-width most-positive-fixnum
            visual-fill-column-center-text t))

    (defun my-nov-window-configuration-change-hook ()
      (my-nov-post-html-render-hook)
      (remove-hook 'window-configuration-change-hook
                   'my-nov-window-configuration-change-hook t))

    (defun my-nov-post-html-render-hook ()
      (if (get-buffer-window)
          (let ((max-width (pj-line-width))
                buffer-read-only)
            (save-excursion
              (goto-char (point-min))
              (while (not (eobp))
                (when (not (looking-at "^[[:space:]]*$"))
                  (goto-char (line-end-position))
                  (when (> (shr-pixel-column) max-width)
                    (goto-char (line-beginning-position))
                    (pj-justify)))
                (forward-line 1))))
        (add-hook 'window-configuration-change-hook
                  'my-nov-window-configuration-change-hook
                  nil t)))


    (add-hook 'nov-mode-hook 'nov-setup)
    (add-hook 'nov-post-html-render-hook 'my-nov-post-html-render-hook)))
#+END_SRC

*** Visual Fill Column

#+NAME: readview-fc
#+BEGIN_SRC emacs-lisp :tangle no
(use-package visual-fill-column
    :commands (visual-fill-column-mode)
    :init
    (defvar visual-fill-column-use-visual-line nil
      "Enable `visual-line-mode' when `visual-fill-column-mode' is non-nil.")
    :config
    (advice-add 'text-scale-adjust :after #'visual-fill-column-adjust)
    (setq split-window-preferred-function
          #'visual-fill-column-split-window-sensibly)

    (setq visual-fill-column-width
          ;; take Emacs 26 line numbers into account
          (+ (if (boundp 'display-line-numbers) 6 0)
             fill-column))

    (unless visual-fill-column-use-visual-line
        (add-hook 'visual-fill-column-mode-hook #'visual-line-mode)))

#+END_SRC

*** Fill Column Indicator

#+NAME: readview-fc-indicator
#+BEGIN_SRC emacs-lisp :tangle no
(use-package fill-column-indicator
  :init
  (setq fci-rule-use-dashes nil))
#+END_SRC

*** Adaptive Wrap

#+NAME: readview-adaptive-wrap
#+BEGIN_SRC emacs-lisp :tangle no
(use-package adaptive-wrap
  :straight t)
#+END_SRC

** Graphics
*** Artist Mode

Artist mode is a built-in Emacs package.

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package artist-mode
  :straight nil
  :bind ((:map artist-mode-map
               ("C-c C-a p" . artist-select-op-pen-line))))
#+END_SRC

*** UML Diagrams

#+NAME: uml-spec
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
<<uml-ditaa>>
<<uml-plantuml>>
#+END_SRC

**** Ditaa

#+NAME: uml-ditaa
#+BEGIN_SRC emacs-lisp :tangle no

(when (and *is-mac*
           (executable-find "brew")
           (executable-find "ditaa"))
  (let ((ditaa-path (replace-regexp-in-string
                     "\n"  ""
                     (shell-command-to-string
                      "realpath $(brew --prefix ditaa)/libexec/*.jar"))))
    (setq org-ditaa-jar-path ditaa-path)))

#+END_SRC

**** PlantUML

#+NAME: uml-plantuml
#+BEGIN_SRC emacs-lisp :tangle no
(use-package plantuml-mode
  :if (executable-find "plantuml")
  :defines (org-plantuml-jar-path plantuml-jar-path)
  :config
  (progn
    (defun halidom/plantuml-resolve-jar-path ()
      (when (executable-find "plantuml")
        (replace-regexp-in-string "\n" ""
                                  (shell-command-to-string
                                   "realpath $(brew --prefix plantuml)/libexec/plantuml.jar"))))
      (when *is-mac*
        (setq org-plantuml-jar-path (halidom/plantuml-resolve-jar-path))
        (setq plantuml-jar-path (halidom/plantuml-resolve-jar-path)))))
#+END_SRC

*** Graphviz

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package graphviz-dot-mode
  :if (executable-find "dot")
  :mode "\\.dot\\'"
  :defines graphiz-dot-program-set
  :bind ((:map graphviz-dot-mode-map
               ("M-s g" . graphviz-dot-program-set)))
  :config
  (defun graphviz-dot-program-set (&optional program)
    "Set the process for `graphviz-dot-dot-program' interactively."
    (interactive)
    (let ((dot-program (or program (completing-read "Process: " graphviz-dot-layout-programs))))
      (setq graphviz-dot-dot-program dot-program)))

  (defun halidom/graphviz-dot-mode-setup ()
    "Setup graphviz dot mode."
    (define-key graphviz-dot-mode-map "{" nil)
    (define-key graphviz-dot-mode-map "}" nil)
    (add-to-list 'org-babel-load-languages '(dot . t))
    (setq org-src-lang-modes
          (append '(("dot" . graphviz-dot))
                  (delete '("dot" . fundamental) org-src-lang-modes))))

  (with-eval-after-load 'graphviz-dot-mode
    (halidom/graphviz-dot-mode-setup)))

#+END_SRC

*** Thesaurus

This library needs to allow setting transfer protocol on the user
end. It's hardcoded to use port 80. HTTP doesn't really work on my
school's WLAN.

#+BEGIN_SRC emacs-lisp :tangle yes

(use-package thesaurus
  :config
  (progn
    ;; `thesaurus-bhl-api-key' is set in secrets
    (setq thesaurus-prompt-mechanism 'counsel-imenu
          url-proxy-services nil)))

#+END_SRC

* Code
** LSP

#+NAME: lsp-spec
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
;; LSP Mode
<<lsp/mode>>
;; LSP UI Mode
<<lsp/ui-mode>>
;; Company LSP
<<lsp/company>>
#+END_SRC

*** LSP Mode

#+NAME: lsp/mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package lsp-mode
  :custom
  (lsp-inhibit-message t)
  (lsp-message-project-root-warning t)
  (lsp-project-blacklist '("^/ssh:" "node_modules"))
  :config

  (require 'lsp-imenu)
  (add-hook 'lsp-after-open-hook 'lsp-enable-imenu)

  (defun lsp/set-projectile-root ()
    (when lsp--cur-workspace
      (setq projectile-project-root (lsp--workspace-root lsp--cur-workspace))))

  (add-hook 'lsp-before-open-hook 'lsp/set-projectile-root)

  (defun lsp/save-file-immediately ()
    (when lsp--cur-workspace
      (save-buffer)))

  (add-hook 'lsp-after-open-hook 'lsp/save-file-immediately))
#+END_SRC

*** LSP UI Mode

#+NAME: lsp/ui-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package lsp-ui
    :bind
    (:map lsp-ui-mode-map
     ([remap xref-find-definitions] . lsp-ui-peek-find-definitions)
     ([remap xref-find-references]  . lsp-ui-peek-find-references))

    :custom
    (lsp-ui-doc-include-signature nil)
    (lsp-ui-doc-header t)
    (lsp-ui-doc-max-width 100)
    (lsp-ui-sideline-show-symbol nil)

    :hook (lsp-mode . lsp-ui-mode))

#+END_SRC

*** Company LSP

#+NAME: lsp/company
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-lsp
    :after company
    :demand t
    :init
    (push 'company-lsp company-backends)

    :custom
    (company-transformers nil)
    (company-lsp-async t)
    (company-lsp-cache-candidates nil))
#+END_SRC

** Flycheck

#+NAME: flycheck-spec
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flycheck
      :custom
      (flycheck-global-modes nil)
      (flycheck-disabled-checkers '(emacs-lisp-checkdoc))
      (flycheck-emacs-lisp-load-path 'inherit)
      :init
      (defun halidom/flycheck-enable (mode)
        "Use flycheck in MODE."
        (push mode flycheck-global-modes))

      (defun halidom/flycheck-enable-hook ()
        "Enable Flycheck as a hook."
        (when (fboundp 'flycheck-mode)
          (flycheck-mode +1)))

      (defun halidom/toggle-flycheck-error-list ()
        "Toggle flycheck's error list window.
  If the error list is visible, hide the window.
  Else display the buffer."
        (interactive)
        (-if-let (window (flycheck-get-error-list-window))
            (quit-window nil window)
          (flycheck-list-errors)))

      (defun halidom/goto-flycheck-error-list ()
        "Open and go to the error list buffer."
        (interactive)
        (unless (get-buffer-window
                 (get-buffer flycheck-error-list-buffer))
          (flycheck-list-errors)
          (switch-to-buffer-other-window
           flycheck-error-list-buffer))))
#+END_SRC

** Code Style
*** Default

#+NAME: code/default
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Disable Tabs
<<default/notabs>>
;; Display line numbers
<<default/linenos>>
#+END_SRC

**** Disable tabs

#+NAME: default/notabs
#+BEGIN_SRC emacs-lisp :tangle no
(setq-default tab-width 2
              indent-tabs-mode nil)
#+END_SRC

**** Display Line Numbers

#+NAME: default/linenos
#+BEGIN_SRC emacs-lisp :tangle no
  ; Line Numbering
  (when (>= emacs-major-version 26)
    (add-hook 'prog-mode-hook #'display-line-numbers-mode))

#+END_SRC

*** Hy mode

#+NAME: code/hy
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package hy-mode)
#+END_SRC

*** Highlight Indentation

#+NAME: code/indent
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Highlight indent guides
<<hli/guides>>
;; Highlight Indentation
<<hli/indentation>>
;; Visual Indentation
<<hli/visual>>
#+END_SRC

**** Highlight indent guide mode

#+NAME: hli/guides
#+BEGIN_SRC emacs-lisp :tangle no
(use-package highlight-indent-guides)
#+END_SRC

**** Highlight indentation

#+NAME: hli/indentation
#+BEGIN_SRC emacs-lisp :tangle no
(use-package highlight-indentation)

#+END_SRC

**** Visual indentation

#+NAME: hli/visual
#+BEGIN_SRC emacs-lisp :tangle no
(use-package visual-indentation-mode)
#+END_SRC

*** Symbol Highlighting

#+NAME: symbol-hl
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Overlay Highlight
<<hl-ov>>
;; Highlight Sexp
<<hl-hl-sexp>>
;; Highlight Todos
<<hl-hl-todo>>
;; Highlight Symbol
<<hl-highlight-symbol>>
#+END_SRC

**** Highlight :disabled:

#+NAME: hl-highlight
#+BEGIN_SRC emacs-lisp :tangle no
(use-package highlight)
#+END_SRC

**** Overlay Highlight

#+NAME: hl-ov
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ov-highlight
  :straight (ov-highlight
             :host github
             :repo "jkitchin/ov-highlight")
  :after ov)
#+END_SRC

**** Hlsexp

Minor mode to highlight sexp.

#+NAME: hl-hl-sexp
#+BEGIN_SRC emacs-lisp :tangle no
(use-package highlight-sexp
  :straight t)
#+END_SRC

**** Hl Todo

Highlight =TODO= keywords:

#+NAME: hl-hl-todo
#+BEGIN_SRC emacs-lisp :tangle no
(use-package hl-todo
  :commands (hl-todo-mode)
  :config
  (add-hook 'prog-mode-hook #'hl-todo-mode))
#+END_SRC

**** Highlight Symbol

#+NAME: hl-highlight-symbol
#+BEGIN_SRC emacs-lisp :tangle no
(use-package highlight-symbol)
#+END_SRC

*** Code Folding

#+NAME: code/fold
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Origami
<<fold/origami>>
;; Hideshow
<<fold/hs>>
;; Hideshowvis
<<fold/hsvis>>
#+END_SRC

**** Origami

#+NAME: fold/origami
#+BEGIN_SRC emacs-lisp :tangle no
(use-package origami
  :requires (dash s)
  :init
  (global-origami-mode nil))
#+END_SRC

**** Hideshow

#+NAME: fold/hs
#+BEGIN_SRC emacs-lisp :tangle no
(use-package hideshow
    :straight nil)
#+END_SRC

**** Hideshowvis

#+NAME: fold/hsvis
#+BEGIN_SRC emacs-lisp :tangle no
(use-package vimish-fold
    :init
  (vimish-fold-global-mode 1))

(use-package hideshowvis
    :init
  (defface halidom-folded-face
      `((((background light)) :background ,(plist-get halidom-theme-colors :base00))
        (((background dark)) :background ,(plist-get halidom-theme-colors :base03)))
    "Face to highlight `hideshow' overlays.")

  (setq hs-set-up-overlay
        (lambda (ov)
          (when (eq 'code (overlay-get ov 'hs))
            (when (featurep 'vimish-fold)
              (overlay-put
               ov 'before-string
               (propertize "..." 'display (list vimish-fold-indication-mode
                                                'empty-line
                                                'vimish-fold-fringe))))
            (overlay-put
             ov 'display (propertize " [...] " 'face 'halidom-folded-face)))))

  (defun hideshowvis/enable ()
    (hideshowvis-minor-mode 1))
  :hook
  (prog-mode . hideshowvis/enable))

#+END_SRC

*** Editorconfig

#+BEGIN_SRC emacs-lisp :tangle yes
;; Editorconfig
(use-package editorconfig
  :if (executable-find "editorconfig")
  :init (editorconfig-mode 1))
#+END_SRC

*** Google C Style

#+NAME: google-c-styleguide
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package google-c-style
  :straight
  (google-c-style
   :host github
   :repo "google/styleguide"
   :branch "gh-pages")
  :init
  (defun halidom/google-c-style ()
    (google-set-c-style)
    (google-make-newline-indent))
  :hook
  (c++-mode . halidom/google-c-style)
  (java-mode . halidom/google-c-style))
#+END_SRC

*** Code Formatting

#+NAME: tools-code-format
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package format-all)
#+END_SRC

** Code Completion
*** Pair Matching
**** Paredit

We could use ~:init~ key to hook the ~enable-paredit-mode~
function to each of the implementing languages like is
done [[https://github.com/tomjakubowski/.emacs.d/blob/master/init.el][here]], but I think adding the hook in the configuration
block of the programming language is easier to follow and
offers more meaningful semantics.

#+NAME: paredit-spec
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package paredit
  :config
  (progn
    (use-package eldoc
      :config
      (eldoc-add-command
       'paredit-backward-delete
       'paredit-close-round))

    (autoload 'enable-paredit-mode "paredit"
      "Turn on pseudo-structural editing of Lisp code." t)))
   #+END_SRC

**** Smartparens

Like paredit, [[https://github.com/Fuco1/smartparens][smartparens]] is a minor-mode for managing parens
pairs. However, it also offers support for curly brackets in
JavaScript objects, angle brackets in HTML, and most other major
programming languages. I think I the "delete-on-command" behavior of
paredit for lisp programming, but in languages where locating
unmatched pairs is less comparable to searching for a needle in a
haystack, =smartparens= are a great productivity tool.

#+NAME: smartparens-config
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package smartparens
  :init
  (progn
    (require 'smartparens-config)
    (smartparens-global-mode)

    (defun sp-wrap-inline-math ()
      "Wrap marked region as ordinary LaTeX inline math mode."
      (interactive)
      (sp-wrap-with-pair "$"))

    (defun disable-smartparens ()
      "Disable smartparens when `paredit-mode' is enabled."
      (smartparens-mode -1))

    (when (fboundp 'paredit-mode)
      (add-hook 'paredit-mode-hook #'disable-smartparens))))
#+END_SRC

**** Rainbow Delimiters

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :init
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

**** Parinfer

Disabling for now.

#+NAME: parinfer-config
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
; Lispy
<<lispy-config>>
;; parinfer
<<parinfer-base>>
#+END_SRC

#+NAME: parinfer-base
#+BEGIN_SRC emacs-lisp :tangle no
(use-package parinfer
  :bind
  (("C-," . parinfer-toggle-mode))
  :init
  (progn
    (setq parinfer-extensions
          '(defaults       ; should be included.
             pretty-parens  ; different paren styles for different modes.
             ;; evil           ; If you use Evil.
             lispy          ; If you use Lispy. With this extension, you should install Lispy and do not enable lispy-mode directly.
             paredit        ; Introduce some paredit commands.
             smart-tab      ; C-b & C-f jump positions and smart shift with tab & S-tab.
             smart-yank))   ; Yank behavior depend on mode.
    (add-hook 'clojure-mode-hook #'parinfer-mode)
    (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
    (add-hook 'common-lisp-mode-hook #'parinfer-mode)
    (add-hook 'scheme-mode-hook #'parinfer-mode)
    (add-hook 'lisp-mode-hook #'parinfer-mode)))
#+END_SRC

***** Lispy

#+NAME: lispy-config
#+BEGIN_SRC emacs-lisp :tangle no
(use-package lispy
  :defer t)
#+END_SRC

*** Gtags
:PROPERTIES:
:ID:       0E4B8051-2EB4-454F-BBB0-BD57A5AEAFA6
:END:

#+NAME: ggtags-spec
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ggtags
  :if (and (getenv "GTAGSLABEL") (executable-find "global"))
  :custom (ggtags-highlight-tag nil))
#+END_SRC

** Version Control

#+NAME: code/vcs
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
<<vcs/customize>>
;; Mercurial
<<vcs/hg>>
;; Git
<<vcs/git>>
;; Diff
<<vcs/diff>>
#+END_SRC

*** VCS Customize Interface

#+NAME: vcs/customize
#+BEGIN_SRC emacs-lisp :tangle no
  (defcustom halidom-vcs-svn-list '(git)
    "List of VCS-SVNs for which libraries and tooling
  should be installed. Options are `git' and/or `hg' as symbols
  in a list, else nil."
    :type '(list symbol))
#+END_SRC

*** Git

#+NAME: vcs/git
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
(when (or (member 'git halidom-vcs-svn-list)
         (executable-find "git"))
  ;; Magit
  <<git-magit>>
  ;; Gist
  <<git-gist>>
  ;; Git Timemachine
  <<git-git-timemachine>>
  ;; Git Messenger
  <<git-git-messenger>>
  ;; Git Modes
  <<git-git-modes>>
)
#+END_SRC

**** Magit
:PROPERTIES:
:ID:       AE7AB6CA-A097-4CB0-9B13-2B131CC2F5D9
:CUSTOM_ID: magit
:END:

#+NAME: git-magit
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Magit Kill Buffers
<<magit-kill-buffers>>
;; Magit mode
<<magit-magit-mode>>
;; Magithub
<<magit-magithub>>
;; Orgit
<<magit-orgit>>
;; Topgit
<<magit-topgit-config>>
;; Stgit
<<magit-stgit-config>>
#+END_SRC

[[https://github.com/magit/magit][Magit]] describes itself as one of two git porcelains, the other being
git itself.

A git porcelain is jargon for a program that features a user-friendly
vcs interface, as opposed to lower-level scripting commands.

It's not a vitrified ceramic commonly used for decorative tableware.
Magit would not be very good at that.

As a git client though, magit is awesome.


#+NAME: magit-magit-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package magit
  :defines (magit-mode-hook)
  :bind
  (("C-c v v" . magit-status)
   ("C-c v m" . magit-merge)
   ("C-c v b" . magit-blame)
   ("C-c v C" . magit-clone)
   ("C-c v i" . magit-init)
   ("C-c v l" . magit-log-buffer-file)
   ("C-c v c" . magit-checkout)
   ("C-c v f" . magit-stage-file)
   ("C-c v p" . magit-pull)
   ("C-c v P" . magit-push)
   ("C-c v S" . magit-stash))
  :init
  (which-key-add-prefix-title "C-c v" "")
  (push '(( nil . "magit-\\(.+\\)") . (nil . " \\1"))
        which-key-replacement-alist)
  :config
  (progn
    (setq magit-save-repository-buffers 'dontask)))

#+END_SRC

***** Magit topgit

#+NAME: magit-topgit-config
#+BEGIN_SRC emacs-lisp :tangle no
(use-package magit-topgit
  :init
  (progn
    (add-hook 'magit-mode-hook 'turn-on-magit-topgit))
  :demand t
  :after (magit))
#+END_SRC

***** Magit stgit

To configure:

#+BEGIN_SRC shell :tangle no
git config --global --add magit.extension stgit
#+END_SRC

#+NAME: magit-stgit-config
#+BEGIN_SRC emacs-lisp :tangle no
(use-package magit-stgit
  :init
  (progn
    (add-hook 'magit-mode-hook 'magit-stgit-mode))
  :demand t
  :after (magit))
#+END_SRC

***** Kill some magit buffers

#+NAME: magit-kill-buffers
#+BEGIN_SRC emacs-lisp :tangle yes :exports none :noweb yes
<<magit-done>>
<<magit-done-no-prompt>>
#+END_SRC

Magit creates a lot of buffers for various git operations. This
function cleans up these buffers upon invocation.

#+NAME: magit-done
#+BEGIN_SRC emacs-lisp :tangle no
(defun magit-done (&optional no-prompt)
  "Kill magit buffers upon completion of various git processe(s).
If called with the interactive prefix argument NO-PROMPT, then
yunmodified magit buffers will be killed without confirming."
  (interactive "P")
  (let* ((buffer-names (buffer-list-names))
	 (magit-regexp-string "^\\*magit")
	 (magit-buffer-names (seq-filter (lambda (b) (string-match magit-regexp-string b)) buffer-names))
	 (magit-buffers (mapcar (lambda (b) (get-buffer b)) magit-buffer-names)))
    (cond (no-prompt
	   (mapcar
	    (lambda (b)
	      (if (> (window-count-unique) 1)
		  (progn
		    (let ((w (get-buffer-window)))
		      (kill-buffer b)
		      (delete-window w)))
		(kill-buffer b)))
	    magit-buffers))
	  (magit-buffers
	   (kill-some-buffers magit-buffers))
	  (t
	   (message "No magit buffer(s) to kill" )))))
#+END_SRC

#+NAME: magit-done-no-prompt
#+BEGIN_SRC emacs-lisp :tangle yes
(defun magit-done-no-prompt ()
  "Close magit buffers without prompting."
    (interactive)
    (magit-done 1))
#+END_SRC

***** Magithub

[[https://github.com/vermiculus/github][Magithub]] offers an interface to github to complement magit.

#+NAME: magit-magithub
#+BEGIN_SRC emacs-lisp :tangle no
(use-package magithub
  :after (magit)
  :commands magithub-dispatch-popup
  :bind (:map magit-status-mode-map
	      ("@" . magithub-dispatch-popup))
  :config
  (progn
    (magithub-feature-autoinject t)))
#+END_SRC

***** Orggit

Insert Org links to magit buffers.

#+NAME: magit-orgit
#+BEGIN_SRC emacs-lisp :tangle no
(use-package orgit
  :straight t)
#+END_SRC

**** gist.el

Emacs integration for gist.github.com.

[[https://github.com/defunkt/gist.el][Gist]] requires generating a personal access token with ~gist~ scope, and
optionally ~user~ and ~repo~ scopes.

#+NAME: git-gist
#+BEGIN_SRC emacs-lisp :tangle no
(use-package gist
  :bind
  (("C-c C-g l" . gist-list)
   ("C-c C-g r" . gist-region)
   ("C-c C-g b" . gist-buffer)
   ("C-c C-g p" . gist-buffer-private)
   ("C-c C-g B" . gist-region-or-buffer)
   ("C-c C-g P" . gist-region-or-buffer-private)))
#+END_SRC

**** git-timemachine

Travel back in time (to your last commit).

#+NAME: git-git-timemachine
#+BEGIN_SRC emacs-lisp :tangle no
(use-package git-timemachine
  :bind
  ("C-c v t" . git-timemachine-toggle)
  :config
  (setq git-timemachine-abbreviation-length 7))
#+END_SRC

**** git-messenger

Pop-up feature for viewing the last git commit.

#+NAME: git-git-messenger
#+BEGIN_SRC emacs-lisp :tangle no
(use-package git-messenger
  :bind
  (("C-c C-v m" . git-messenger:popup-message)))
#+END_SRC

**** git modes

#+NAME: git-git-modes
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package git-modes
  :straight t
  :mode (".projectile\\'" . gitignore-mode))
#+END_SRC

*** Mercurial

#+NAME: vcs/hg
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
(when (or (member 'hg halidom-vcs-svn-list)
         (executable-find "hg"))
  ;; hg-monky
  <<hg/monky>>
  ;; hg-ahg
  <<hg/ahg>>
)

#+END_SRC

**** Monky

Monky provides an interactive interface for mercurial. It's
essentially to ~hg~ what [[#magit][magit]] is for ~git~.

#+NAME: hg/monky
#+BEGIN_SRC emacs-lisp :tangle no
(use-package monky
  :custom
  (monky-process-type 'cmdserver))
#+END_SRC

**** ahg

#+NAME: hg/ahg
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ahg)
#+END_SRC

*** Ediff

#+NAME: vcs/diff
#+BEGIN_SRC emacs-lisp :tangle no

(use-package ediff
:custom
(ediff-diff-options "-w"))

#+END_SRC

** DevOps

#+NAME: code/devops
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Docker
<<devops/docker>>
;; AWS
<<devops/aws>>
#+END_SRC

*** Docker

#+NAME: devops/docker
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Docker
<<docker-cmds>>
;; Dockerfile Mode
<<docker-dockerfile>>
;; Docker Compose Mode
<<docker-docker-compose>>
;; Docker Tramp
<<docker-docker-tramp>>
#+END_SRC

**** Docker commands

#+NAME: docker-cmds
#+BEGIN_SRC emacs-lisp :tangle no

(use-package docker)
#+END_SRC

**** Dockerfile mode

#+NAME: docker-dockerfile
#+BEGIN_SRC emacs-lisp :tangle no
(use-package dockerfile-mode
  :mode "Dockerfile\\'")
#+END_SRC

**** Docker Compose

#+NAME: docker-docker-compose
#+BEGIN_SRC emacs-lisp :tangle no
(use-package docker-compose-mode
    :mode ("docker-compose.yml\\'" . docker-compose-mode))

#+END_SRC

**** Docker Tramp

#+NAME: docker-docker-tramp
#+BEGIN_SRC emacs-lisp :tangle no
(use-package docker-tramp
  :straight t)
#+END_SRC

*** AWS

#+NAME: devops/aws
#+BEGIN_SRC emacs-lisp :tangle no
(use-package aws
  :config
  (progn
    (autoload 'ec2-desribe-instances "aws")
    (autoload 'ec2-describe-volumes "aws")
    (autoload 'ec2-describe-snapshots "aws")
    (autoload 'ec2-describe-group "aws")
    (autoload 'ec2-get-console "aws")))
#+END_SRC

** Prog Tools
*** Time Tracking

Automate time tracking with [[https://github.com/wakatime/wakatime-mode][wakatime]].

#+NAME: wakatime-mode-config
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wakatime-mode
    :if (executable-find "wakatime")
    :hook
    (prog-mode . wakatime-mode)
    :custom
    (wakatime-cli-path
     (user-home ".local" "lib" "python3.6"
                "site-packages" "wakatime" "cli.py"))
    (wakatime-python-bin
     (executable-find "python")))
#+END_SRC

*** RealGUD

A front-end for interacting with external debuggers in Emacs.

#+NAME: debug-realgud
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package realgud
  :straight t)
#+END_SRC

*** Logging
**** Log view

#+NAME: logview
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package logview)
#+END_SRC

**** Log nav

#+NAME: lognav
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package lognav-mode)
#+END_SRC

*** Pair Programming

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package floobits
  :if (file-exists-p (user-home ".floorc.json")))

#+END_SRC

** Prog Lang API

Opt-in to programming languages. A very simplified version of
Spacemacs =dotspacemacs-configuration-layers=.

#+BEGIN_SRC emacs-lisp :tangle yes

  (defcustom halidom-proglang-enabled-list nil
    "List of languages for which straight should install respective
  tooling, syntax-highlighting, and peripherals."
    :type '(list symbol))


  (defun halidom/proglang-enabled-p (lang)
    "Returns non-nil if LANG is an enabled language spec."
    (member lang halidom-proglang-enabled-list))

  (defun halidom/enable-langs (&rest langs)
    "Enable LANGS."
    (mapcar (lambda (lang)
              (setq halidom-proglang-enabled-list
                    (cons lang halidom-proglang-enabled-list)))
            langs))

  (when *is-mac*
    (halidom/enable-langs 'asm 'c-c++ 'common-lisp 'clojure 'groovy
                          'java 'javascript 'markdown 'scala 'python
                          'ocaml 'ruby 'web))

#+END_SRC

** Programming Languages
*** Conf

#+NAME: lang/conf
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin conf Group
;; Nginx
<<conf-nginx>>
;; YAML Mode
<<conf-yaml>>
;; End conf Group
#+END_SRC

**** Nginx

#+NAME: web-nginx
#+BEGIN_SRC emacs-lisp :tangle no
(use-package nginx-mode
    :mode ("/nginx/sites-\\(?:available|enabled\\)/" . nginx-mode))
#+END_SRC

**** Yaml

#+NAME: conf-yaml
#+BEGIN_SRC emacs-lisp :tangle no

(use-package yaml-mode
    :mode (("\\.yml\\'" . yaml-mode)
           (".clang-tidy\\'" . yaml-mode)))

#+END_SRC

*** Assembly

- See Spacemacs [[https://github.com/syl20bnr/spacemacs/blob/master/layers/%2Blang/asm/][ASM layer]].

#+NAME: lang/asm
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin ASM
(when (halidom/proglang-enabled-p 'asm)
  ;; ASM Hooks
  <<asm-asm-hooks>>
  ;; ASM Mode
  <<asm-asm-mode>>
  ;; NASM Mode
  <<asm-nasm-mode>>
  ;; ASM x86 Lookup
  <<asm-asm-init-x86-lookup>>) ;; End ASM
#+END_SRC

**** ASM Hook Functions

#+NAME: asm-asm-hooks
#+BEGIN_SRC emacs-lisp :tangle no
(defun halidom/asm-setup ()
  (setq tab-stopp-list (number-sequence 2 60 2)))

(defvar asm-colon-has-space nil)

(defun halidom/asm-colon-check-space ()
  (setq asm-colon-has-space nil)
  (when (and (not (null (char-after)))
             (member (string (char-after)) '(" " "\t")))
    (setq asm-colon-has-space t)))

(defun halidom/asm-colon-delete-space ()
  (unless asm-colon-has-space
    (call-interactively 'delete-horizontal-space)))

(advice-add 'asm-colon :before 'halidom/asm-colon-check-space)
(advice-add 'asm-colon :after  'halidom/asm-colon-delete-space)
#+END_SRC

**** ASM Mode

#+NAME: asm-asm-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package asm-mode
  :mode (("\\.64sa\\'" . asm-mode)
         ("\\.64da\\'" . asm-mode)
         ("\\.32sa\\'" . asm-mode)
         ("\\.32da\\'" . asm-mode))
  :config
  (progn
    (define-key asm-mode-map (kbd "C-j") 'newline)))
#+END_SRC

**** NASM mode

#+NAME: asm-nasm-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package nasm-mode
  :init
  (add-hook 'nasm-mode-hook #'halidom/asm-setup)
  :mode
  (("\\.[n]*\\(asm\\|s\\)\\'" . nasm-mode))
  :bind ((:map nasm-mode-map
               ("C-j" . newline)
               (":" . asm-colon))))

#+END_SRC

**** ASM Init x86 Lookup

#+NAME: asm-asm-init-x86-lookup
#+BEGIN_SRC emacs-lisp :tangle no
(use-package x86-lookup
  :init
  (progn
    (when (straight-check-package "pdf-tools")
      (setq x86-lookup-browse-pdf-function 'x86-lookup-browse-pdf-pdf-tools)))
  :config
  (setq x86-lookup-pdf
        "~/Dropbox/Documents/Books/ASM/x86-manual/325462-sdm-vol-1-2abcd-3abcd.pdf"))

#+END_SRC

***  C/C++

#+NAME: lang/c-c++
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin C/C++
(when (halidom/proglang-enabled-p 'c-c++)
  ;; Cmake
  <<c-cxx-cmake>>
  ;; Make Comint
  <<c-cxx-make>>
  ;; Cquery
  <<c-cxx-cquery>>
  ;; Clangd
  <<c-cxx-clangd>>
  ;; Clang Tidy
  <<c-cxx-clang-tidy>>
  ;; Rtags
  <<c-cxx-rtags>>
  ;; llvm
  <<c-cxx-llvm>>
)

#+END_SRC

**** Cmake Mode

#+NAME: c-cxx-cmake
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package cmake-mode
  :mode (("CMakeLists\\.txt\\'" . cmake-mode)
         ("\\.cmake\\'" . cmake-mode))
  :init
  (with-eval-after-load 'projectile
    (add-to-list 'projectile-project-root-files-top-down-recurring
                 "compile_commands.json"))

  (defun cmake-build-compilation-database ()
    (interactive)
    (let* ((project-directory (cond (projectile-project-root
                                     projectile-project-root)
                                    ((eq 'major-mode 'dired-mode)
                                     dired-directory)
                                    (t default-directory)))
           (build-directory (f-join project-directory "build"))
           (compiledb (f-join build-directory "compile_commands.json")))
      (when (f-exists? (f-join project-directory "CMakeLists.txt"))
        (if-not (f-exists? build-directory)
            (mkdir build-directory))
        (with-temp-buffer
          (shell-command "make clean")
          (cd build-directory)
          (cmake-command-run "-DCMAKE_EXPORT_COMPILE_COMMANDS=ON" project-directory))
        (if (f-exists? compiledb)
            (make-symbolic-link (f-slash project-directory) build-directory t)))))

  (defun cmake-mode-dash-docsets ()
    (setq-local dash-plugin-keywords '("cmake")))

  :hook (cmake-mode . cmake-mode-dash-docsets))

#+END_SRC

**** Make Comint

#+NAME: c-cxx-make
#+BEGIN_SRC emacs-lisp :tangle no
(defun make-command (command)
  (interactive "P")
  (compilation-start
   (read-shell-command "Make command: " "make " command)))

#+END_SRC

**** Cquery

#+NAME: c-cxx-cquery
#+BEGIN_SRC emacs-lisp :tangle no

(use-package cquery
    :commands lsp-cquery-enable
    :if (executable-find "cquery")
    :custom
    (cquery-executable (executable-find "cquery"))
    (cquery-extra-init-params '(:index (:comments 2)
                                :cacheFormat "msgpack"
                                :completion (:detailedLabel t)))
    :init
    (defun cquery/enable ()
      "Enable cquery in the workspace."
      (condition-case nil
          (lsp-cquery-enable)
        (user-error "%s" "cquery didn't work")))

    :hook
    ((c-mode c++-mode)  . cquery/enable)
    ((c-mode c++-mode) . halidom/flycheck-enable-hook)

    :config

    ;; Alternatively, use lsp-ui-peek interface
    ;; (setq cquery-sem-highlight-method 'font-lock)
    ;; alternatively
    (setq cquery-sem-highlight-method 'overlay)

    ;; For rainbow semantic highlighting
    (with-eval-after-load 'lsp-ui-mode
      (lsp-ui-peek-find-custom 'base "$cquery/base")
      (lsp-ui-peek-find-custom 'callers "$cquery/callers")
      (lsp-ui-peek-find-custom 'vars "$cquery/vars"))

    (cquery-use-default-rainbow-sem-highlight)

    (with-eval-after-load 'projectile
        (add-to-list 'projectile-project-root-files-top-down-recurring
                     ".cquery")))

#+END_SRC

**** Rtags

#+NAME: c-cxx-rtags
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; rtags
<<rt-rtags>>
;; Ivy rtags
<<rt-ivy>>
#+END_SRC


#+NAME: rt-rtags
#+BEGIN_SRC emacs-lisp :tangle no

(use-package rtags
    :if (executable-find "rdm")
    :hook
    ((c-mode . rtags-start-process-unless-running)
     (c++-mode . rtags-start-process-unless-running)
     (objc-mode . rtags-start-process-unless-running)))


#+END_SRC

***** Ivy Rtags

#+NAME: rt-ivy
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ivy-rtags
    :requires (rtags))
#+END_SRC


**** LLVM Mode

#+NAME: c-cxx-llvm
#+BEGIN_SRC emacs-lisp :tangle no
(use-package llvm-mode
    :straight nil
    :load-path "~/.emacs.d/etc/local/llvm-mode"
    :init
    (require 'llvm-mode)
    (require 'tablegen-mode))
#+END_SRC

**** Clangd

#+NAME: c-cxx-clangd
#+BEGIN_SRC emacs-lisp :tangle no
(use-package lsp-clangd
    :straight (lsp-clangd
               :type git
               :repo "emacs-lsp/lsp-clangd"
               :host github)
    :commands (lsp-clangd-c-enable
               lsp-clangd-c++-enable
               lsp-clangd-objc-enable)
    :custom
    (lsp-clangd-executable  (executable-find "clangd"))

    :if  (executable-find "clangd")
    :hook
    ((c-mode . lsp-clangd-c-enable)
     (c++-mode . lsp-clangd-c++-enable)
     (objc-mode . lsp-clangd-objc-enable)))

#+END_SRC

**** Clang Tidy

#+NAME: c-cxx-clang-tidy
#+BEGIN_SRC emacs-lisp :tangle no
(use-package flycheck-clang-tidy
    :after flycheck
    :if (executable-find "clang-tidy")
    :init
    (defun clang-tidy/enable ()
      (when (and (-non-nil projectile-project-root)
                 (string= projectile-project-type "cmake"))
        (when (fboundp 'flycheck-mode)
          (flycheck-clang-tidy-setup))))
    (add-hook 'c-mode-common-hook 'clang-tidy/enable))

#+END_SRC

**** Clang Check

#+NAME: c-cxx-clang-check
#+BEGIN_SRC emacs-lisp :tangle no
(use-package flycheck-clangcheck
    :after flycheckclang-fo
    :if (executable-find "clangcheck")
    :init
    (defun clangcheck//enable ()
      (when (and (-non-nil projectile-project-root)
                 (file-exists-p (f-join projectile-project-root
                                        "build"
                                        "compile_commands.json")))
        (when (fboundp 'flycheck-mode)
          (flycheck-clangcheck-setup))))
    (add-hook 'c-mode-common-hook 'clangcheck//enable)))

#+END_SRC

**** Clang Format

#+NAME: c-cxx-clang-format
#+BEGIN_SRC emacs-lisp :tangle no
(use-package clang-format
    :if (executable-find "clang-format")
    :bind (:map c-mode-base-map
                ("C-c i" . clang-format-region)
                ("C-c u" . clang-format-buffer))
    :custom
    (clang-format-style-option "google"))

#+END_SRC

*** Common Lisp

#+NAME: lang/clisp
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin CLisp
(when (halidom/proglang-enabled-p 'common-lisp)
  ;; CL Hooks
  <<cl-hooks>>
  ;; Slime
  <<cl-slime>>
) ;; End CLisp
#+END_SRC

Configuration for common-lisp.

#+NAME: cl-hooks
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes
(defun common-lisp-style ()
  "Styleguide for common lisp."
  (if (fboundp 'paredit-mode)
      (paredit-mode +1))
  (if (fboundp 'highlight-symbol-mode)
      (highlight-symbol-mode +1))
  (if *is-mac*
      (setq-local dash-plugin-keywords '("lisp"))))

(add-hook 'lisp-mode-hook #'common-lisp-style)
#+END_SRC

**** Slime

[[https://common-lisp.net/project/slime/][SLIME]] is The Superior Lisp Interaction Mode for Emacs.

#+NAME: cl-slime
#+BEGIN_SRC emacs-lisp :tangle no
(use-package slime
  :commands slime
  :defines (slime-complete-symbol*-fancy
            slime-completion-at-point-functions)
  :init
  (progn
    (setq slime-contribs
            '(slime-asdf
      			  slime-fancy
			        slime-indentation
      			  slime-sbcl-exts
      			  slime-scratch)
	          inferior-lisp-program "sbcl"
      	    ;; enable fuzzy matching in code buffer and SLIME REPL
      	    slime-complete-symbol*-fancy t
      	    slime-completion-at-point-functions 'slime-fuzzy-complete-symbol)

    (defun slime-disable-smartparens ()
      (smartparens-strict-mode -1)
      (turn-off-smartparens-mode))

    (add-hook 'slime-repl-mode-hook #'slime-disable-smartparens)))
#+END_SRC

*** Clojure

#+NAME: lang/clj
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin Clojure
(when (halidom/proglang-enabled-p 'clojure)
  ;; Clojure Mode
  <<clj-clojure-mode>>
  ;; Clojure Mode Extra Font Locking
  <<clj-extra-font-locking>>
  ;; IDE Widget
  <<clj-ide>>
  ;; CIDER
  <<clj-cider>>
  ;; Inf Clojure
  <<clj-inf-clojure>>
  ;; Clj Refactor
  <<clj-refactor>>
  ;; Leiningen
  <<clj-lein>>
) ;; End Clojure
#+END_SRC

**** Clojure Mode
:PROPERTIES:
:ID:       B09DFF0C-3404-483C-824F-E51A5CE50BCD
:END:

Everything about [[https://gihub.com/clojure-emacs/clojure-mode][clojure]], is awesome. That's
before we even get to [[#cider][CIDER]]...:beer::raised_hands_tone3:

Provides key bindings and font-locking for Clojure.

#+NAME: clj-clojure-mode
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes
(use-package clojure-mode
  :custom (clojure-indent-style :always-indent)

  :mode (("\\.edn$"   . clojure-mode)
         ("\\.cljs$"  . clojurescript-mode)
         ("\\.cljx$"  . clojurex-mode)
         ("\\.cljsc$" . clojurec-mode))

  :hook ((clojure-mode . enable-paredit-mode)
         (clojure-mode . show-paren-mode))

  :config

  (defun halidom/clj-dash-docsets ()
    "Keywords for Clojure Docsets via Dash.app."
    (setq-local dash-plugin-keywords '("clojure")))

  (defun halidom/clj-style-compojure ()
    "Indendation for macros defined in compojure routing framework.

     See https://github.com/weavejester/compojure/wiki/Emacs-indentation."

    (define-clojure-indent
        (defroutes 'defun)
        (GET 2)
        (POST 2)
        (PUT 2)
        (DELETE 2)
        (HEAD 2)
        (ANY 2)
        (OPTIONS 2)
        (PATCH 2)
        (rfn 2)
        (let-routes 1)
        (context 2)))


  (defun halidom/clj-style-om-next ()
    "Indendation for om-next macros."
      (put-clojure-indent 'defui '(1 nil nil (1)))
      (put-clojure-indent 'dom/div 1))

  (defun halidom/clj-style-guide ()
    "Styleguide for clojure."
    (halidom/clj-style-compojure)
    (halidom/clj-style-om-next))

  (add-hook 'clojure-mode-hook #'halidom/clj-dash-docsets)
  (add-hook 'clojure-mode-hook #'halidom/clj-style-guide))
#+END_SRC

***** Clojure Mode Extra Font Locking

Additional syntax highlighting for ~clojure-mode~.

#+NAME: clj-extra-font-locking
#+BEGIN_SRC emacs-lisp :tangle no
(use-package clojure-mode-extra-font-locking
  :requires clojure-mode
  :config
  (defun halidom/clj-extra-font-locking ()
    (require 'clojure-mode-extra-font-locking))

  (add-hook 'clojure-mode-hook #'halidom/clj-extra-font-locking))
#+END_SRC

**** Clojure IDE

#+NAME: clj-ide
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
(defcustom halidom-clojure-ide 'cider
  "Select the interactive development environment to use
   in clojure mode. Note that Emacs must be restarted when
   the value of this variable is modified for the change
   to take effect."
  :type '(symbol)
  :options '(cider inf-clojure))
#+END_SRC

***** CIDER
:PROPERTIES:
:ID:       324C7B10-8B92-4C49-8FAC-702C65C7A2EE
:CUSTOM_ID: cider
:END:

[[https://github.com/clojure-emacs/cider][Clojure Interactive Development Environment that Rocks for Emacs]]

#+NAME: clj-cider
#+BEGIN_SRC emacs-lisp :tangle no
(use-package cider
  :if (eq halidom-clojure-ide 'cider)
  :init
  (with-eval-after-load 'clojure-mode
    (add-hook 'clojure-mode-hook 'cider-mode))
  :custom
  (cider-repl-history-file "~/.emacs.d/cider-history")
  (cider-repl-use-clojure-font-lock t)
  (cider-repl-result-prefix ";; => ")
  (cider-repl-wrap-history t)
  (cider-repl-history-size 3000)
  (cider-show-error-buffer nil)
  (nrepl-hide-special-buffers t)
  :hook (((cider-mode cider-repl-mode) . eldoc-mode)
         ((cider-mode cider-repl-mode) . company-mode)
         ((cider-mode cider-repl-mode) .
          cider-company-enable-fuzzy-completion)
         (cider-repl-mode . subword-mode)))
#+END_SRC

***** Inf Clojure
:PROPERTIES:
:ID:       D1642BA7-3A2F-40CA-8B80-D28927627A91
:CUSTOM_ID: inf-clojure
:END:


 [[https://github.com/clojure-emacs/inf-clojure][inf-clojure]] is a drop-in replacement for CIDER that provides basic
 integration with a running Clojure subprocess. This package is
 necessary for running an inferior Figwheel process with Emacs.
 It's not as feature-rich as CIDER, but still offers the ability
 to load files, switch namespaces, evaluate expressions, show
 documentation, and do macro-expansion.

#+NAME: clj-inf-clojure
#+BEGIN_SRC emacs-lisp :tangle no
(use-package inf-clojure
  :if (eq halidom-clojure-ide 'inf-clojure)
  :init
  (with-eval-after-load 'clojure-mode
    (add-hook 'clojure-mode-hook #'inf-clojure-minor-mode))
  :config
  (defun figwheel-repl ()
    (interactive)
    (inf-clojure "lein figwheel")))
#+END_SRC

**** Clojure Refactor

#+NAME: clj-refactor
#+BEGIN_SRC emacs-lisp :tangle no
(use-package clj-refactor
  :init
  (defun halidom/clj-refactor-enable ()
    "Enable clj-refactor in clojure-mode."
    (clj-refactor-mode 1)
    ;; For adding reuire/use/import statements
    (yas-minor-mode 1)
    ;; Unbinds `cider-macroexpand-1'
    (cljr-add-keybindings-with-prefix "C-c C-m"))

  :hook ((clojure-mode) . halidom/clj-refactor-enable))

#+END_SRC

**** Leiningen

#+NAME: clj-lein
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Elein
<<lein-elein>>
;; Cljsbuild
<<lein-cljsbuild>>
#+END_SRC

***** elein

[[https://github.com/remvee/elein][Elein]] rovides support for leiningen commands in Emacs.

#+NAME: lein-elein
#+BEGIN_SRC emacs-lisp :tangle no
(use-package elein
  :if (executable-find "lein")
  :straight t)
#+END_SRC

***** Cljsbuild

Minor mode offering ~lein cljsbuild~ commands for the Leiningen [[https://github.com/emezeske/lein-cljsbuild][plugin]].

#+NAME: lein-cljsbuild
#+BEGIN_SRC emacs-lisp :tangle no
(use-package cljsbuild-mode
  :if (executable-find "lein")
  :hook ((clojure-mode clojurescript-mode) . cljsbuild-mode))
#+END_SRC

*** Emacs Lisp

#+NAME: lang/emacs-lisp
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin emacs-lisp
<<elisp/core>>
;; Cask
<<elisp-cask>>
;; End emacs-lisp
#+END_SRC

#+NAME: elisp/core
#+BEGIN_SRC emacs-lisp :tangle no
  (defun emacs-lisp-style ()
    (paredit-mode 1)
    (highlight-symbol-mode 1))

  (defun halidom/elisp-dash-docsets ()
    (setq-local dash-plugin-keywords '("elisp")))


  (add-hook 'emacs-lisp-mode-hook #'emacs-lisp-style)
  (add-hook 'emacs-lisp-mode-hook #'halidom/elisp-dash-docsets)
#+END_SRC

**** Emacs Lisp  Format

#+NAME: elisp/format
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package elisp-format
    :custom
    (elisp-format-column 80))
#+END_SRC

**** Cask

#+NAME: elisp-cask
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Cask Mode
<<cask-cask-mode>>
;; Flycheck cask
<<cask-flycheck-cask>>
;; Cask Package Toolset
<<cask-pkg-toolset>>
#+END_SRC

***** Cask Mode

#+NAME: cask-cask-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package cask-mode)
#+END_SRC

***** Flycheck Cask

#+NAME: cask-flycheck-cask
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package flycheck-cask
    :init
    (defun flycheck-cask/enable ()
      (when (eq projectile-project-type 'emacs-cask)
        (flycheck-cask-setup)))

    (defun flycheck-cask/disable-dir-locals ()
      (when (string= ".dir-locals.el" (buffer-file-name))
        (set (make-variable-buffer-local 'flycheck-mode) nil)))

    :hook
    (flycheck-mode . flycheck-cask/enable)
    (flycheck-mode . flycheck-cask/disable-dir-locals))

#+END_SRC

***** Cask Toolset

#+NAME: cask-pkg-toolset
#+BEGIN_SRC emacs-lisp :tangle no
(use-package cask-package-toolset)
#+END_SRC

*** Groovy

#+NAME: lang/java
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package groovy-mode
  :mode  "\\.gradle\\'"
  :config
  (defun groovy-style ()
    (setq groovy-indent-offset 2
          tab-width 4
          indent-tabs-mode nil
          c-indent-comments-syntactically-p t))
  (add-hook 'groovy-mode-hook #'groovy-style))
#+END_SRC

*** Java

#+NAME: lang/java
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin Java
(when (halidom/proglang-enabled-p 'java)
  ;; Java Backend
  <<java-backend>>
  ;; Java Hooks
  <<java-hooks>>
  ;; Eclim
  <<java-eclim>>
  ;; Meghanada
  <<java-meghanada>>
  ;; Autodisass Java Bytecode
  <<java-disass>>
  ;; Gradle Mode
  <<java-gradle>>
  ;; LSP Java
  <<java/lsp>>
  ;; Javadoc lookup
  <<java/doc>>
) ;;End Java

#+END_SRC

#+NAME: java-hooks
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
(defun java-mode-style ()
  (c-set-offset 'arglist-close '0)
  (setq indent-tabs-mode nil
        tab-width 2
        c-basic-offset 2))

(defun java-mode-dash-docsets-hook ()
  (setq-local dash-plugin-keywords '("java" "gradle" "groovy")))

;; Enable Hooks
(add-hook 'java-mode-hook 'java-mode-style)

(if *is-mac*
  (add-hook 'java-mode-hook 'java-mode-dash-docsets-hook))
#+END_SRC

**** Gradle Mode
:PROPERTIES:
:ID:       0D4DEC79-5E2D-48D0-A8B1-38E2432565C8
:CUSTOM_ID: gradle-mode
:END:

Gradle is a build tool for Java. It's awesome.

#+NAME: java-gradle
#+BEGIN_SRC emacs-lisp :tangle no
(use-package gradle-mode
  :if (executable-find "gradle")
  :hook
  ((java-mode . gradle-mode)))
#+END_SRC

**** Java Backends

#+NAME: java-backend
#+BEGIN_SRC emacs-lisp :tangle no
(defcustom halidom-java-backend 'meghanada
  "Select a backend to use when opening a *.java file."
  :type '(symbol)
  :options '(meghanada ensime eclim lsp))
#+END_SRC


***** Eclim

#+NAME: java-eclim
#+BEGIN_SRC emacs-lisp :tangle no
(use-package eclim
  :if (eq halidom-java-backend 'eclim)

  :custom
  (eclimd-autostart-with-default-workspace t)
  (eclim-autostart nil)
  (eclim-wait-for-process t))

#+END_SRC

***** Meghanada

#+NAME: java-meghanada
#+BEGIN_SRC emacs-lisp :tangle no :noweb
  (use-package meghanada
    :if (eq halidom-java-backend 'meghanada)
    :commands meghanada-mode

    :bind
    (:map meghanada-mode-map
          ("C-S-t" . meghanada-switch-testcase)
          ("M-RET" . meghanada-local-variable)
          ("M-r"   . meghanada-reference)
          ("M-t"   . meghanada-typeinfo)
          ("C-z"   . hydra-meghanada/body))

    :hook
    ((java-mode . meghanada-mode)
     (java-mode . flycheck-mode))

    :custom
    (meghanada-server-remote-debug t)
    (meghanada-javac-xlint "-Xlint:all,-processing")

    :config
    (defhydra hydra-meghanada (:hint nil :exit t)
      "
         ^Edit^                          ^Tast or Task^
         ^^^^^^---------------------------------------------
         _f_: meghanada-compile-file     _m_: meghanada-restart
         _c_: meghanada-compile-project  _t_: meghanada-run-task
         _o_: meghanada-optimize-import  _j_: meghanada-run-junit-test-case
         _s_: meghanada-switch-test-case _J_: meghanada-run-junit-class
         _v_: meghanada-local-variable   _R_: meghanada-run-junit-recent
         _i_: meghanada-import-all       _r_: meghanada-reference
         _q_: exit                       _T_: meghanada-typeinfo
         "
      ("f" meghanada-compile-file)
      ("m" meghanada-restart)

      ("c"  meghanada-compile-project)
      ("o"  meghanada-optimize-import)
      ("s"  meghanada-switch-test-case)
      ("v"  meghanada-local-variable)
      ("i"  meghanada-import-all)


      ("t"  meghanada-run-task)
      ("T"  meghanada-typeinfo)
      ("j"  meghanada-run-junit-test-case)
      ("J"  meghanada-run-junit-class)
      ("R"  meghanada-run-junit-recent)
      ("r"  meghanada-reference)

      ("q" exit)
      ("z" nil "leave")))
#+END_SRC

***** Ensime

#+NAME: java-ensime
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ensime
    :if (eq halidom-java-backend 'ensime)
    :straight (ensime
               :host github
               :repo "ensime/ensime-emacs"
               :branch "2.0"))
#+END_SRC

**** Autodisass Java Bytecode

The [[https://github.com/gbalats/autodisass-java-bytecode][autodisass-java-bytecode]] package enables automatic disassembly of
Java bytecode inside Emacs buffers.

#+NAME: java-disass
#+BEGIN_SRC emacs-lisp :tangle no
(use-package autodisass-java-bytecode)
#+END_SRC

**** Lsp Java

#+NAME: java/lsp
#+BEGIN_SRC emacs-lisp :tangle no
(use-package lsp-java
  :defines (lsp-java-enable)
  :init
  (defun java-setup-lsp ()
    (require 'lsp-java)
    (lsp-java-enable))
  :custom
  (lsp-java-workspace-dir
   (if *is-mac*
       "~/Developer/Workspace/"
     (emacs-var-dir "workspace/")))
  (lsp-java-server-install-dir
   (file-name-as-directory (emacs-var-dir "lsp-java" "server")))
  :hook
  (java-mode . java-setup-lsp))

#+END_SRC

**** Javadoc lookup

#+NAME: 
#+BEGIN_SRC emacs-lisp :tangle no
(use-package javadoc-lookup
  :bind
  ("C-h j" . javadoc-lookup)
  :custom
  (javadoc-lookup-completing-read-function #'ivy-completing-read))

#+END_SRC

*** JavaScript

#+NAME: lang/js
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin JavaScript
(when (halidom/proglang-enabled-p 'javascript)
  ;; Set up backend
  <<js-backend>>
  ;; js2 mode
  <<js-js2>>
  ;; JSON Mode
  <<js-json>>
  ;; RJSX Mode
  <<js-rjsx>>
  ;; Flycheck jest
  <<js/jest>>
  ;; Tide Mode
  <<js-tide>>
  ;; Coffeescript
  <<js-cofee>>
  ;; Node.js
  <<js-node>>
  ;; Indium
  <<js-indium>>
) ;; End JavaScript

#+END_SRC

**** JS Backend

#+NAME: js-backend
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes
<<js-backend-interface>>
;; Tern
<<js-backend-tern>>
;; LSP
<<js-backend-lsp>>
;; Setup backend
<<js-backend-setup>>
#+END_SRC

***** Backend Interface

#+NAME: js-backend-interface
#+BEGIN_SRC emacs-lisp :tangle yes
(defcustom halidom-js-backend 'lsp
  "The backend to use with JavaScript and friends.
Supported symbols are `tern' and `lsp'. If enabled,
the `halidom-js-lsp-clients' variable can be used to
customize the enabled clients."
  :type '(choice
          (const :tag "Use tern." tern)
          (const :tag "Use lsp." lsp)
          (const :tag "I don't like nice things." nil)))

(defcustom halidom-js-lsp-clients '(javascript-typescript)
  "List of defined stdio LSP clients to enable for use in JavaScript.
Supported values are `javascript-typescript', `javascript-flow',
and `typescript'.
By default, only `javascript-typescript' is enabled. This is because
it's the only one of the three I've gotten to work so far."
  :type '(list symbol))

(defcustom halidom-js-lsp-modes '(js typescript rjsx)
  "List of JavaScript major modes which should support `lsp-mode'."
  :type '(list symbol))


#+END_SRC

***** Tern Backend

#+NAME: js-backend-tern
#+BEGIN_SRC emacs-lisp :tangle no
;; Tern Backend
(use-package tern)

(use-package company-tern
    :requires (tern company))

(defun js-setup-tern ()
  "Setup the JS backend for Tern."
  (let ((completion-backends '(company-tern)))
    (if-not (executable-find "tern")
        (error "%s" "Executable `tern' could not be found in PATH.")
      (require 'tern)
      (require 'company-tern)
      (set (make-local-variable 'company-backends) completion-backends)
      (message "%s" "Using Tern backend for JavaScript."))))
#+END_SRC

***** LSP Backend

#+NAME: js-backend-lsp
#+BEGIN_SRC emacs-lisp :tangle no

;; LSP Backend

;; LSP JS Typescript
(use-package lsp-javascript-typescript
    :if (executable-find "javascript-typescript-langserver")
    :commands lsp-javascript-typescript-enable)

;; LSP JS Flow
(use-package lsp-javascript-flow
    :if (executable-find "flow-language-server")
    :commands lsp-javascript-flow-enable)

;; LSP Typescript
(use-package lsp-typescript
    :straight (lsp-typescript
               :type git
               :files ("lsp-typescript.el")
               :host github
               :repo "emacs-lsp/lsp-javascript")
    :if (executable-find "typescript-language-server")
    :commands lsp-typescript-enable)

(defun js-company-transformer (candidates)
  (let ((completion-ignore-case t))
    (all-completions (company-grab-symbol) candidates)))

(defun js-setup-lsp ()
  "Set up the JS backend for LSP.

More specifically, enable lsp clients listed in `halidom-js-lsp-clients'
for major modes listed in `halidom-js-lsp-modes'."

  (cl-flet ((lsp-client-function (client)
              (intern (concat "lsp-" (symbol-name client) "-enable")))
            (lsp-client-req-pkg (client)
              (require `,(intern
                          (concat "lsp-" (symbol-name client))))))

    ;;  Fix issue with `javascript-typescript-langserver' completion.
    (when (member 'javascript-typescript halidom-js-lsp-clients)
      (make-local-variable 'company-transformers)
      (push 'js-company-transformer company-transformers))

    (cl-loop
       for lsp-client in halidom-js-lsp-clients
       for enable-func = (lsp-client-function lsp-client)
       do
         (lsp-client-req-pkg lsp-client)
         (funcall enable-func))))
#+END_SRC

***** Setup Backend

#+NAME: js-backend-setup
#+BEGIN_SRC emacs-lisp :tangle no

(defun js-setup-backend-function ()
  "Return the setup function corresponding to the symbol
  assigned to `halidom-js-backend.' "
  (pcase halidom-js-backend
    (`tern #'js-setup-tern)
    (`lsp  #'js-setup-lsp)))

(defun js-setup-backend ()
  "Set up the JavaScript Backend."
  (let ((backend-function (js-setup-backend-function)))
    (funcall backend-function)))


#+END_SRC

**** js2-mode

#+NAME: js-js2
#+BEGIN_SRC emacs-lisp :tangle no

(use-package js2-mode
  :custom
  (js-indent-level 2)
  :mode (("\\.js\\'" . js2-mode)
         ("\\.mjs\\'" . js2-mode))
  :interpreter "node"
  :init

  :hook ((js-mode . js-setup-backend)
         (js-mode . halidom/flycheck-enable-hook)))
#+END_SRC

**** JSON

#+NAME: js-json
#+BEGIN_SRC emacs-lisp :tangle no
(use-package json-mode
  :mode "\\.json\\'"
  :init
  (defun json-mode-style ()
    "Styleguide for JSON Mode."
    (set (make-local-variable 'js-indent-level) 2))

    (defun json-mode-faces ()
    (let ((foreground (face-foreground 'font-lock-variable-name-face)))
      (face-remap-add-relative 'font-lock-keyword-face
                               `(:slant normal :foreground ,foreground))))
  (defun json-inhibit-message ()
      (set (make-local-variable 'inhibit-message) t))

  :hook
  (json-mode . json-mode-style)
  (json-mode . json-mode-faces)
  (json-mode . json-inhibit-message))

#+END_SRC

**** Node JS

#+NAME: js-node
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Node Modules
<<node-modules-path>>
;; Npm
<<node-npm>>
;; Yarn
<<node-yarn>>
;; Node Version Manager (nvm)
<<node-nvm>>

#+END_SRC

***** Add Node Modules Path

#+NAME: node-modules-path
#+BEGIN_SRC emacs-lisp :tangle no
(use-package add-node-modules-path
  :if (executable-find "node")
  :init
  (progn
    (add-hook 'js-mode-hook #'add-node-modules-path)))
#+END_SRC

***** NPM Mode

#+NAME: node-npm
#+BEGIN_SRC emacs-lisp :tangle no
(use-package npm-mode
    :if (executable-find "npm")
    :init
    (el-patch-feature npm-mode)
    (el-patch-defun npm-mode--exec-process (cmd)
      "Execute a process running CMD."
      (message (concat "Running " cmd))
      (compile cmd (el-patch-add t)))

    (defun npm-mode-npm-install-global (dep)
      (interactive "sEnter package name: ")
      (npm-mode--exec-process (format "npm i -g %s" dep)))

    :config
    (npm-global-mode)

    :hook
    (js-mode . npm-mode))
#+END_SRC

***** Yarn mode

#+NAME: node-yarn
#+BEGIN_SRC emacs-lisp :tangle no
(use-package yarn-mode
    :if (executable-find "yarn"))
#+END_SRC

***** NVM

#+NAME: node-nvm
#+BEGIN_SRC emacs-lisp :tangle no
(use-package nvm
  :if (executable-find "nvm"))
#+END_SRC

**** TypeScript

#+NAME: js-tide
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package typescript-mode
    :custom
    (typescript-indent-level 2)
    :hook
    (typescript-mode . subword-mode)
    (typescript-mode . js-setup-backend))


  (use-package tide
    :after (:all typescript-mode flycheck company)
    :demand t
    :init
    ;; (require 'typescript-mode)
    (defun setup-tide-mode ()
      "Enable Tide Mode for Typescript."
      (tide-setup)
      (when (fboundp 'flycheck-mode)
        (flycheck-add-mode 'typescript-tslint 'typescript-mode)
        (flycheck-mode +1)
        (setq flycheck-check-syntax-automatically '(save mode-enabled)))
      (eldoc-mode +1))

    :hook
    (before-save . tide-format-before-save)
    (typescript-mode . setup-tide-mode)
    (typescript-mode . tide-hl-identifier-mode))
#+END_SRC

**** rjsx-mode

Real jsx support.

#+NAME: js-rjsx
#+BEGIN_SRC emacs-lisp :tangle no
(use-package rjsx-mode
  :mode "\\.jsx\\'"
  :hook ((rjsx-mode-hook . js-setup-backend)
         (rjsx-mode-hook . halidom/flycheck-enable-hook)))
#+END_SRC

**** Flycheck Jest

#+NAME: js/jest
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package flycheck-jest
    :after flycheck
    :init
    (flycheck-jest-setup))

#+END_SRC

**** CoffeeScript

#+NAME: js-coffee
#+BEGIN_SRC emacs-lisp :tangle no
(use-package coffee-mode
  :mode ("\\.coffee\\'" . coffee-mode))
#+END_SRC

**** Indium

#+NAME: js-indium
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package indium
    :bind (:map indium-interaction-mode-map
                ("C-M-b" . indium-eval-buffer))
    :init
    (el-patch-feature indium-nodejs)
    (with-eval-after-load 'indium-nodejs
      (el-patch-defun indium-nodejs--process-filter (process output)
        "Filter function for PROCESS. Append OUTPUT to the PROCESS buffer,
   and parse it to detect the socket URL to connect to."
        ;; Append output to the process buffer
        (with-current-buffer (process-buffer process)
          (goto-char (point-max))
          (insert output)
          (goto-char (point-min))
          (el-patch-add (ansi-color-apply-on-region (point-min) (point-max))))

        (when (string-match-p "Debugger listening on" output)
          (ignore-errors
            (indium-nodejs--connect-to-process process output)))))


    (cl-defun chrome-debugger-launch (&optional
                                      (port "3000")
                                      (host "localhost")
                                      (type "http"))
      "Launch a chromium debugger process on HOST using PORT and protocol TYPE.

      Note this will kill any running instances of Chromium."

      (interactive (list
                    (read-string "Port: " "3000")
                    (read-string "Host: " "localhost")
                    (read-string "Type: " "http")))

      (unless (featurep 'secrets)
        (require 'secrets))

      (if (boundp 'google-api-key)
          (setenv "GOOGLE_API_KEY" google-api-key))
      (if (boundp 'google-api-key)
          (setenv "GOOGLE_DEFAULT_CLIENT_ID" google-default-client-id))
      (if (boundp 'google-default-client-secret)
          (setenv "GOOGLE_DEFAULT_CLIENT_SECRET" google-default-client-secret))
      (let ((process-names (--> (process-list)
                                (mapcar (lambda (p) (process-name p)) it)))
            (process (get-process "chromium"))
            (ip (concat type "://" host ":" port))
            (chromium-program browse-url-chromium-program))
        (if (shell-command-to-list "pgrep \"Chromium\"")
            (shell-command "killall Chromium"))
        (if (process-live-p process)
            (kill-process process))
        (start-process "chromium" (get-buffer-create "chromium")
                       chromium-program "--remote-debugging-port=9222" ip)))
    :hook
    (js-mode . indium-interaction-mode))
#+END_SRC

*** Python

#+NAME: lang/py
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin Python
(when (halidom/proglang-enabled-p 'python)
  ;; Python Mode
  <<py-python>>
  ;; Pyenv Mode
  <<py-pyenv>>
  ;; Pyenv Mode Auto
  <<py-pyenv-auto>>
  ;; Virtualenvwrapper
  <<py-virtualenvwrapper>>
  ;; Pyvenv
  <<py-pyvenv>>
  ;; LSP Python
  <<py-lsp>>
  ;; Pip Requirements
  <<py-pip-requirements>>
  ;; Pydoc
  <<py-pydoc>>
  ;; EIN
  <<py-ein>>) ;; End Python

#+END_SRC

**** Python Mode

#+NAME: py-python
#+BEGIN_SRC emacs-lisp :tangle no
(use-package python-mode
  :init
  (when (executable-find "ipython3")
    (setenv "IPY_TEST_SIMPLE_PROMPT" "1")
    (setq python-shell-interpreter "ipython3"
          python-shell-interpreter-args "-i"))
  :config
  (defun python-dash-docsets ()
    (setq-local dash-plugin-keywords
                '("python" "django" "twisted" "sphinx"
                  "flask" "tornado" "sqlalchemy" "numpy"
                  "scipy" "salt" "pandas" "matplotlib"
                  "cvp")))
  (when *is-mac*
    (add-hook #'python-dash-docsets)))

#+END_SRC

**** Pyenv Mode

#+NAME: py-pyenv
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package pyenv-mode
    :if (executable-find "pyenv")
    :init
    (add-to-list 'exec-path (user-home ".pyenv" "shims"))
    (setenv "WORKON_HOME" (file-name-as-directory (user-home ".pyenv" "versions")))
    (pyenv-mode)
    :bind
    ("C-x p e" . pyenv-activate-current-project)
    ("C-x p s" . pyenv-mode-set)
    :commands

    (pyenv-mode-set pyenv-mode-unset pyenv-mode-versions)

    :config

    (defvar pyenv-current-version nil nil)

    (defun pyenv-init()
      "Initialize pyenv's current version to the global one."
      (let ((global-pyenv (replace-regexp-in-string "\n" "" (shell-command-to-string "pyenv global"))))
        (message (concat "Setting pyenv version to " global-pyenv))
        (pyenv-mode-set global-pyenv)
        (setq pyenv-current-version global-pyenv)))

    (add-hook 'after-init-hook 'pyenv-init)

    (progn
      (with-eval-after-load 'projectile
        (defun projectile-pyenv-mode-set ()
          "Set pyenv version matching project name."
          (let ((project (projectile-project-name)))
            (if (member project (pyenv-mode-versions))
                (pyenv-mode-set project)
              (pyenv-mode-unset))))

        (add-hook 'projectile-after-switch-project-hook
                  'projectile-pyenv-mode-set))

      ;; http://rakan.me/emacs/python-dev-with-emacs-and-pyenv/
      (defun pyenv-activate-current-project ()
        "Automatically activates pyenv version if .python-version file exists."
        (interactive)
        (let ((python-version-directory (locate-dominating-file (buffer-file-name) ".python-version")))
          (if python-version-directory
              (let* ((pyenv-version-path (f-expand ".python-version" python-version-directory))
                     (pyenv-current-version (s-trim (f-read-text pyenv-version-path 'utf-8))))
                (pyenv-mode-set pyenv-current-version)
                (message (concat "Setting virtualenv to " pyenv-current-version))))))))
#+END_SRC

**** Pyenv Auto Set

#+NAME: py-pyenv-auto
#+BEGIN_SRC emacs-lisp :tangle no
(use-package pyenv-mode-auto)
#+END_SRC

**** Virtualenv Wrapper

#+NAME: py-virtualenvwrapper
#+BEGIN_SRC emacs-lisp :tangle no
(use-package virtualenvwrapper
    :init
    (setq venv-dirlookup-names '(".pyenv" ".venv"))
    (setq venv-location (getenv "WORKON_HOME"))
    :config
    (when (fboundp 'projectile-mode)
      (setq projectile-switch-project-action
            '(lambda ()
              (venv-projectile-auto-workon)
              (projectile-find-file)))))

#+END_SRC

**** Pyvenv

#+NAME: py-pyvenv
#+BEGIN_SRC emacs-lisp :tangle no
(use-package pyvenv
    :requires virtualenvwrapper
    :init
  (pyvenv-mode +1))
#+END_SRC

**** LSP Python

#+NAME: py-lsp
#+BEGIN_SRC emacs-lisp :tangle no
(use-package lsp-python
    :commands lsp-python-enable
    ;; Requires python-language-server
    :if (executable-find "pyls")
    :init
    (add-hook 'python-mode-hook #'lsp-python-enable)

    (defun python//enable-flycheck ()
      (when (fboundp 'flycheck-mode)
        (flycheck-mode +1)))

    (add-hook 'python-mode-hook 'python//enable-flycheck))
#+END_SRC

**** Pip Requirements

#+NAME: py-pip-requirements
#+BEGIN_SRC emacs-lisp :tangle no
(use-package pip-requirements
    :straight t)
#+END_SRC

**** Pydoc

#+NAME: py-pydoc
#+BEGIN_SRC emacs-lisp :tangle no
(use-package pydoc
    :straight t)
#+END_SRC

**** EIN

The [[https://github.com/millejoh/emacs-ipython-notebook][emacs ipyton notebook]] client.

#+NAME: py-ein
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ein
    :config
    (setq ein:use-smartrep t))
#+END_SRC

*** Ruby

#+NAME: ruby-spec
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin Ruby
(when (halidom/proglang-enabled-p 'ruby)
  ;; Ruby Mode
  <<ruby-ruby-mode>>
  ;; Enhanced Ruby Mode
  <<ruby-enh-ruby-mode>>
  ;; RVM
  <<ruby-rvm>>
  ;; Robe Mode
  <<ruby-robe>>
  ;; Yard Mode
  <<ruby-yard>> ) ;; End Ruby
#+END_SRC

**** Ruby Mode

#+NAME: ruby-ruby-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ruby-mode
  :mode "\\.rb\\'"
  :interpreter "ruby"
  :config

  (defun halidom/ruby-dash-docsets ()
    (setq-local dash-plugin-keywords '("ruby" "rails")))


  (add-hook 'ruby-mode-hook #'halidom/ruby-dash-docsets))

#+END_SRC

**** Enhanced Ruby Mode

#+NAME: ruby-enh-ruby-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package enh-ruby-mode
    :after ruby-mode
    :demand t
    :mode "\\.rb\\'"
    :config
    (add-hook 'enh-ruby-mode-hook #'halidom/ruby-dash-docsets))
#+END_SRC

**** Inf ruby

#+NAME: ruby-inf-ruby
#+BEGIN_SRC emacs-lisp :tangle no
(use-package inf-ruby
    :after (:all ruby-mode ruby-enh-ruby-mode)
    :init
    (add-to-hooks #'inf-ruby-minor-mode '(ruby-mode-hook enh-ruby-mode-hook))
    (add-hook 'compilation-filter-hook 'inf-ruby-auto-enter))

#+END_SRC


**** Ruby Version Manager (RVM)

#+NAME: ruby-rvm
#+BEGIN_SRC emacs-lisp :tangle no
(use-package rvm
  :init
  (rvm-use-default))
#+END_SRC

**** Robe

#+NAME: ruby-robe
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package robe
    :after (:all ruby-mode rvm enh-ruby-mode)
    :demand t
    :init
    ;; https://github.com/dgutov/robe#integration-with-rvmel
    (defadvice inf-ruby-console-auto (before
                                      activate-rvm-for-robe
                                      activate)
      (rvm-activate-corresponding-ruby))
    (defun halidom/robe-mode-enable ()
      (robe-mode)
      (with-eval-after-load 'company
        (push 'company-robe company-backends)))
    (add-to-hooks #'halidom/robe-mode-enable
                  '(ruby-mode-hook enh-ruby-mode-hook)))
#+END_SRC

**** Yard Mode

#+NAME: ruby-yard
#+BEGIN_SRC emacs-lisp :tangle no
(use-package yard-mode
    :after (:all ruby-mode enh-ruby-mode)
    :demand t
    :init
    (add-to-hooks #'yard-mode '(ruby-mode-hook enh-ruby-mode-hook))
    (add-to-hooks #'eldoc-mode '(ruby-mode-hook enh-ruby-mode-hook)))

#+END_SRC

*** Ocaml

#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin Ocaml
(when (halidom/proglang-enabled-p 'ocaml)
  ;; Ocaml user setup
  ;; <<ocaml/user-setup>>
  ;; Merlin
  <<ocaml/merlin>>
  ;; Utop
  <<ocaml/utop>>
  ;; Tuareg
  <<ocaml/tuareg>>
  ;; Dune
  <<ocaml/dune>>
  ;; Reason Mode
  <<ocaml/reason>>
  ;; Caml mode
  <<ocaml/caml>>
  ;; Lsp mode
  <<ocaml/lsp>>
  ;; Setup LSP
  <<ocaml/setup>>
) ;; End Ocaml
#+END_SRC

**** Ocaml User Setup :disabled:

#+NAME: ocaml/user-setup
#+BEGIN_SRC emacs-lisp :tangle no
(let ((opam-user-setup-dir (no-littering-expand-etc-file-name "opam-user-setup")))
  (if (file-directory-p opam-user-setup-dir)
      (load-file (expand-file-name "opam-user-setup.el" opam-user-setup-dir))))
#+END_SRC

**** Utop

#+NAME: ocaml/utop
#+BEGIN_SRC emacs-lisp :tangle no
(use-package utop)
#+END_SRC

**** Merlin

#+NAME: ocaml/merlin
#+BEGIN_SRC emacs-lisp :tangle no
(use-package merlin
  :custom
  (merlin-command 'opam)
  (merlin-error-after-save nil)
  :init
  (defun ocaml/merlin ()
    "Enable merlin mode."
    (if (functionp 'merlin-mode)
        (merlin-mode))))
#+END_SRC

**** Flycheck Ocaml

#+NAME: ocaml/flycheck
#+BEGIN_SRC emacs-lisp :tangle no
(use-package flycheck-ocaml)

#+END_SRC

**** Caml mode

#+NAME: ocaml/caml
#+BEGIN_SRC emacs-lisp :tangle no
(use-package caml
  :init

  (defun caml/lsp ()
    (when (functionp 'ocaml/setup-lsp)
      (ocaml/setup-lsp)))

  :hook
  (caml . caml/lsp)
  (caml . ocaml/merlin))
#+END_SRC

**** Tuareg

#+NAME: ocaml/tuareg
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package tuareg
    :mode
    ("\\.ml\\'" . tuareg-mode)

    :init
    (defun tuareg/prettify-symbols ()
      "Enable `prettify-symbols-mode' for `tuareg-mode'."
      (when (functionp 'prettify-symbols-mode)
        (prettify-symbols-mode)))

    (defun tuareg/lsp ()
      "Enable `lsp-ocaml' for `tuareg-mode'."
      (when (functionp 'ocaml/setup-lsp)
        (ocaml/setup-lsp)))

    (defun tuareg/flycheck ()
      (when (locate-library "flycheck-ocaml")
        (unless (and (featurep 'flycheck-ocaml)
                   (bound-and-true-p flycheck-ocaml/enable))
          (require 'flycheck-ocaml))
        (halidom/flycheck-enable-hook)

        (when (and (featurep 'merlin)
                 (bound-and-true-p merlin-error-after-save))
          (flycheck-ocaml-setup))))

    :hook
    (tuareg-mode . tuareg/prettify-symbols)
    (tuareg-mode . tuareg/flycheck)
    (tuareg-mode . tuareg/lsp)
    (tuareg-mode . ocaml/merlin))
#+END_SRC

**** Dune

#+NAME: ocaml/dune
#+BEGIN_SRC emacs-lisp :tangle no
(use-package dune
  :straight (dune
             :host github
             :type git
             :repo "ocaml/dune"
             :files ("editor-integration/emacs/dune"
                     "editor-integration/emacs/dune.el"
                     "editor-integration/emacs/dune-flymake.el"))
  :mode
  ("dune\\'" . dune-mode)
  ("dune-project\\'" . dune-mode)

  :ensure-system-package
  (dune . "opam install dune")

  :init

  (require 'dune)

  (with-eval-after-load 'projectile
    (projectile-register-project-type 'dune
                                      '("dune-project")
                                      :compile "dune build"
                                      :test "dune runtest"
                                      :run "dune exec"))

  :hook
  (dune-mode . enable-paredit-mode))
#+END_SRC

**** Reason Mode

#+NAME: ocaml/reason
#+BEGIN_SRC emacs-lisp :tangle no
(use-package reason-mode
  :init
  (defun reason/lsp ()
    (when (functionp 'ocaml/setup-lsp)
      (ocaml/setup-lsp)))
  :hook
  (reason . reason/lsp)
  (reason . ocaml/merlin))
#+END_SRC

**** Lsp Ocaml

#+NAME: ocaml/lsp
#+BEGIN_SRC emacs-lisp :tangle no
(use-package lsp-ocaml
  :custom-face (lsp-face-highlight-write ((t nil)))
  :ensure-system-package
  (ocaml-language-server
   .
   "yarn global add ocaml-language-server")
  :commands lsp-ocaml-enable)
#+END_SRC

**** Setup Ocaml

#+NAME: ocaml/setup
#+BEGIN_SRC emacs-lisp :tangle no
(defun ocaml/setup-lsp ()
  (require 'lsp-mode)
  (require 'lsp-ocaml)
  (lsp-ocaml-enable))

#+END_SRC

*** Scala

#+NAME: lang/scala
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin Scala
(when (halidom/proglang-enabled-p 'scala)
  ;; Scala Mode
  <<scala-scala-mode>>
  ;; Scala SBT Mode
  <<scala-sbt-mode>>
) ;: End Scala
#+END_SRC

**** Scala Mode
#+NAME: scala-scala-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package scala-mode
  :interpreter
  ("scala" . scala-mode))
#+END_SRC

**** Sbt

#+NAME: scala-sbt-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package sbt-mode
  :commands (sbt-start sbt-command)
  :config
  ;; WORKAROUND: https://github.com/ensime/emacs-sbt-mode/issues/31
  ;; allows using SPACE when in the minibuffer
  (substitute-key-definition
   'minibuffer-complete-word
   'self-insert-command
   minibuffer-local-completion-map))
#+END_SRC

*** Web

#+NAME: lang/web
#+BEGIN_SRC emacs-lisp :noweb yes :tangle yes :exports none
;; Begin Web Configuration
(when (halidom/proglang-enabled-p 'web)
   ;; Web Mode
   <<web-web-mode>>
   ;; Tagedit Mode
   <<web-tagedit>>
   ;; Htmlize
   <<web-htmlize>>
   ;; CSS
   <<web-css>>
   ;; Emmet Mode
   <<web-emmet>>
   ;; Company Tern
   <<web-tern>>
   ;; Company Web
   <<web-company>>
   ;; Web LSP
   <<web-lsp>>

) ;; End Web Configuration
#+END_SRC

**** Web Mode

#+NAME: web-web-mode
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package web-mode
    :bind
    (:map web-mode-map
          ;; I should rebind this because it conficts
          ;; with `company-select-next-or-abort'
          ("M-n" . web-mode-tag-match))
    :mode
    (("\\.phtml\\'"      . web-mode)
     ("\\.tpl\\.php\\'"  . web-mode)
     ("\\.twig\\'"       . web-mode)
     ("\\.html\\'"       . web-mode)
     ("\\.htm\\'"        . web-mode)
     ("\\.[gj]sp\\'"     . web-mode)
     ("\\.as[cp]x?\\'"   . web-mode)
     ("\\.eex\\'"        . web-mode)
     ("\\.erb\\'"        . web-mode)
     ("\\.mustache\\'"   . web-mode)
     ("\\.handlebars\\'" . web-mode)
     ("\\.hbs\\'"        . web-mode)
     ("\\.eco\\'"        . web-mode)
     ("\\.ejs\\'"        . web-mode)
     ("\\.djhtml\\'"     . web-mode)
     ("\\.tsx\\'"        . web-mode))

    :config
    (setq web-mode-engines-alist
          '(("php" . "\\.phtml\\'")
            ("blade" . "\\.blade\\'")))

    (defun halidom/web-mode-enable ()
      "Enabled web-mode options."
      (setq web-mode-enable-auto-pairing t
            web-mode-enable-css-colorization t
            web-mode-enable-block-face t
            web-mode-enable-part-face t
            web-mode-enable-comment-keywords t
            web-mode-enable-heredoc-fontification t
            web-mode-enable-current-element-highlight t
            web-mode-enable-current-column-highlight t)
      )


    (defun halidom/web-mode-tide ()
      "Enable tide-mode in Typescript tsx buffers."
      (when (string-equal "tsx" (file-name-extension buffer-file-name))
        (setup-tide-mode)
        (flycheck-add-mode 'typescript-tslint 'web-mode)))

    (add-hook 'web-mode-hook #'halidom/web-mode-tide)

    (defun halidom/web-mode-indent ()
      "Indentation settings for web-mode."
      (setq web-mode-markup-indent-offset 2
            web-mode-code-indent-offset 2
            web-mode-style-padding 1
            web-mode-script-padding 1
            web-mode-block-padding 0
            web-mode-comment-style 2))

    (defun halidom/web-mode-style ()
      "Styleguide for web-mode."
      (halidom/web-mode-enable)
      (halidom/web-mode-indent))

    (defun halidom/web-mode-flycheck ()
      (when (fboundp 'flycheck-mode)
        (flycheck-mode +1)))

    (add-hook 'web-mode-hook #'halidom/web-mode-flycheck)

    (add-hook 'web-mode-hook #'halidom/web-mode-style)

    (defun halidom/web-dash-docsets ()
      (setq-local dash-plugin-keywords
                  '("css" "html" "javascript" "react")))
    (when *is-mac*
      (add-hook 'web-mode-hook #'halidom/web-dash-docsets)))
#+END_SRC

**** Tag Edit

#+NAME: web-tagedit
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package tagedit
    :init
    (defun halidom/tagedit-enable ()
      (tagedit-add-experimental-features)
      (tagedit-mode +1))

    :hook
    (html-mode . halidom/tagedit-enable)

    :blackout t)
#+END_SRC

**** Htmlize

#+NAME: web-htmlize
#+BEGIN_SRC emacs-lisp :tangle no
(use-package htmlize
  :straight t)
#+END_SRC

**** LSP HTML

#+NAME: web-lsp
#+BEGIN_SRC emacs-lisp :tangle no
(use-package lsp-html
    :if (executable-find "html-languageserver")
    :commands (lsp-html-enable)
    :init
    (require 'lsp-html)
    (defun html-lsp-setup ()
      (when (string-equal "html" (file-name-extension buffer-file-name))
        (lsp-html-enable)
        (flycheck-add-mode 'html-tidy 'web-mode)))
    :hook (web-mode . html-lsp-setup))


#+END_SRC

**** CSS

#+NAME: web-css
#+BEGIN_SRC emacs-lisp :tangle no :noweb yes :exports none
;; Begin CSS
<<css-css-mode>>
;; Less Mode
<<css-less-mode>>
;; Sass Mode
<<css-sass-mode>>
;; SCSS Mode
<<css-scss-mode>>
;; CSS LSP
<<css-css-lsp>>
;; CSS Backends
<<css-backends>>
;; End CSS
#+END_SRC

***** CSS Mode

#+NAME: css-css-mode
#+BEGIN_SRC emacs-lisp :tangle no

  (use-package css-mode
    :commands (css-expand-statment css-contrac-statement)
    :custom (css-indent-offset )
    :init
    (defun css-expand-statment ()
      (interactive)
      (save-excursion
        (end-of-line)
        (search-backward "{")
        (forward-char 1)
        (while (or (eobp) (not (looking-at "}")))
          (let ((beg (point)))
            (newline)
            (search-forward ";")
            (indent-region beg (point))))
        (newline)))

    (defun css-contrac-statement ()
      "Contract CSS Block"
      (interactive)
      (end-of-line)
      (search-backward "{")
      (while (not (looking-at "}"))
        (join-line -1)))

    (defun css/style ()
      (setq css-indent-offset 2))

    :hook
    (css-mode . css/style))
#+END_SRC

***** CSS LSP

#+NAME: css-css-lsp
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package lsp-css
    :if (executable-find "css-language-server")
    :commands (lsp-css-enable
               lsp-less-enable
               lsp-scss-enable
               lsp-scss-enable))
#+END_SRC

***** Less

#+NAME: css-less-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package less-mode
    :mode "\\.less\\'")
#+END_SRC

***** SASS

#+NAME: css-sass-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package sass-mode
  :mode "\\.sass\\'")
#+END_SRC

***** SCSS

#+NAME: css-scss-mode
#+BEGIN_SRC emacs-lisp :tangle no
(use-package scss-mode
    :mode "\\.scss\\'")
#+END_SRC

***** Setup CSS Backends

#+NAME: css-backends
#+BEGIN_SRC emacs-lisp :tangle no
(defun css-mode-setup ()
  (when (eq major-mode 'css-mode)
    ;; Only enable in strictly css-mode, not scss-mode (css-mode-hook
    ;; fires for scss-mode because scss-mode is derived from css-mode)
    (require 'lsp-css)
    (lsp-css-enable)))

(defun less-mode-setup ()
  (require 'lsp-css)
  (lsp-less-enable))

(defun scss-mode-setup ()
  (require 'lsp-css)
  (lsp-scss-enable))

(add-hook 'css-mode-hook #'css-mode-setup)
(add-hook 'less-mode-hook #'less-mode-setup)
(add-hook 'sass-mode-hook #'scss-mode-setup)
(add-hook 'scss-mode-hook #'scss-mode-setup)
#+END_SRC

**** Emmet

#+NAME: web-emmet
#+BEGIN_SRC emacs-lisp :tangle no
(use-package emmet-mode
  :init
  (add-to-hooks 'emmet-mode
                '(css-mode-hook html-mode-hook web-mode-hook)))
#+END_SRC

**** Tern

#+NAME: web-tern
#+BEGIN_SRC emacs-lisp :tangle no
(use-package tern
  :if (executable-find "tern"))

(use-package company-tern
    :after (:all company tern)
    :demand t)
#+END_SRC

**** Company Web

[[https://github.com/osv/company-web][Company Web]] provides code completion for html-mode, web-mode, jade-mode,
and slim-mode using company.

#+NAME: web-company
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-web
  :after (:all company web-mode)
  :demand t
  :init
  (defun halidom/company-web-mode-enable ()
    "Enable company web-mode backends."
    (let ((backends '(company-web-html company-yasnippet company-files)))
      (when (featurep 'company-tern)
        (advice-add 'company-tern :before
                    #'(lambda (&rest _)
                        (if (equal major-mode 'web-mode)
                            (let ((web-mode-cur-language
                                   (web-mode-language-at-pos)))
                              (if (or (string= web-mode-cur-language "javascript")
                                      (string= web-mode-cur-language "jsx"))
                                  (unless tern-mode (tern-mode))
                                (if tern-mode (tern-mode -1)))))))
        (setq backends (push 'company-tern backends)))
      (set (make-local-variable 'company-backends) backends)))


  (add-hook 'web-mode-hook #'halidom/company-web-mode-enable))

#+END_SRC

*** Markdown

#+NAME: md-spec
#+BEGIN_SRC emacs-lisp :tangle yes :noweb yes :exports none
;; Begin Markdown Configuration
(when (halidom/proglang-enabled-p 'markdown)
  ;; Markdown Mode
  <<md-markdown-mode>>
  ;; Markdown-Mode+
  <<md-markdown-mode-plus>>
  ;; Markdown Toc
  <<md-markdown-toc>>
  ;; Markdownfmt
  <<md-markdownfmt>>
  ;; Livedown
  <<md-livedown>>
) ;; End Markdown Configuration
#+END_SRC

**** Markdown Mode

- See https://jblevins.org/projects/markdown-mode/

#+NAME md-markdown-mode
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package markdown-mode
      :custom
    (markdown-command "markdown")
      :mode
      (("README\\.md\\'" . gfm-mode)
       ("\\.md\\'" . markdown-mode)
       ("\\.markdown\\'" . markdown-mode))

      :init
      (defun md-setup ()
        "Setup markdown mode"
        (when (functionp 'macos-open-with-default-app)
          (setq markdown-open-command 'macos-open-with-default-app)))

      :hook
      ((markdown-mode gfm-mode) . md-setup)
      ((markdown-mode gfm-mode) . halidom/vfc-hook))
#+END_SRC


**** markdown-mode+

#+NAME: md-markdown-mode-plus
#+BEGIN_SRC emacs-lisp :tangle no
(use-package markdown-mode+)
#+END_SRC

**** markdown-toc

#+NAME: md-markdown-toc
#+BEGIN_SRC emacs-lisp :tangle no
(use-package markdown-toc)
#+END_SRC

**** markdownfmt

#+NAME: md-markdownfmt
#+BEGIN_SRC emacs-lisp :tangle no
(use-package markdownfmt
  :bind (:map markdown-mode-map
	      ("C-c C-f" . markdown-format-buffer))
  :hook
  (markdown-mode . markdownfmt-enable-on-save))
#+END_SRC

**** Livedown

#+NAME: md-livedown
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package livedown
      :straight (livedown
                 :type git
                 :host github
                 :repo "shime/emacs-livedown")
      :custom (livedown-open nil)
      :init

      (when (featurep 'xwidget-internal)
        (unless (featurep 'xwidget)
          (require 'xwidget))

        (defadvice livedown-preview (after livedown-preview-after activate)
          (xwidget-webkit-browse-url "http://localhost:1337"))))
#+END_SRC

* Misc
** Scimax

#+NAME: research/scimax
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package scimax
  :straight nil
  :if (file-directory-p (emacs-etc-dir "local" "scimax"))
  :custom
  (scimax-dir (emacs-etc-dir "local" "scimax"))
  (scimax-snippet-dir (car yas-snippet-dirs))
  :load-path "etc/local/scimax"
  :init
  (setq ore-user-directory (emacs-etc-dir "ore"))
  (require 'scimax-ivy)
  (require 'scimax-latex)
  (require 'scimax-utils)
  (require 'scimax-yas)
  (require 'scimax-link-thumbnails)
  (require 'ore)
  (require 'ox-word))
#+END_SRC

** Alfred Org Capture

#+BEGIN_SRC emacs-lisp :tangle yes
(when *is-mac*
  (load-file (no-littering-expand-etc-file-name
              "local/alfred-org-capture/alfred-org-capture.el")))
#+END_SRC

** ESS :disabled:

#+NAME: research/ess
#+BEGIN_SRC emacs-lisp :tangle no
  ;; (use-package ess)
#+END_SRC

* Prologue

#+BEGIN_SRC emacs-lisp :tangle yes :exports none

;;; end halidom.el

#+END_SRC

* Known Issues
** ~halidom-literate-config-file~ is added to ~org-agenda-files~
** dashboard buffer not  found when setting value of initial buffer
** Improper font locking by ~org-highlight-latex-and-related~

Makes emacs really slow.

See[[id:8E0531C6-0E85-4F0A-9340-2868F54F3A6D][ Highlight inline LaTeX fragments]] for temporary fix.

* Footnotes

[fn:1] [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Library-Headers.html#Library-Headers][Emacs Manual - D.8 Conventional Headers for Emacs Libraries]]

[fn:2]  "Next-generation, purely functional package manager for the
Emacs hacker."

[fn:3] [[https://www.gnu.org/software/emacs/manual/html_node/emacs/General-Variables.html#General-Variables][Emacs Manual - C.4.1 General Variables]]

[fn:4] In lisp, global variables are called /top-level defintions/. By
convention, globals are wrapped in a pair of asterisks called
/earmuffs/. Earmuffs are completely optional -- they have no effect on
how the program is compiled -- its a best practice in all of the many
dialects of Lisp.

[fn:5] [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Conditionals.html][Emacs Manual - 10.2 Conditionals]]

[fn:9] [[https://www.emacswiki.org/emacs/EmacsForMacOS][Emacs Wiki - Emacs For MacOS]]

[fn:6] [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html][Emacs Manual - 51.1.4 Saving Customizations]]

[fn:7] [[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources][Mastering Emacs - Keeping Secrets in Emacs GnuPG Auth Sources]]

[fn:8] [[https://www.quora.com/Is-Windows-POSIX-compliant][Quora - Is Windows POSIX compliant?]]

[fn:10] http://www.jonathanleroux.org/bibtex-mode.html

[fn:11] http://mbork.pl/2018-04-28_org-mru-clock

[fn:12] [[https://matt.hackinghistory.ca/2015/11/11/note-taking-with-pdf-tools/][Note taking with pdf-tools]]

[fn:14] [[https://github.com/d12frosted/homebrew-emacs-plus][d12frosted/homebrew-emacs-plus]]

[fn:13] [[https://www.emacswiki.org/emacs/NeoTree][Emacs Wiki - NeoTree]]

[fn:15] [[https://www.emacswiki.org/emacs/WindowResize][Emacs Wiki - Window Resize]]

[fn:16] https://www.emacswiki.org/emacs/BookMarks#toc7

[fn:17] https://joelkuiper.eu/spellcheck_emacs

[fn:18] [[http://ergoemacs.org/emacs/dictionary_lookup.html][Ergo Emacs - Dictionary Lookup]]

[fn:19] [[http://www.modernemacs.com/#spacemacs][Modern Emacs]]




